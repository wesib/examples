{"version":3,"file":"lib.a89aa200.module.js","sources":["../../node_modules/call-thru/src/next-call.ts","../../node_modules/call-thru/src/passed-thru.ts","../../node_modules/call-thru/src/call-thru.ts","../../node_modules/call-thru/src/misc/asis.ts","../../node_modules/call-thru/src/misc/noop.ts","../../node_modules/call-thru/src/misc/presence.ts","../../node_modules/call-thru/src/misc/value-providers.ts","../../node_modules/call-thru/src/passes/args.ts","../../node_modules/call-thru/src/passes/each.ts","../../node_modules/call-thru/src/passes/iteration.ts","../../node_modules/call-thru/src/passes/skip.ts","../../node_modules/a-iterable/src/api.ts","../../node_modules/a-iterable/src/revertible-iterable.ts","../../node_modules/a-iterable/src/util.ts","../../node_modules/a-iterable/src/reverse.ts","../../node_modules/a-iterable/src/termination.ts","../../node_modules/a-iterable/src/thru.ts","../../node_modules/a-iterable/src/transform.ts","../../node_modules/a-iterable/src/a-iterable.ts","../../node_modules/a-iterable/src/construction.ts","../../node_modules/a-iterable/src/objects.ts","../../node_modules/fun-events/src/event-keeper.ts","../../node_modules/fun-events/src/event-supply.ts","../../node_modules/fun-events/src/event-receiver.ts","../../node_modules/fun-events/src/event-sender.ts","../../node_modules/fun-events/src/event-notifier.ts","../../node_modules/fun-events/src/on-event.ts","../../node_modules/fun-events/src/after-event.ts","../../node_modules/fun-events/src/dom/on-dom-event.ts","../../node_modules/fun-events/src/dom/dom-event-dispatcher.ts","../../node_modules/fun-events/src/event-emitter.ts","../../node_modules/fun-events/src/keepers/after-all.ts","../../node_modules/fun-events/src/keepers/after-each.ts","../../node_modules/fun-events/src/senders/on-any.ts","../../node_modules/fun-events/src/state/state-path.ts","../../node_modules/fun-events/src/state/state-tracker.ts","../../node_modules/fun-events/src/value/value-tracker.ts","../../node_modules/fun-events/src/value/track-value.ts","../../node_modules/fun-events/src/value/value-sync.ts","../../node_modules/context-values/src/context-key.ts","../../node_modules/context-values/src/context-key-error.ts","../../node_modules/context-values/src/context-value-spec.ts","../../node_modules/context-values/src/context-values.ts","../../node_modules/context-values/src/context-registry.ts","../../node_modules/context-values/src/context-up-key.ts","../../node_modules/context-values/src/fn-context-key.ts","../../node_modules/context-values/src/simple-context-key.ts","../../node_modules/namespace-aliaser/src/naming.ts","../../node_modules/namespace-aliaser/src/namings.ts","../../node_modules/namespace-aliaser/src/namespace.ts","../../node_modules/namespace-aliaser/src/default.ns.ts","../../node_modules/namespace-aliaser/src/name.ts","../../node_modules/namespace-aliaser/src/namespace-aliaser.ts","../../node_modules/http-header-value/src/hthv-partial.impl.ts","../../node_modules/http-header-value/src/parser/add-param.ts","../../node_modules/http-header-value/src/parser/next-in-item.ts","../../node_modules/http-header-value/src/parser/parse-date-time.ts","../../node_modules/http-header-value/src/parser/parse-none.ts","../../node_modules/http-header-value/src/parser/item-parser.ts","../../node_modules/http-header-value/src/parser/quoted-string-parser.ts","../../node_modules/http-header-value/src/parser/angle-brackets-parser.ts","../../node_modules/http-header-value/src/parser/next-in-comment.ts","../../node_modules/http-header-value/src/parser/spaces-parser.ts","../../node_modules/http-header-value/src/parser/param-parser.ts","../../node_modules/http-header-value/src/parser/parser-config.ts","../../node_modules/http-header-value/src/hthv-parser.ts","../../node_modules/http-header-value/src/parser/item-delimit-parser.ts","../../node_modules/http-header-value/src/parser/comment-parser.ts","../../node_modules/http-header-value/src/custom/hthv-parse-commented.ts","../../node_modules/http-header-value/src/custom/hthv-parse-directives.ts","../../node_modules/http-header-value/src/custom/hthv-parse-uris.ts","../../node_modules/http-header-value/src/hthv-parse.ts","../../node_modules/http-header-value/src/hthv-quote.ts","../../node_modules/cssesc/cssesc.js","../../node_modules/hyphenate-style-name/index.js","../../node_modules/style-producer/src/internal/css.ts","../../node_modules/style-producer/src/internal/types.ts","../../node_modules/style-producer/src/value/value.ts","../../node_modules/style-producer/src/value/color/color.ts","../../node_modules/style-producer/src/value/color/mix.ts","../../node_modules/style-producer/src/value/numeric/numeric.ts","../../node_modules/style-producer/src/value/mapper.ts","../../node_modules/style-producer/src/value/numeric/numeric.impl.ts","../../node_modules/style-producer/src/value/numeric/zero.impl.ts","../../node_modules/style-producer/src/value/numeric/dimension-kind.impl.ts","../../node_modules/style-producer/src/value/unit/angle.ts","../../node_modules/style-producer/src/value/unit/frequency.ts","../../node_modules/style-producer/src/value/unit/length.ts","../../node_modules/style-producer/src/rule/properties.impl.ts","../../node_modules/style-producer/src/selector/selector.impl.ts","../../node_modules/style-producer/src/selector/query.ts","../../node_modules/style-producer/src/selector/selector-constructor.ts","../../node_modules/style-producer/src/selector/selector-text.impl.ts","../../node_modules/style-producer/src/producer/properties.render.ts","../../node_modules/style-producer/src/value/priority.ts","../../node_modules/style-producer/src/producer/options.impl.ts","../../node_modules/style-producer/src/producer/produce-basic-style.ts","../../node_modules/style-producer/src/producer/render.impl.ts","../../node_modules/style-producer/src/selector/selector-text.ts","../../node_modules/style-producer/src/rule/rule.ts","../../node_modules/style-producer/src/rule/rules.impl.ts","../../node_modules/style-producer/src/rule/rule.impl.ts","../../node_modules/style-producer/src/rule/root.ts","../../node_modules/style-producer/src/rule/rule-ref.ts","../../node_modules/style-producer/src/rule/rule-refs.ts","../../node_modules/style-producer/src/rule/rules.ts","../../node_modules/input-aspects/src/aspect.ts","../../node_modules/input-aspects/src/aspect.impl.ts","../../node_modules/input-aspects/src/control.ts","../../node_modules/input-aspects/src/container/container.control.ts","../../node_modules/input-aspects/src/container/parents.aspect.ts","../../node_modules/input-aspects/src/element.control.ts","../../node_modules/input-aspects/src/data/mode.aspect.ts","../../node_modules/input-aspects/src/data/data.aspect.ts","../../node_modules/input-aspects/src/container/group.control.ts","../../node_modules/input-aspects/src/validation/require-nothing.validator.ts","../../node_modules/input-aspects/src/validation/validator.ts","../../node_modules/input-aspects/src/validation/validator.impl.ts","../../node_modules/input-aspects/src/validation/validation.aspect.ts","../../node_modules/input-aspects/src/validation/require-all.validator.ts","../../node_modules/input-aspects/src/validation/require-present.validator.ts","../../node_modules/input-aspects/src/element/element.impl.ts","../../node_modules/input-aspects/src/element/text.control.ts","../../node_modules/input-aspects/src/focus/focus.aspect.ts","../../node_modules/input-aspects/src/focus/status.aspect.ts","../../node_modules/input-aspects/src/style/styled-element.aspect.ts","../../node_modules/input-aspects/src/style/css-classes.aspect.ts","../../node_modules/input-aspects/src/style/css-info.ts"],"sourcesContent":["/**\n * @module call-thru\n */\nimport { CallOutcome } from './call-outcome';\n\n/**\n * A key of a [[NextCall]] method responsible for calling the next function in chain.\n */\nexport const NextCall__symbol = /*#__PURE__*/ Symbol('next-call');\n\n/**\n * A key of a [[NextCall]] method responsible for returning the outcome of the las pass in chain.\n */\nexport const NextCall_lastOutcome__symbol = /*#__PURE__*/ Symbol('next-call:last-outcome');\n\n/**\n * A call of the next function in chain.\n *\n * This is basically a function with additional method, which is treated specially by call chaining functions.\n * When previous function in chain returns a [[NextCall]] instance, it will be used to call the next function in chain.\n * Otherwise the next function will be called with single argument containing a value returned.\n *\n * A [[NextCall]] is a function returning itself. So it can be chained like any other function.\n *\n * A [[nextCall]] function can be used to construct a next call.\n *\n * @typeparam OutKind  A kind of the call outcome.\n * @typeparam NextThis  A type of `this` context object reference of the next function.\n * @typeparam NextArgs  A type of argument tuple of the next function.\n * @typeparam NextReturn  A return type of the next function.\n * @typeparam Out  A type of the next function call outcome.\n * @typeparam Last  A type of the outcome of the next call returned from the last pass in chain.\n */\nexport abstract class NextCall<\n    OutKind extends CallOutcome.Kind,\n    NextArgs extends any[],\n    NextReturn,\n    Out = NextReturn,\n    Last = CallOutcome.OfKind<OutKind, NextArgs[0], Out>> extends Function {\n\n  /**\n   * Checks whether the `target` value is a next function call.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true`.\n   */\n  static is<V extends NextCall.Any>(target: V): target is V;\n\n  /**\n   * Checks whether the `target` value is a next function call.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true` if the `target` value is a function with a `[NextCall.mark]` property, or `false` otherwise.\n   */\n  static is(target: any): target is NextCall.Any;\n\n  static is(target: any): target is NextCall.Any {\n    return typeof target === 'function' && NextCall__symbol in target;\n  }\n\n  /**\n   * Converts a value returned from previous chained function call to the call of the next function in chain.\n   *\n   * @param nextCall  A next function call to return.\n   *\n   * @returns A `nextCall` itself.\n   */\n  static of<V extends NextCall.Any>(nextCall: V): V;\n\n  /**\n   * Converts a value returned from previous chained function call to the call of the next function in chain.\n   *\n   * @param value  A value to convert.\n   *\n   * @returns Either a `value` itself if it is a next function call, or a new next function call instance that passes\n   * a `value` as the only argument to the callee.\n   */\n  static of<V, Out>(value: V): NextCall<'default', [V], Out, Out, Out>;\n\n  static of<V, NextReturn>(value: V): NextCall<any, NextCall.Callee.Args<V>, NextReturn> {\n    if (NextCall.is(value)) {\n      return value;\n    }\n    return nextCall((callee: any) => callee(value));\n  }\n\n  /**\n   * Calls the next function in chain.\n   *\n   * This is invoked only when there _is_ a next function. When next call is returned by the last pass a\n   * `[NextCall_lastOutcome__symbol]()` is invoked instead.\n   *\n   * @param callee  A function to call.\n   *\n   * @returns A call outcome.\n   */\n  abstract [NextCall__symbol](callee: (this: void, ...args: NextArgs) => NextReturn): Out;\n\n  /**\n   * Builds an outcome of the last pass in chain.\n   *\n   * This is invoked for the last pass in chain only. If there is the next pass, a `[NextCall__symbol]()` is invoked\n   * instead.\n   */\n  abstract [NextCall_lastOutcome__symbol](): Last;\n\n}\n\nexport interface NextCall<\n    OutKind extends CallOutcome.Kind,\n    NextArgs extends any[],\n    NextReturn,\n    Out = NextReturn,\n    Last = CallOutcome.OfKind<OutKind, NextArgs[0], Out>> {\n\n  /**\n   * Returns itself to add it to functions chain.\n   */\n  (): NextCall<OutKind, NextArgs, NextReturn, Out, Last>; // tslint:disable-line:callable-types\n\n}\n\nexport namespace NextCall {\n\n  /**\n   * Any call of the next function.\n   */\n  export type Any = NextCall<any, any, any, any, any>;\n\n  export namespace Callee {\n\n    /**\n     * Arguments tuple type of a callee. Either extracted from [[NextCall]], or consisting of single argument of type\n     * `V`.\n     */\n    export type Args<V> = V extends NextCall<any, infer NextArgs, any, any, any> ? NextArgs : [V];\n\n    /**\n     * A return type of a callee. Either extracted from [[NextCall]], or `V` itself.\n     */\n    export type Return<V> = V extends NextCall<any, any, infer NextReturn, any, any> ? NextReturn : V;\n\n  }\n\n  /**\n   * A type of next call outcome. Either extracted from [[NextCall]], or `Return`.\n   */\n  export type Outcome<V, Return> = V extends NextCall<infer OutKind, any, any, infer Out, any>\n      ? CallOutcome.OfKind<OutKind, Return, Out>\n      : Return;\n\n  /**\n   * A type of last call outcome. Either extracted from the last call, or the value itself.\n   */\n  export type LastOutcome<V> = V extends NextCall<any, any, any, any, infer Last> ? Last : V;\n\n  /**\n   * A type of the result returned from chained function call, except for the last one.\n   *\n   * This may be either a [[NextCall]] instance, or single value.\n   *\n   * In any case the result provides arguments for the next pass in chain and thus should be compatible with next\n   * function signature.\n   *\n   * @typeparam NextArgs  A type of argument tuple of the next function in chain.\n   */\n  export type CallResult<NextArgs extends any[]> =\n      NextArgs extends [infer Result]\n          // Next function expects single argument.\n          // So the previous one may return either a single value, or a [[NextCall]] with compatible argument.\n          ? (Result | NextCall<any, NextArgs, any, any, any>)\n          // Next function expects multiple arguments.\n          // So the previous one should always return a [[NextCall]] instance with compatible arguments.\n          : NextCall<any, NextArgs, any, any, any>;\n\n  /**\n   * A result returned by last function in chain.\n   *\n   * This may be either a [[NextCall]] instance, or single value.\n   *\n   * @typeparam Last  A type of outcome of the last pass in chain.\n   */\n  export type LastResult<Last> =\n      Last | NextCall<any, any, any, any, Last>;\n\n}\n\nconst firstArg: (...args: any[]) => any = (arg: any) => arg;\n\n/**\n * Constructs a call to the next function.\n *\n * @param callNext  A next function caller function.\n * @param lastOutcome  A function building an outcome of the last pass in chain.\n *\n * @returns A next function call performed by the given `callNext` function.\n */\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out, Last>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out,\n    lastOutcome: (this: void) => Last):\n    NextCall<OutKind, NextArgs, NextReturn, Out, Last>;\n\n/**\n * Constructs a call to the next function with default last pass outcome implementation.\n *\n * The last pass outcome is detected by passing to `callNext` a function that just returns its first argument.\n *\n * @param callNext  A next function caller function.\n *\n * @returns A next function call performed by the given `callNext` function.\n */\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out):\n    NextCall<OutKind, NextArgs, NextReturn, Out>;\n\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out, Last>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out,\n    lastOutcome: (this: void) => Last = () => callNext(firstArg) as any):\n    NextCall<OutKind, NextArgs, NextReturn, Out, Last> {\n\n  const result = (() => result) as NextCall<OutKind, NextArgs, NextReturn, Out, Last>;\n\n  result[NextCall__symbol] = callee => callNext(callee);\n  result[NextCall_lastOutcome__symbol] = lastOutcome;\n\n  return result;\n}\n","/**\n * @module call-thru\n */\n/**\n * A key of a [[PassedThru]] property containing the actual outcome value.\n */\nexport const PassedThru__symbol = /*#__PURE__*/ Symbol('passed-thru');\n\n/**\n * An chained pass outcome value wrapping the actual outcome.\n *\n * When the outcome of the last chained pass is a [[PassedThru]] instance, it is be replaced with the value of its\n * [[PassedThru__symbol]] property.\n *\n * Also extends an `Iterable` interface, so that e.g. [[nextEach]] and [[nextFlatEach]] unwrap the passed through value\n * to convert it to arbitrary number of elements. Including zero, which is the case when `nextSkip()` is returned.\n */\nexport abstract class PassedThru<V, I = V> implements Iterable<I> {\n\n  /**\n   * The actual passed thru value.\n   */\n  abstract readonly [PassedThru__symbol]: V;\n\n  /**\n   * Checks whether `target` value is a [[PassedThru]] instance.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true`.\n   */\n  static is<V extends PassedThru<any, any>>(target: V): target is V;\n\n  /**\n   * Checks whether `target` value is a [[PassedThru]] instance.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true` if the `target` value is an object with a [[PassedThru__symbol]] property, or `false` otherwise.\n   */\n  static is<V>(target: any): target is PassedThru<V, any>;\n\n  static is(target: any): target is PassedThru<any, any> {\n    return typeof target === 'object' && PassedThru__symbol in target;\n  }\n\n  /**\n   * Extracts the passed through value.\n   *\n   * @param outcome  The outcome to extract the value from.\n   *\n   * @returns A [[PassedThru__symbol]] property value is the given `outcome` is a [[PassedThru]] instance, or `outcome`\n   * itself otherwise.\n   */\n  static get<V>(outcome: V): PassedThru.Value<V> {\n    if (PassedThru.is<V>(outcome)) {\n      return outcome[PassedThru__symbol] as PassedThru.Value<V>;\n    }\n    return outcome as PassedThru.Value<V>;\n  }\n\n  /**\n   * Extracts the passed through items.\n   *\n   * @param outcome  The outcome to extract the items from.\n   *\n   * @return An iterable of passed through items if the the given `outcome` is a [[PassedThru]] instance, or an iterable\n   * containing the `outcome` itself otherwise.\n   */\n  static items<V>(outcome: V): Iterable<PassedThru.Item<V>> {\n    if (PassedThru.is<V>(outcome)) {\n      return outcome;\n    }\n    return {\n      * [Symbol.iterator]() {\n        yield outcome as PassedThru.Item<V>;\n      }\n    };\n  }\n\n  abstract [Symbol.iterator](): Iterator<I>;\n\n}\n\nexport namespace PassedThru {\n\n  /**\n   * A type of the passed though value.\n   */\n  export type Value<V> = V extends PassedThru<infer T, any> ? T : V;\n\n  /**\n   * A type of the passed though item.\n   */\n  export type Item<V> = V extends PassedThru<any, infer I> ? I : V;\n\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from './next-call';\nimport { PassedThru } from './passed-thru';\nimport Last = NextCall.LastResult;\nimport Out = NextCall.Outcome;\nimport Result = NextCall.CallResult;\n\n/**\n * Constructs a function that invokes the chained passes.\n *\n * Each pass is function accepts argument(s) passed from the previous one.\n *\n * The value returned from the pass is treated the following way:\n *\n * - When a [[NextCall]] is returned, this instance is used to perform the next function call.\n * - When plain value returned, this value is passed to the next function as the only argument.\n * - When a [[NextCall]] is returned by the last pass, it is used to construct the outcome.\n * - When a plain value is returned by the last pass, it is used as outcome.\n *\n * A [[NextCall]] instance returned the pass is responsible for next function call and may modify the call outcome.\n */\nexport function callThru<P extends any[], R>(\n    fn: (this: void, ...args: P) => Last<R>,\n): (this: void, ...args: P) =>\n    PassedThru.Value<R>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => Last<R2>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, R2>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => Last<R3>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, R3>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => Last<R4>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, R4>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => Last<R5>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4, R5>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => Last<R6>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, R6>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => Last<R7>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, R7>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => Last<R8>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, R8>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => Last<R9>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, R9>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => Last<R10>):\n    (this: void, ...args: P1) => PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9, R10>>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => Last<R11>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9,\n            Out<R10, R11>>>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => Last<R12>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9,\n            Out<R10, Out<R11, R12>>>>>>>>>>>>;\n\nexport function callThru<\n    P1 extends any[], R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12 extends Result<P13>,\n    P13 extends any[], R13>(\n    fn1: (this: void, ...args: P1) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P7) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => R12,\n    fn13: (this: void, ...args: P13) => Last<R13>,\n): (this: void, ...args: P1) =>\n    PassedThru.Value<Out<R1, Out<R2, Out<R3, Out<R4,\n        Out<R5, Out<R6, Out<R7, Out<R8, Out<R9,\n            Out<R10, Out<R11, Out<R12, R13>>>>>>>>>>>>>;\n\nexport function callThru<R>(...fns: ((...args: any[]) => any)[]): (...args: any[]) => R {\n\n  function callNext(idx: number, prev: any): any {\n\n    const len = fns.length;\n\n    if (idx < len) {\n      // There is a next pass in chain\n      if (!NextCall.is(prev)) {\n        return callNext(idx + 1, fns[idx].call(null, prev));\n      }\n      return prev[NextCall__symbol](function (this: any, ...args: any[]) {\n        return callNext(idx + 1, fns[idx].apply(this, args));\n      });\n    }\n\n    // Last in chain\n    if (!NextCall.is(prev)) {\n      return prev;\n    }\n\n    return prev[NextCall_lastOutcome__symbol]();\n  }\n\n  return function (this: any, ...args: any[]) {\n    return PassedThru.get(callNext(1, fns[0].apply(this, args)));\n  };\n}\n","/**\n * @module call-thru\n */\n/**\n * A function that returns its argument as is.\n *\n * @param value  A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * @module call-thru\n */\n/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","/**\n * @module call-thru\n */\n/**\n * A function that checks whether the given value is present.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n","/**\n * @module call-thru\n */\n/**\n * Creates a provider of the only argument.\n *\n * @param value  A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return () => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return () => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return () => [...values] as T;\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, nextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\n\nexport interface NextArgs<Args extends any[], NextReturn>\n    extends NextCall<'default', Args, NextReturn, NextReturn, Args> {\n\n  (): NextArgs<Args, NextReturn>;\n\n  [NextCall__symbol](callee: (this: void, ...args: Args) => NextReturn): NextReturn;\n\n  [NextCall_lastOutcome__symbol](): Args;\n\n}\n\n/**\n * Constructs arguments for the next function call.\n *\n * When returned from the lass pass, the outcome will contain a tuple containing `args`.\n *\n * @param args  Next function call arguments.\n *\n * @return A next function call with the given arguments.\n */\nexport function nextArgs<Args extends any[], NextReturn>(...args: Args): NextArgs<Args, NextReturn> {\n  return nextCall(callee => callee.apply(undefined, args), () => args);\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, nextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\nimport { PassedThru } from '../passed-thru';\nimport { forEachItem, lastItems } from './iteration';\n\ndeclare module '../call-outcome' {\n  export namespace CallOutcome {\n    export interface Map<Return, Out> {\n\n      /**\n       * Iterable outcome type.\n       */\n      each(): Iterable<PassedThru.Item<NextCall.Callee.Return<Return>>>;\n\n    }\n  }\n}\n\nexport interface NextEach<NextItem, NextReturn> extends NextCall<\n    'each',\n    NextCall.Callee.Args<NextItem>,\n    NextReturn,\n    Iterable<PassedThru.Item<NextCall.Callee.Return<NextReturn>>>,\n    Iterable<PassedThru.Item<NextCall.LastOutcome<NextItem>>>> {\n\n  (): NextEach<NextItem, NextReturn>;\n\n  [NextCall__symbol](callee: (this: void, ...args: NextCall.Callee.Args<NextItem>) => NextReturn):\n      Iterable<PassedThru.Item<NextCall.Callee.Return<NextReturn>>>;\n\n  [NextCall_lastOutcome__symbol](): Iterable<PassedThru.Item<NextCall.LastOutcome<NextItem>>>;\n\n}\n\n/**\n * Creates an next call that invokes subsequent passes for each item in the given iterable.\n *\n * If `items` are [[NextCall]] implementations, then the next pass will be processed by them.\n *\n * When returned from the last pass, the chain outcome will be an iterable of the last pass outcomes of the `items`.\n * Or an iterable of `items` if they are not implementing [[NextCall]].\n *\n * @param items  An iterable of items to invoke the passes for.\n */\nexport function nextEach<NextItem, NextReturn>(items: Iterable<NextItem>): NextEach<NextItem, NextReturn> {\n  return nextCall(\n      callee => ({\n        [Symbol.iterator]() {\n          return forEachItem(items, callee);\n        },\n      }),\n      () => ({\n        [Symbol.iterator]() {\n          return lastItems(items);\n        },\n      }));\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\nimport { PassedThru } from '../passed-thru';\n\nexport function *forEachItem<NextItem, NextReturn>(\n    items: Iterable<NextItem>,\n    callee: (this: void, ...args: NextCall.Callee.Args<NextItem>) => NextReturn) {\n  for (const item of items) {\n    yield* PassedThru.items(\n        NextCall.is(item)\n            ? item[NextCall__symbol](callee)\n            : (callee as (arg: NextItem) => NextReturn)(item));\n  }\n}\n\nexport function *lastItems<NextItem>(items: Iterable<NextItem>) {\n  for (const item of items) {\n    yield* PassedThru.items(\n        NextCall.is(item)\n            ? item[NextCall_lastOutcome__symbol]()\n            : item);\n  }\n}\n\nexport function *flatItems<I>(items: Iterable<unknown>, depth: number): IterableIterator<any> {\n  if (!depth) {\n    yield *items;\n    return;\n  }\n  for (const item of items) {\n    if (isIterable(item)) {\n      yield *flatItems(item, depth - 1);\n    } else {\n      yield item;\n    }\n  }\n}\n\nfunction isIterable<I>(value: any): value is Iterable<I> {\n\n  const type = typeof value;\n\n  return (type === 'object' || type === 'function') && Symbol.iterator in value;\n}\n","/**\n * @module call-thru\n */\nimport { NextCall, nextCall, NextCall__symbol, NextCall_lastOutcome__symbol } from '../next-call';\nimport { PassedThru, PassedThru__symbol } from '../passed-thru';\n\ndeclare module '../call-outcome' {\n  export namespace CallOutcome {\n    export interface Map<Return, Out> {\n\n      /**\n       * Skipped call outcome type. Always `undefined`.\n       */\n      skip(): PassedThru<undefined, never>;\n\n    }\n  }\n}\n\nexport type SkippedThru = PassedThru<undefined, never>;\n\nexport interface NextSkip<NextArgs extends any[], NextReturn>\n    extends NextCall<'skip', NextArgs, NextReturn, SkippedThru> {\n\n  (): NextSkip<NextArgs, NextReturn>;\n\n  [NextCall__symbol](callee: (this: void, ...args: NextArgs) => NextReturn): SkippedThru;\n\n  [NextCall_lastOutcome__symbol](): SkippedThru;\n\n}\n\nconst SKIP: SkippedThru = {\n  [PassedThru__symbol]: undefined,\n  * [Symbol.iterator](): Iterator<never> {},\n};\n\nfunction _skip(): SkippedThru {\n  return SKIP;\n}\n\nconst _nextSkip: NextCall<'skip', any[], any, SkippedThru> = nextCall(_skip, _skip);\n\n/**\n * Constructs a next call that skips the rest of the chain.\n *\n * This has the same effect as `nextReturn(undefined)`.\n */\nexport function nextSkip<NextArgs extends any[], NextReturn>(): NextSkip<NextArgs, NextReturn> {\n  return _nextSkip as NextCall<'skip', NextArgs, NextReturn, SkippedThru>;\n}\n","/**\n * @module a-iterable\n */\n/**\n * A type of elements of iterable.\n *\n * @typeparam T  A type of iterable.\n */\nexport type IterableElement<T extends Iterable<any>> = T extends Iterable<infer E> ? E : never;\n\n/**\n * Arbitrary class implementing `Iterable` interface.\n *\n * @typeparam T  A type of iterable.\n * @typeparam E  A type of elements to iterate.\n */\nexport interface IterableClass<T extends Iterable<E>, E = IterableElement<T>> extends Function {\n  prototype: T;\n  new (...args: any[]): T;\n}\n\n/**\n * Checks whether the given value is array-like.\n *\n * @param target  A value to check.\n *\n * @returns `true` if the `value` has a `length` property, or `false` otherwise.\n */\nexport function isArrayLike<T>(target: any): target is ArrayLike<T> {\n  return 'length' in target;\n}\n","/**\n * @module a-iterable\n */\n/**\n * An iterable which elements order can be reversed.\n *\n * Arrays implement this interface.\n */\nexport interface RevertibleIterable<T> extends Iterable<T> {\n\n  /**\n   * Returns an iterable containing this iterable's elements in reverse order.\n   *\n   * Corresponds to `Array.prototype.reverse()`. Note however, that the array counterpart reverses elements _in place_\n   * rather than creating a new array.\n   *\n   * @return Reversed iterable instance.\n   */\n  reverse(): Iterable<T>;\n\n}\n\n/**\n * Checks whether the given iterable is revertible.\n *\n * This is always `true` for arrays.\n *\n * @param iterable  Iterable to check.\n *\n * @returns `true` if `iterable` has a `reverse` property, or `false` otherwise.\n */\nexport function itsRevertible<T>(iterable: Iterable<T>): iterable is RevertibleIterable<T> {\n  return 'reverse' in iterable;\n}\n","/**\n * @module a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * This is a shortcut for `iterable[Symbol.iterator]` to make it friendlier to minification.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n\n/**\n * Builds an iterable iterator over the given `iterable`.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterable<T>(iterable: Iterable<T>): IterableIterator<T> {\n  return function* () { yield* iterable; }();\n}\n\n/**\n * Creates custom iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  When `undefined` or unspecified the created iterable won't be reversible.\n *\n * @returns New iterable.\n */\nexport function makeIt<T>(iterate: (this: Iterable<T>) => Iterator<T>, reverse?: undefined): Iterable<T>;\n\n/**\n * Creates custom revertible iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  A no-arg function constructing a reverse iterable.\n *\n * @returns New reversible iterable.\n */\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse: (this: RevertibleIterable<T>) => Iterable<T>): RevertibleIterable<T>;\n\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse?: (this: RevertibleIterable<T>) => Iterable<T>): Iterable<T> {\n\n  const iterable: Iterable<T> = {\n    [Symbol.iterator]: iterate,\n  };\n\n  if (!reverse) {\n    return iterable;\n  }\n\n  const reversible = iterable as RevertibleIterable<T>;\n\n  reversible.reverse = reverse;\n\n  return reversible;\n}\n","/**\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Constructs a reversed iterable.\n *\n * If the `source` iterable is an array-like structure, then uses `reverseArray()` function to revert the constructed\n * iterable.\n * If the `source` iterable is revertible, then uses its `reverse()` method to revert the constructed one.\n * Otherwise stores elements to array and reverts them with `reverseArray()` function.\n *\n * @param source  A source iterable.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseIt<T>(source: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): Iterable<T> {\n  if (isArrayLike(source)) {\n    return reverseArray(source);\n  }\n  if (itsRevertible(source)) {\n\n    const reversed = source.reverse();\n\n    return makeIt(() => itsIterator(reversed));\n  }\n  return reverseArray([...source]);\n}\n\n/**\n * Constructs an iterable of array-like structure elements in reverse order.\n *\n * @param array  Source array.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseArray<T>(array: ArrayLike<T>): Iterable<T> {\n  return makeIt(\n      function* () {\n\n        const len = array.length;\n\n        for (let i = len - 1; i >= 0; --i) {\n          yield array[i];\n        }\n      });\n}\n","/**\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator } from './util';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (element: T) => void) {\n  for (const element of iterable) {\n    action(element);\n  }\n}\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable  Iterable to check for elements.\n *\n * @return `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<any>): boolean {\n  return !!itsIterator(iterable).next().done;\n}\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(iterable: Iterable<T>, test: (element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (!test(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the first element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  return itsIterator(iterable).next().value;\n}\n\n/**\n * Returns the last element of the given `iterable`.\n *\n * If the given `iterable` is an array-like structure, then just returns its last element. If it is revertible,\n * then extracts the first element of reverted one. Otherwise iterates over elements to find the last one.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the last element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsLast<T>(iterable: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): T | undefined {\n  if (isArrayLike(iterable)) {\n    return iterable[iterable.length - 1];\n  }\n  if (itsRevertible(iterable)) {\n    return itsFirst(iterable.reverse());\n  }\n\n  let last: T | undefined;\n\n  for (const element of iterable) {\n    last = element;\n  }\n\n  return last;\n}\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeparam T  A type of `iterable` elements.\n * @typeparam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (prev: R, element: T) => R,\n    initialValue: R): R {\n\n  let reduced = initialValue;\n\n  for (const element of iterable) {\n    reduced = reducer(reduced, element);\n  }\n\n  return reduced;\n}\n","/**\n * @module a-iterable\n */\nimport { callThru, NextCall, nextEach, PassedThru } from 'call-thru';\nimport Last = NextCall.LastResult;\nimport Out = NextCall.Outcome;\nimport Result = NextCall.CallResult;\n\n/**\n * Passes each element of the given iterable trough a chain of transformation passes.\n *\n * The passes are preformed by `callThru()` function.\n *\n * @returns Next iterable of transformed elements.\n */\nexport function thruIt<T, R1>(\n    it: Iterable<T>,\n    fn: (this: void, arg: T) => Last<R1>,\n): Iterable<PassedThru.Item<R1>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => Last<R2>,\n): Iterable<PassedThru.Item<Out<R1, R2>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => Last<R3>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, R3>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => Last<R4>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Last<R4>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => Last<R5>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, R5>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => Last<R6>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    R6>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => Last<R7>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, R7>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => Last<R8>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, R8>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => Last<R9>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, R9>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => Last<R10>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, R10>>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => Last<R11>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n        R11>>>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => Last<R12>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n        Out<R11, R12>>>>>>>>>>>>>;\n\nexport function thruIt<\n    T, R1 extends Result<P2>,\n    P2 extends any[], R2 extends Result<P3>,\n    P3 extends any[], R3 extends Result<P4>,\n    P4 extends any[], R4 extends Result<P5>,\n    P5 extends any[], R5 extends Result<P6>,\n    P6 extends any[], R6 extends Result<P7>,\n    P7 extends any[], R7 extends Result<P8>,\n    P8 extends any[], R8 extends Result<P9>,\n    P9 extends any[], R9 extends Result<P10>,\n    P10 extends any[], R10 extends Result<P11>,\n    P11 extends any[], R11 extends Result<P12>,\n    P12 extends any[], R12 extends Result<P13>,\n    P13 extends any[], R13>(\n    it: Iterable<T>,\n    fn1: (this: void, arg: T) => R1,\n    fn2: (this: void, ...args: P2) => R2,\n    fn3: (this: void, ...args: P3) => R3,\n    fn4: (this: void, ...args: P4) => R4,\n    fn5: (this: void, ...args: P5) => R5,\n    fn6: (this: void, ...args: P6) => R6,\n    fn7: (this: void, ...args: P7) => R7,\n    fn8: (this: void, ...args: P8) => R8,\n    fn9: (this: void, ...args: P9) => R9,\n    fn10: (this: void, ...args: P10) => R10,\n    fn11: (this: void, ...args: P11) => R11,\n    fn12: (this: void, ...args: P12) => R12,\n    fn13: (this: void, ...args: P13) => Last<R13>,\n): Iterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n    Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n        Out<R11, Out<R12, R13>>>>>>>>>>>>>>;\n\nexport function thruIt<T, R>(\n    it: Iterable<T>,\n    ...fns: ((...args: any[]) => any)[]): Iterable<PassedThru.Item<R>> {\n\n  const thru: () => Iterable<PassedThru.Item<R>> = (callThru as any)(\n      nextEach(it),\n      ...fns);\n\n  return thru();\n}\n","/**\n * @module a-iterable\n */\nimport { makeIt } from './util';\n\n/**\n * Creates an iterable with all `source` iterable elements that pass the test implemented by the provided function.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T>(source: Iterable<T>, test: (element: T) => boolean): Iterable<T>;\n\n/**\n * Creates an iterable with all `source` iterable elements extending the given type.\n *\n * @typeparam T  A type of source elements\n * @typeparam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T, R extends T>(source: Iterable<T>, test: (element: T) => element is R): Iterable<R>;\n\nexport function filterIt<T>(source: Iterable<T>, test: (element: T) => boolean): Iterable<T> {\n  return makeIt(function* () {\n    for (const element of source) {\n      if (test(element)) {\n        yield element;\n      }\n    }\n  });\n}\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into a new\n * iterable.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n *\n * @returns A new iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(source: Iterable<T>, convert: (element: T) => Iterable<R>): Iterable<R> {\n  return makeIt(function* () {\n    for (const element of source) {\n      yield* convert(element);\n    }\n  });\n}\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element of the `source` one.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n */\nexport function mapIt<T, R>(source: Iterable<T>, convert: (element: T) => R): Iterable<R> {\n  return makeIt(function* () {\n    for (const element of source) {\n      yield convert(element);\n    }\n  });\n}\n","/**\n * @module a-iterable\n */\nimport { NextCall, PassedThru } from 'call-thru';\nimport { IterableClass, IterableElement } from './api';\nimport { ArrayLikeIterable } from './array-like-iterable';\nimport { reverseArray, reverseIt } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { itsEach, itsEvery, itsReduction } from './termination';\nimport { thruIt } from './thru';\nimport { filterIt, flatMapIt, mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\nimport Result = NextCall.CallResult;\nimport Last = NextCall.LastResult;\nimport Out = NextCall.Outcome;\n\nconst API_METHODS: (keyof ArrayLikeIterable<any>)[] = [\n  'every',\n  'filter',\n  'flatMap',\n  'forEach',\n  'map',\n  'reduce',\n  'reverse',\n];\n\n/**\n * Abstract `Iterable` implementation with array-like iteration operations.\n *\n * @typeparam T  A type of elements.\n */\nexport abstract class AIterable<T> implements ArrayLikeIterable<T> {\n\n  /**\n   * Returns an iterable without elements.\n   *\n   * @returns An empty iterable instance.\n   */\n  static none<T>(): AIterable<T> {\n    return NONE; // tslint:disable-line:no-use-before-declare\n  }\n\n  /**\n   * Checks whether the given iterable is an array-like one.\n   *\n   * @param source  An iterable to check.\n   *\n   * @returns `true` is the `source` has all `ArrayLikeIterable` methods (like `Array` or `AIterable` instance),\n   * or `false` otherwise.\n   */\n  static is<T>(source: Iterable<T>): source is ArrayLikeIterable<T> {\n    return API_METHODS.every(name => name in source);\n  }\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source array-like iterable.\n   *\n   * @return A `source` itself.\n   */\n  static of<T>(source: ArrayLikeIterable<T>): typeof source;\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Either `source` itself if it implements `ArrayLikeIterable` already (see `is()` method),\n   * or new [[AIterable]] instance iterating over the `source`.\n   */\n  static of<T>(source: Iterable<T>): AIterable<T>;\n\n  static of<T>(source: Iterable<T> | RevertibleIterable<T> | T[]): ArrayLikeIterable<T> {\n    if (AIterable.is(source)) {\n      return source;\n    }\n    return AIterable.from(source);\n  }\n\n  /**\n   * Creates an `AIterable` instance that iterates over the same elements as the given one.\n   *\n   * Uses [[reverseIt]] function to reverse the constructed iterable.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Always new `AIterable` instance.\n   */\n  static from<T>(source: Iterable<T> | RevertibleIterable<T> | T[]): AIterable<T> {\n    return make(() => source, () => reverseIt(source));\n  }\n\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.every()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n   * and return `false` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n   * Returns `true` for empty iterable.\n   */\n  every(test: (element: T) => boolean): boolean {\n    return itsEvery(this, test);\n  }\n\n  /**\n   * Creates an iterable with all elements that pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n   * It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter(test: (element: T) => boolean): AIterable<T>;\n\n  /**\n   * Creates an iterable with all elements extending the given type.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @typeparam R  Target type.\n   * @param test  A predicate function to test that element extends the type R. Returns `true` to keep the element, or\n   * `false` otherwise. It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter<R extends T>(test: (element: T) => element is R): AIterable<R>;\n\n  filter(test: (element: T) => boolean): AIterable<T> {\n    return make(\n        () => filterIt(this, test),\n        () => filterIt(this.reverse(), test));\n  }\n\n  /**\n   * First maps each element using a mapping function, then flattens the result into a new iterable.\n   *\n   * Corresponds to `Array.prototype.flatMap()`.\n   *\n   * Note that the overridden `flatMap` method of `ArrayLikeIterable` expects an array to be returned from `convert`\n   * callback, while in this method it may return arbitrary iterable.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n   *\n   * @returns A new [[AIterable]] with each element being the flattened result of the `convert` function call.\n   */\n  flatMap<R>(convert: (element: T) => Iterable<R>): AIterable<R> {\n    return make(\n        () => flatMapIt(this, convert),\n        () => flatMapIt(this.reverse(), element => reverseIt(convert(element))));\n  }\n\n  /**\n   * Performs the given `action` for each element.\n   *\n   * Corresponds to `Array.prototype.forEach()`.\n   *\n   * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n   * parameter.\n   */\n  forEach(action: (element: T) => void) {\n    itsEach(this, action);\n  }\n\n  /**\n   * Creates a new iterable with the results of calling a provided function on every element.\n   *\n   * Corresponds to `Array.prototype.map()`.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n   * parameter.\n   *\n   * @return A new [[AIterable]] with each element being the result of the `convert` function call.\n   */\n  map<R>(convert: (element: T) => R): AIterable<R> {\n    return make(\n        () => mapIt(this, convert),\n        () => mapIt(this.reverse(), convert));\n  }\n\n  /**\n   * Applies a function against an accumulator and each element to reduce elements to a single value.\n   *\n   * Corresponds to `Array.prototype.reduce()`.\n   *\n   * @typeparam R  A type of reduced value.\n   * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n   * @param initialValue  Initial value passed to the first `reducer` call.\n   *\n   * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in this\n   * iterable.\n   */\n  reduce<R>(reducer: (prev: R, element: T) => R, initialValue: R): R {\n    return itsReduction(this, reducer, initialValue);\n  }\n\n  /**\n   * Constructs an iterable containing this iterable's elements in reverse order.\n   *\n   * By default this method converts iterable to array and then reverts its elements with [[reverseArray]] function.\n   *\n   * @return Reversed [[AIterable]] instance.\n   */\n  reverse(): AIterable<T> {\n\n    const elements = this;\n\n    return make(() => reverseArray([...elements]), () => this);\n  }\n\n  /**\n   * Passes each element of this iterable trough a chain of transformation passes.\n   *\n   * The passes are preformed by `callThru()` function.\n   *\n   * @returns Next iterable of transformed elements.\n   */\n  thru<R1>(\n      fn: (this: void, arg: T) => Last<R1>,\n  ): AIterable<PassedThru.Item<R1>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => Last<R2>,\n  ): AIterable<PassedThru.Item<Out<R1, R2>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => Last<R3>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, R3>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => Last<R4>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Last<R4>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => Last<R5>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, R5>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => Last<R6>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      R6>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => Last<R7>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, R7>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => Last<R8>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, R8>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => Last<R9>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, R9>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => Last<R10>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, R10>>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => Last<R11>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n          R11>>>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => Last<R12>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n          Out<R11, R12>>>>>>>>>>>>>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, arg: T) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => Last<R13>,\n  ): AIterable<PassedThru.Item<Out<R1, Out<R2, Out<R3, Out<R4, Out<R5,\n      Out<R6, Out<R7, Out<R8, Out<R9, Out<R10,\n          Out<R11, Out<R12, R13>>>>>>>>>>>>>>;\n\n  thru<R>(...fns: ((...args: any[]) => any)[]): AIterable<PassedThru.Item<R>> {\n\n    const thru = thruIt as any;\n\n    return make(() => thru(this, ...fns));\n  }\n\n}\n\nclass None extends AIterable<any> {\n\n  *[Symbol.iterator](): Iterator<any> {}\n\n  reverse() {\n    return this;\n  }\n\n}\n\nconst NONE = /*#__PURE__*/ new None();\n\nfunction make<T>(iterate: () => Iterable<T>, reverse?: () => Iterable<T>): AIterable<T> {\n\n  class Iterable extends AIterable<T> {\n\n    [Symbol.iterator]() {\n      return itsIterator(iterate());\n    }\n\n    reverse(): Iterable {\n      if (!reverse) {\n        return super.reverse();\n      }\n      return AIterable.from(makeIt(() => itsIterator(reverse()), () => this));\n    }\n\n  }\n\n  return new Iterable();\n}\n\n/**\n * Extends an iterable class with `AIterable` API.\n *\n * @typeparam C  A type of iterable class to extend.\n * @typeparam E  A type of elements to iterate.\n * @param iterableClass  A class to extend.\n *\n * @returns A new class extending original `iterableClass` and implementing the missing [[AIterable]] methods.\n */\nexport function toAIterable<C extends IterableClass<any, E>, E = IterableElement<InstanceType<C>>>(\n    iterableClass: C):\n    C & IterableClass<AIterable<E>, E> {\n\n  class ExtendedIterable extends iterableClass {\n  }\n\n  const extended = ExtendedIterable;\n  const proto = extended.prototype;\n\n  API_METHODS.forEach(name => {\n    if (!(name in proto)) {\n      Object.defineProperty(proto, name, {\n        configurable: true,\n        value: AIterable.prototype[name],\n      });\n    }\n  });\n\n  return extended as C & IterableClass<AIterable<E>, E>;\n}\n","/**\n * @module a-iterable\n */\nimport { reverseArray } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { makeIt } from './util';\n\n/**\n * Builds an iterable over elements of array-like structure.\n *\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns A revertible iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt<T>(\n      function* () {\n        for (let i = 0; i < array.length; ++i) {\n          yield array[i];\n        }\n      },\n      () => reverseArray(array));\n}\n\nconst NONE: RevertibleIterable<any> = {\n\n  *[Symbol.iterator](): Iterator<any> {},\n\n  reverse() { return this; }\n\n};\n\n/**\n * Returns an iterable without elements.\n *\n * @typeparam T  A type of constructed iterable elements.\n *\n * @returns An empty iterable instance revertible to itself.\n */\nexport function overNone<T>(): RevertibleIterable<T> {\n  return NONE;\n}\n","/**\n * @module a-iterable\n */\nimport { overArray } from './construction';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Builds an iterable over the keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys from.\n */\nexport function overKeys<T extends object>(target: T): RevertibleIterable<keyof T> {\n  return overArray(Reflect.ownKeys(target) as (keyof T)[]);\n}\n\n/**\n * Object property entry. This is a tuple consisting of property key and value.\n */\nexport type ObjectEntry<T, K extends keyof T = keyof T> = [K, T[K]];\n\n/**\n * Builds an iterable over the key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys and values from.\n */\nexport function overEntries<T extends object>(target: T): RevertibleIterable<ObjectEntry<T>> {\n\n  const keys = overKeys(target);\n\n  function mapToEntries(_keys: Iterable<keyof T>): Iterable<ObjectEntry<T>> {\n    return mapIt(_keys, key => [key, target[key]] as ObjectEntry<T>);\n  }\n\n  return makeIt(() => itsIterator(mapToEntries(keys)), () => mapToEntries(keys.reverse()));\n}\n","/**\n * @module fun-events\n */\nimport { EventReceiver } from './event-receiver';\nimport { EventSupply } from './event-supply';\n\n/**\n * A key of event receiver registration method of [[EventKeeper]].\n *\n * @category Core\n */\nexport const AfterEvent__symbol = /*#__PURE__*/ Symbol('after-event');\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<E extends any[]> {\n\n  /**\n   * Registers a receiver of events kept and sent by this keeper.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  [AfterEvent__symbol](receiver: EventReceiver<E>): EventSupply;\n\n}\n\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeparam T  Target event keeper.\n   */\n  export type Event<T extends EventKeeper<any>> = T extends EventKeeper<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventKeeper]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains an `[AfterEvent__symbol]` property, or `false` otherwise.\n */\nexport function isEventKeeper<E extends any[]>(value: object): value is EventKeeper<E> {\n  return AfterEvent__symbol in value;\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\n\n/**\n * A supply of events from {@link EventSupplier event supplier} to {@link EventReceiver event receiver}.\n *\n * When no longer needed the supply may be {@link off cut off}.\n *\n * May be constructed using [[eventSupply]] function.\n *\n * @category Core\n */\nexport abstract class EventSupply {\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means the events will no longer be supplied.\n   */\n  abstract readonly isOff: boolean;\n\n  /**\n   * Cuts off the supply of events.\n   *\n   * After this method call the receiver will no longer receive events.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason  An optional reason why supply is cut off. It will be reported to [[whenOff]] callbacks.\n   * @returns A cut off event supply instance.\n   */\n  abstract off(reason?: any): EventSupply;\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if [[isOff]] is `true`.\n   *\n   * @param callback  A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means normal completion.\n   *\n   * @returns `this` instance.\n   */\n  abstract whenOff(callback: (this: void, reason?: any) => void): this;\n\n  /**\n   * Declares this event supply depends on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one is will be cut off with the same reason.\n   *\n   * @param another  An event supply this one depends on.\n   *\n   * @return `this` instance.\n   */\n  needs(another: EventSupply): this {\n    another.whenOff(reason => this.off(reason));\n    return this;\n  }\n\n}\n\n/**\n * Constructs new {@link EventSupply event supply}.\n *\n * @category Core\n * @param off  A function to call when supply will supply is {@link EventSupply.off cut off}. Accepts optional\n * cut off reason as its only parameter. No-op by default.\n */\nexport function eventSupply(off: (this: void, reason?: any) => void = noop): EventSupply {\n\n  let whenOff: (callback: (reason?: any) => void) => void;\n  let cutOff: (reason?: any) => void = reason => {\n    whenOff = callback => callback(reason);\n    cutOff = noop;\n    off(reason);\n  };\n\n  whenOff = callback => {\n\n    const prev = cutOff;\n\n    cutOff = reason => {\n      prev(reason);\n      callback(reason);\n    };\n  };\n\n  class Supply extends EventSupply {\n\n    get isOff() {\n      return cutOff === noop;\n    }\n\n    off(reason?: any): EventSupply {\n      cutOff(reason);\n      return this;\n    }\n\n    whenOff(callback: (reason?: any) => void): this {\n      whenOff(callback);\n      return this;\n    }\n\n  }\n\n  return new Supply();\n}\n\nclass NoSupply extends EventSupply {\n\n  get isOff() {\n    return true;\n  }\n\n  off() {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n}\n\nconst noSupply = /*#__PURE__*/ new NoSupply();\n\n/**\n * Returns a no-event supply.\n *\n * @category Core\n *\n * @returns An event supply that is already cut off without any particular reason.\n */\nexport function noEventSupply(): EventSupply {\n  return noSupply;\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { eventSupply, EventSupply } from './event-supply';\n\n/**\n * Event receiver is called on each event sent by [[EventSender]] when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of [[EventReceiver.Object.receive]] method.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<E extends any[]> = EventReceiver.Function<E> | EventReceiver.Object<E>;\n\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<E extends any[]> =\n  /**\n   * @param event  An event represented by function call arguments.\n   */\n      (this: void, ...event: E) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<E extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link EventSupply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: EventSupply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context  An event processing context.\n     * @param event  An event represented as the rest of arguments.\n     */\n    receive(context: Context<E>, ...event: E): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by [[eventReceiver]] function.\n   *\n   * In contrast to [[Object]] this one always has a supply.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<E extends any[]> extends Object<E> {\n\n    readonly supply: EventSupply;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to [[Object]] receivers.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<E extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver  Recurrent events receiver function.\n     */\n    onRecurrent(receiver: Function<E>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n * @param receiver  An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<E extends any[]>(receiver: EventReceiver<E>): EventReceiver.Generic<E> {\n\n  let generic: {\n    readonly supply: EventSupply;\n    receive: (context: EventReceiver.Context<E>, ...event: E) => void;\n  };\n\n  if (typeof receiver === 'function') {\n    generic = {\n      supply: eventSupply(),\n      receive(_context, ...event) {\n        receiver(...event);\n      },\n    };\n  } else {\n    generic = {\n      supply: receiver.supply || eventSupply(),\n      receive(context, ...event) {\n        if (!this.supply.isOff) {\n          // Supply cut off callback may be called before the receiver disabled.\n          // Such callback may send an event that should not be received.\n          receiver.receive(context, ...event);\n        }\n      },\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  generic.supply.whenOff(() => generic.receive = noop);\n\n  return generic;\n}\n","/**\n * @module fun-events\n */\nimport { EventReceiver } from './event-receiver';\nimport { EventSupply } from './event-supply';\n\n/**\n * A key of event receiver registration method of [[EventSender]].\n *\n * @category Core\n */\nexport const OnEvent__symbol = /*#__PURE__*/ Symbol('on-event');\n\n/**\n * A sender of events.\n *\n * It is able to register event receivers.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<E extends any[]> {\n\n  /**\n   * Registers a receiver of events sent by this sender.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  [OnEvent__symbol](receiver: EventReceiver<E>): EventSupply;\n\n}\n\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeparam T  Target event sender.\n   */\n  export type Event<T extends EventSender<any>> = T extends EventSender<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventSender]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains `[OnEvent__symbol]` property, or `false` otherwise.\n */\nexport function isEventSender<E extends any[]>(value: object): value is EventSender<E> {\n  return OnEvent__symbol in value;\n}\n","/**\n * @module fun-events\n */\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { EventSender, OnEvent__symbol } from './event-sender';\nimport { EventSupply } from './event-supply';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an [[OnEvent]] interface though. Use an [[EventEmitter]] if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link EventSupply.off cut off}.\n *\n * Can be used as [[EventSender]].\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<E extends any[]> implements EventSender<E> {\n\n  /**\n   * @internal\n   */\n  private readonly _rcvs = new Set<EventReceiver.Generic<E>>();\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event  An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: E) => void = receiveEventsByEach(this._rcvs);\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcvs.size;\n  }\n\n  [OnEvent__symbol](receiver: EventReceiver<E>): EventSupply {\n    return this.on(receiver);\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<E>): EventSupply {\n\n    const generic = eventReceiver(receiver);\n\n    this._rcvs.add(generic);\n\n    return generic.supply.whenOff(() => this._rcvs.delete(generic));\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive any events.\n   *\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this._rcvs.forEach(({ supply }) => supply.off(reason));\n    return this;\n  }\n\n}\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @category Core\n * @param receivers  An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nfunction receiveEventsByEach<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n): (this: void, ...event: E) => void  {\n\n  let send: (this: void, event: E) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: E) {\n\n    let actualReceivers = receivers;\n    const received: E[] = [];\n\n    send = sendRecurrent;\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n\n    function sendRecurrent(recurrent: E) {\n      received.push(recurrent);\n    }\n  }\n}\n\nfunction processEvent<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n    event: E,\n): EventReceiver.Generic<E>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<E>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<E> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","/**\n * @module fun-events\n */\nimport { callThru, NextCall } from 'call-thru';\nimport { AfterEvent__symbol } from './event-keeper';\nimport { EventNotifier } from './event-notifier';\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { EventSender, isEventSender, OnEvent__symbol } from './event-sender';\nimport { EventSupplier } from './event-supplier';\nimport { eventSupply, EventSupply, noEventSupply } from './event-supply';\nimport Result = NextCall.CallResult;\n\n/**\n * An event receiver registration function interface.\n *\n * A registered event receiver would receive upcoming events, until the returned event supply will be\n * {@link EventSupply.off cut off}.\n *\n * An [[OnEvent]] function also has a set of handy methods. More could be added later. It also can be used as\n * [[EventSender]].\n *\n * To convert a plain event receiver registration function to [[OnEvent]] an [[onEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport abstract class OnEvent<E extends any[]> extends Function implements EventSender<E> {\n\n  get [OnEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Registers the next event receiver. It won't receive any events after receiving the first one.\n   *\n   * @param receiver  Next event receiver.\n   *\n   * @returns A supply of the next event.\n   */\n  once(receiver: EventReceiver<E>): EventSupply {\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    return this({\n      supply,\n      receive: (context, ...event) => {\n        generic.receive(context, ...event);\n        supply.off();\n      },\n    });\n  }\n\n  /**\n   * Extracts event suppliers from incoming events.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event supplier from incoming event. May return `undefined` when nothing\n   * extracted.\n   *\n   * @returns An [[OnEvent]] sender of events from extracted suppliers. The events supply is cut off once the incoming\n   * events supply do. The returned sender shares the supply of extracted events among receivers.\n   */\n  dig<F extends any[]>(\n      extract: (this: void, ...event: E) => EventSupplier<F> | void | undefined,\n  ): OnEvent<F> {\n    return shareSupplyTo(this.dig_(extract));\n  }\n\n  /**\n   * Extracts event suppliers from incoming events without sharing extracted events supply.\n   *\n   * This method does the same as [[OnEvent.dig]] one, except it does not share the supply of extracted events among\n   * receivers. This may be useful e.g. when the result will be further transformed. It is wise to {@link share share}\n   * the supply of events from final result in this case.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event supplier from incoming event. May return `undefined` when\n   * nothing extracted.\n   *\n   * @returns An [[OnEvent]] sender of events from extracted suppliers. The events supply is cut off once the incoming\n   * events supply do.\n   */\n  dig_<F extends any[]>(\n      extract: (this: void, ...event: E) => EventSupplier<F> | void | undefined,\n  ): OnEvent<F> {\n    return onEventBy((receiver: EventReceiver.Generic<F>) => {\n\n      let nestedSupply = noEventSupply();\n\n      this({\n        supply: receiver.supply,\n        receive(_context, ...event: E)  {\n\n          const prevSupply = nestedSupply;\n          const extracted = extract(...event);\n\n          try {\n            nestedSupply = extracted\n                ? onSupplied(extracted)({\n                  supply: eventSupply().needs(receiver.supply),\n                  receive(context, ...nestedEvent) {\n                    receiver.receive(context, ...nestedEvent);\n                  },\n                })\n                : noEventSupply();\n          } finally {\n            prevSupply.off();\n          }\n        },\n      });\n    });\n  }\n\n  /**\n   * Consumes events.\n   *\n   * @param consume  A function consuming events. This function may return an {@link EventSupply event supply} instance\n   * when registers a nested event receiver. This supply will be cut of on new event.\n   *\n   * @returns An event supply that will stop consuming events once {@link EventSupply.off cut off}.\n   */\n  consume(consume: (...event: E) => EventSupply | void | undefined): EventSupply {\n\n    let consumerSupply = noEventSupply();\n    const senderSupply = this((...event: E) => {\n\n      const prevSupply = consumerSupply;\n\n      try {\n        consumerSupply = consume(...event) || noEventSupply();\n      } finally {\n        prevSupply.off();\n      }\n    });\n\n    return eventSupply(reason => {\n      consumerSupply.off(reason);\n      senderSupply.off(reason);\n    }).needs(senderSupply);\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender that shares events supply among all registered receivers.\n   *\n   * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * supplies do.\n   *\n   * @returns An [[OnEvent]] sender sharing a common supply of events originated from this sender.\n   */\n  share(): OnEvent<E> {\n    return shareSupplyTo(this);\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `callThru()` function. The event receivers registered by resulting event sender\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes. The returned sender shares the supply\n   * of transformed events among receivers.\n   */\n  thru<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, any, any, any>,\n  ): OnEvent<R1>;\n\n  thru<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): OnEvent<[R1]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, any, any, any>,\n  ): OnEvent<R2>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): OnEvent<[R2]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): OnEvent<R3>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): OnEvent<[RE]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): OnEvent<[R4]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, any, any, any>,\n  ): OnEvent<R5>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): OnEvent<[R5]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, any, any, any>,\n  ): OnEvent<R6>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): OnEvent<[R6]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, any, any, any>,\n  ): OnEvent<R7>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): OnEvent<[R7]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, any, any, any>,\n  ): OnEvent<R8>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): OnEvent<[R8]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, any, any, any>,\n  ): OnEvent<R9>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): OnEvent<[R9]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, any, any, any>,\n  ): OnEvent<R10>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): OnEvent<[R10]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, any, any, any>,\n  ): OnEvent<R11>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): OnEvent<[R11]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, any, any, any>,\n  ): OnEvent<R12>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): OnEvent<[R12]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, any, any, any>,\n  ): OnEvent<R13>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): OnEvent<[R13]>;\n\n  thru(...fns: any[]): OnEvent<any[]> {\n    return shareSupplyTo((this as any).thru_(...fns));\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[OnEvent.thru]] one, except it does not share the supply of transformed events\n   * among receivers. This may be useful e.g. when the result will be further transformed anyway. It is wise to\n   * {@link share share} the supply of events from final result in this case.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes.\n   */\n  thru_<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, any, any, any>,\n  ): OnEvent<R1>;\n\n  thru_<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): OnEvent<[R1]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, any, any, any>,\n  ): OnEvent<R2>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): OnEvent<[R2]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): OnEvent<R3>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): OnEvent<[RE]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): OnEvent<[R4]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, any, any, any>,\n  ): OnEvent<R5>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): OnEvent<[R5]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, any, any, any>,\n  ): OnEvent<R6>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): OnEvent<[R6]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, any, any, any>,\n  ): OnEvent<R7>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): OnEvent<[R7]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, any, any, any>,\n  ): OnEvent<R8>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): OnEvent<[R8]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, any, any, any>,\n  ): OnEvent<R9>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): OnEvent<[R9]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, any, any, any>,\n  ): OnEvent<R10>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): OnEvent<[R10]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, any, any, any>,\n  ): OnEvent<R11>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): OnEvent<[R11]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, any, any, any>,\n  ): OnEvent<R12>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): OnEvent<[R12]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, any, any, any>,\n  ): OnEvent<R13>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): OnEvent<[R13]>;\n\n  thru_(...fns: any[]): OnEvent<any[]> {\n\n    const thru = callThru as any;\n\n    return onEventBy(receiver =>\n        this({\n          supply: receiver.supply,\n          receive(context, ...event) {\n            thru(\n                ...fns,\n                (...transformed: any[]) => receiver.receive(context, ...transformed),\n            )(...event);\n          }\n        }));\n  }\n\n}\n\nexport interface OnEvent<E extends any[]> {\n\n  /**\n   * Registers a receiver of events sent by this sender.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  (this: void, receiver: EventReceiver<E>): EventSupply; // tslint:disable-line:callable-types\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[OnEvent]] sender.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An [[OnEvent]] sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n): OnEvent<E> {\n\n  const onEvent = ((receiver: EventReceiver<E>) => {\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      register(generic);\n    }\n\n    return supply;\n  }) as OnEvent<E>;\n\n  Object.setPrototypeOf(onEvent, OnEvent.prototype);\n\n  return onEvent;\n}\n\n/**\n * Builds an [[OnEvent]] sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param supplier  An event supplier.\n *\n * @returns An [[OnEvent]] sender of events originated from the given `supplier`.\n */\nexport function onSupplied<E extends any[]>(supplier: EventSupplier<E>): OnEvent<E> {\n\n  const onEvent = isEventSender(supplier) ? supplier[OnEvent__symbol] : supplier[AfterEvent__symbol];\n\n  if (onEvent instanceof OnEvent) {\n    return onEvent;\n  }\n\n  return onEventBy(onEvent.bind(supplier));\n}\n\n/**\n * An [[OnEvent]] sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> = /*#__PURE__*/ onEventBy(({ supply }) => supply.off());\n\nfunction shareSupplyTo<E extends any[]>(onEvent: OnEvent<E>): OnEvent<E> {\n\n  const shared = new EventNotifier<E>();\n  let sharedSupply = noEventSupply();\n  let initialEvents: E[] | undefined = [];\n  const removeReceiver = (reason?: any) => {\n    if (!shared.size) {\n      sharedSupply.off(reason);\n      initialEvents = [];\n    }\n  };\n\n  return onEventBy(receiver => {\n    if (!shared.size) {\n      sharedSupply = onEvent((...event) => {\n        if (initialEvents) {\n          if (shared.size) {\n            // More events received\n            // Stop sending initial ones\n            initialEvents = undefined;\n          } else {\n            // Record events received during first receiver registration\n            // to send them to all receivers until more event received\n            initialEvents.push(event);\n          }\n        }\n        shared.send(...event);\n      });\n    }\n\n    shared.on(receiver).whenOff(removeReceiver).needs(sharedSupply);\n\n    if (initialEvents) {\n      // Send initial events to just registered receiver\n\n      const dispatcher = new EventNotifier<E>();\n\n      dispatcher.on(receiver);\n      initialEvents.forEach(event => dispatcher.send(...event));\n    }\n  });\n}\n","/**\n * @module fun-events\n */\nimport { NextCall, noop, valueProvider } from 'call-thru';\nimport { AfterEvent__symbol, EventKeeper, isEventKeeper } from './event-keeper';\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { EventSender, OnEvent__symbol } from './event-sender';\nimport { EventSupplier } from './event-supplier';\nimport { eventSupply } from './event-supply';\nimport { OnEvent } from './on-event';\nimport Result = NextCall.CallResult;\n\n/**\n * A subset of [[AfterEvent]] transformation methods inherited that return [[AfterEvent]] keepers instead of\n * [[OnEvent]] senders.\n *\n * This can not be done automatically, as not every transformation results to [[EventKeeper]]. E.g. when some events\n * are filtered out.\n *\n * An instance of this class can be obtained from [[AfterEvent.keep]] property.\n *\n * @category Core\n */\nexport class AfterEventKeep<E extends any[]> {\n\n  /**\n   * @internal\n   */\n  private readonly _keeper: AfterEvent<E>;\n\n  constructor(keeper: AfterEvent<E>) {\n    this._keeper = keeper;\n  }\n\n  /**\n   * Extracts event keepers from incoming events.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event keeper from incoming event.\n   *\n   * @returns An [[AfterEvent]] keeper of extracted events. The events supply is cut off once the incoming events supply\n   * do. The returned keeper shares the supply of extracted events among receivers.\n   */\n  dig<F extends any[]>(extract: (this: void, ...event: E) => EventKeeper<F>): AfterEvent<F> {\n    return this.dig_(extract).share();\n  }\n\n  /**\n   * Extracts event keepers from incoming events without sharing extracted events supply.\n   *\n   * This method does the same as [[AfterEventKeep.dig]] one, except it does not share the supply of extracted events\n   * among receivers. This may be useful e.g. when the result will be further transformed. It is wise to\n   * {@link AfterEvent.share share} the supply of events from the final result in this case.\n   *\n   * @typeparam F  Extracted event type.\n   * @param extract  A function extracting event keeper from incoming event.\n   *\n   * @returns An [[AfterEvent]] keeper of extracted events. The events supply is cut off once the incoming events\n   * supply do.\n   */\n  dig_<F extends any[]>(extract: (this: void, ...event: E) => EventKeeper<F>): AfterEvent<F> {\n    return afterSupplied(this._keeper.dig_((...event) => afterSupplied(extract(...event))));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `callThru()` function. The event receivers registered by resulting event keeper\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes. The returned keeper shares the supply\n   * of transformed events among receivers.\n   */\n  thru<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, any, any, any>,\n  ): AfterEvent<R1>;\n\n  thru<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): AfterEvent<[R1]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, any, any, any>,\n  ): AfterEvent<R2>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): AfterEvent<[R2]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): AfterEvent<R3>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): AfterEvent<[RE]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): AfterEvent<[R4]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, any, any, any>,\n  ): AfterEvent<R5>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): AfterEvent<[R5]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, any, any, any>,\n  ): AfterEvent<R6>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): AfterEvent<[R6]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, any, any, any>,\n  ): AfterEvent<R7>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): AfterEvent<[R7]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, any, any, any>,\n  ): AfterEvent<R8>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): AfterEvent<[R8]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, any, any, any>,\n  ): AfterEvent<R9>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): AfterEvent<[R9]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, any, any, any>,\n  ): AfterEvent<R10>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): AfterEvent<[R10]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, any, any, any>,\n  ): AfterEvent<R11>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): AfterEvent<[R11]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, any, any, any>,\n  ): AfterEvent<R12>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): AfterEvent<[R12]>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, any, any, any>,\n  ): AfterEvent<R13>;\n\n  thru<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): AfterEvent<[R13]>;\n\n  thru(...fns: any[]): AfterEvent<any[]> {\n    return (this as any).thru_(...fns).share();\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[AfterEventKeep.thru]] one, except it does not share the supply of transformed\n   * events among receivers. This may be useful e.g. when the result will be further transformed anyway.\n   * It is wise to {@link AfterEvent.share share} the supply of events from final result in this case.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes.\n   */\n  thru_<R1 extends any[]>(\n      fn1: (this: void, ...args: E) => NextCall<any, R1, any, any, any>,\n  ): AfterEvent<R1>;\n\n  thru_<R1>(\n      fn1: (this: void, ...args: E) => R1,\n  ): AfterEvent<[R1]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => NextCall<any, R2, any, any, any>,\n  ): AfterEvent<R2>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n  ): AfterEvent<[R2]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n  ): AfterEvent<R3>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], RE>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => RE,\n  ): AfterEvent<[RE]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n  ): AfterEvent<[R4]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => NextCall<any, R5, any, any, any>,\n  ): AfterEvent<R5>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n  ): AfterEvent<[R5]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => NextCall<any, R6, any, any, any>,\n  ): AfterEvent<R6>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n  ): AfterEvent<[R6]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => NextCall<any, R7, any, any, any>,\n  ): AfterEvent<R7>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n  ): AfterEvent<[R7]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => NextCall<any, R8, any, any, any>,\n  ): AfterEvent<R8>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n  ): AfterEvent<[R8]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => NextCall<any, R9, any, any, any>,\n  ): AfterEvent<R9>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n  ): AfterEvent<[R9]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => NextCall<any, R10, any, any, any>,\n  ): AfterEvent<R10>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n  ): AfterEvent<[R10]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => NextCall<any, R11, any, any, any>,\n  ): AfterEvent<R11>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n  ): AfterEvent<[R11]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => NextCall<any, R12, any, any, any>,\n  ): AfterEvent<R12>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n  ): AfterEvent<[R12]>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13 extends any[]>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => NextCall<any, R13, any, any, any>,\n  ): AfterEvent<R13>;\n\n  thru_<\n      R1 extends Result<P2>,\n      P2 extends any[], R2 extends Result<P3>,\n      P3 extends any[], R3 extends Result<P4>,\n      P4 extends any[], R4 extends Result<P5>,\n      P5 extends any[], R5 extends Result<P6>,\n      P6 extends any[], R6 extends Result<P7>,\n      P7 extends any[], R7 extends Result<P8>,\n      P8 extends any[], R8 extends Result<P9>,\n      P9 extends any[], R9 extends Result<P10>,\n      P10 extends any[], R10 extends Result<P11>,\n      P11 extends any[], R11 extends Result<P12>,\n      P12 extends any[], R12 extends Result<P13>,\n      P13 extends any[], R13>(\n      fn1: (this: void, ...args: E) => R1,\n      fn2: (this: void, ...args: P2) => R2,\n      fn3: (this: void, ...args: P3) => R3,\n      fn4: (this: void, ...args: P4) => R4,\n      fn5: (this: void, ...args: P5) => R5,\n      fn6: (this: void, ...args: P6) => R6,\n      fn7: (this: void, ...args: P7) => R7,\n      fn8: (this: void, ...args: P8) => R8,\n      fn9: (this: void, ...args: P9) => R9,\n      fn10: (this: void, ...args: P10) => R10,\n      fn11: (this: void, ...args: P11) => R11,\n      fn12: (this: void, ...args: P12) => R12,\n      fn13: (this: void, ...args: P13) => R13,\n  ): AfterEvent<[R13]>;\n\n  thru_(...fns: any[]): AfterEvent<any[]> {\n    return afterSupplied((this._keeper as any).thru_(...fns));\n  }\n\n}\n\n/**\n * A kept and upcoming events receiver registration function interface.\n *\n * A registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * To convert a plain event receiver registration function to [[AfterEvent]] an [[afterEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport abstract class AfterEvent<E extends any[]> extends OnEvent<E> implements EventKeeper<E> {\n\n  get [AfterEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * A subset of [[AfterEvent]] transformation methods that return [[AfterEvent]] keepers instead of [[OnEvent]]\n   * senders.\n   *\n   * Note that not every transformation can properly result to [[EventKeeper]]. E.g. some events may be filtered out and\n   * the resulting [[AfterEvent]] would rise an exception on receiver registration, as it won't have any events to send.\n   */\n  get keep(): AfterEventKeep<E> {\n    return new AfterEventKeep(this);\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper that shares events supply among all registered receivers.\n   *\n   * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * event supplies do.\n   *\n   * @returns An [[AfterEvent]] keeper sharing a common supply of events originating from this keeper.\n   */\n  share(): AfterEvent<E> {\n    return afterEventBy(super.share());\n  }\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[AfterEvent]] keeper with a fallback.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n    fallback: (this: void) => E = noEvent,\n): AfterEvent<E> {\n\n  let lastEvent: E | undefined;\n  let numReceivers = 0;\n\n  const afterEvent = ((receiver: EventReceiver<E>) => {\n\n    let dest: (context: EventReceiver.Context<E>, ...event: E) => void = noop;\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (supply.isOff) {\n      return supply;\n    }\n\n    register({\n      supply,\n      receive(context, ...event: E) {\n        lastEvent = event;\n        dest(context, ...event);\n      }\n    });\n    ++numReceivers;\n\n    if (!supply.isOff) {\n      generic.receive(\n          {\n            onRecurrent(recurrent) {\n              dest = (_context, ...event) => recurrent(...event);\n            },\n          },\n          ...(lastEvent || (lastEvent = fallback())),\n      );\n      dest = (context, ...event) => generic.receive(context, ...event);\n    }\n\n    supply.whenOff(() => {\n      if (!--numReceivers) {\n        lastEvent = undefined;\n      }\n    });\n\n    return supply;\n  }) as AfterEvent<E>;\n\n  Object.setPrototypeOf(afterEvent, AfterEvent.prototype);\n\n  return afterEvent;\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param keeper  A keeper of events.\n *\n * @returns An [[AfterEvent]] keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<E extends any[]>(keeper: EventKeeper<E>): AfterEvent<E>;\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * This is a synonym of [[afterSent]], unless `sender` is an [[EventKeeper]].\n *\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSupplied<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E>;\n\nexport function afterSupplied<E extends any[]>(\n    supplier: EventSupplier<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  if (!isEventKeeper(supplier)) {\n    return afterSent(supplier, fallback);\n  }\n\n  const afterEvent = supplier[AfterEvent__symbol];\n\n  if (afterEvent instanceof AfterEvent) {\n    return afterEvent;\n  }\n\n  return afterEventBy(afterEvent.bind(supplier));\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return afterEventBy(receiver => sender[OnEvent__symbol](receiver), fallback);\n}\n\n/**\n * Builds an [[AfterEvent]] keeper of the given `event`.\n *\n * @category Core\n * @param event  An event that will be sent to all receivers upon registration.\n *\n * @returns An [[AfterEvent]] keeper that always sends the given `event`.\n */\nexport function afterThe<E extends any[]>(...event: E): AfterEvent<E> {\n  return afterEventBy(() => eventSupply(), valueProvider(event));\n}\n\n/**\n * An [[AfterEvent]] keeper that never sends any events.\n *\n * @category Core\n */\nexport const afterNever: AfterEvent<any> = /*#__PURE__*/ afterEventBy(({ supply }) => supply.off());\n\nfunction noEvent(): never {\n  throw new Error('No events to send');\n}\n","/**\n * @module fun-events\n */\nimport { eventReceiver, EventReceiver } from '../event-receiver';\nimport { EventSupply } from '../event-supply';\nimport { OnEvent } from '../on-event';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport type DomEventListener<E extends Event> = EventReceiver<[E]>;\n\n/**\n * A DOM event listener registrar signature.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport abstract class OnDomEvent<E extends Event> extends OnEvent<[E]> {\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that enables event capturing by default.\n   *\n   * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n   * `EventTarget.addEventListener()`.\n   */\n  get capture(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this(listener, true);\n      }\n      if (typeof opts === 'object' && opts.capture == null) {\n        return this(listener, { ...opts, capture: true });\n      }\n      return this(listener, opts);\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers listeners to invoke instead of the default action.\n   *\n   * It invokes an `Event.preventDefault()` method prior to calling the registered listeners.\n   */\n  get instead(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.preventDefault();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers listeners preventing further propagation of\n   * current event in the capturing and bubbling phases.\n   *\n   * It invokes an `Event.stopPropagation()` method prior to calling the registered listeners.\n   */\n  get just(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopPropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that registers the last event listener.\n   *\n   * It invokes an `Event.stopImmediatePropagation()` method prior to calling the registered listeners.\n   */\n  get last(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopImmediatePropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    });\n  }\n\n  /**\n   * An [[OnDomEvent]] sender derived from this one that accepts listeners never calling `Event.preventDefault()`.\n   *\n   * This corresponds to specifying `{ passive: true }` as a second argument to `EventTarget.addEventListener()`.\n   */\n  get passive(): OnDomEvent<E> {\n    return onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this(listener, { passive: true });\n      }\n      if (typeof opts === 'boolean') {\n        return this(listener, { capture: opts, passive: true });\n      }\n      if (opts.passive == null) {\n        return this(listener, { ...opts, passive: true });\n      }\n      return this(listener, opts);\n    });\n  }\n\n}\n\nexport interface OnDomEvent<E extends Event> {\n\n  /**\n   * Registers a DOM event listener.\n   *\n   * @param listener  A DOM event listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @return A DOM events supply.\n   */\n  // tslint:disable-next-line:callable-types\n  (this: void, listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n}\n\n/**\n * Converts a plain DOM event listener registration function to [[OnDomEvent]] sender.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n * @param register  A generic DOM event listener registration function.\n *\n * @returns An [[OnDomEvent]] sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<E extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[E]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<E> {\n\n  const onDomEvent = (\n      (\n          listener: DomEventListener<E>,\n          opts?: AddEventListenerOptions | boolean,\n      ) => {\n\n        const receiver = eventReceiver(listener);\n\n        register(receiver, opts);\n\n        return receiver.supply;\n      }\n  ) as OnDomEvent<E>;\n\n  Object.setPrototypeOf(onDomEvent, OnDomEvent.prototype);\n\n  return onDomEvent;\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { EventReceiver } from '../event-receiver';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\nconst domEventContext: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners and dispatch events.\n *\n * @category DOM\n */\nexport class DomEventDispatcher {\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target  Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link EventSupply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link EventSupply.off cut off}.\n   *\n   * @typeparam E  Supported DOM event type.\n   * @param type  DOM event type name.\n   *\n   * @returns [[OnDomEvent]] sender of DOM events of the given `type`.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return onDomEventBy<E>((listener, opts) => {\n\n      // Create unique DOM listener instance\n      const domListener: EventListener = event => listener.receive(domEventContext, event as E);\n\n      this._target.addEventListener(type, domListener, opts);\n      listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean {\n    return this._target.dispatchEvent(event);\n  }\n\n}\n","/**\n * @module fun-events\n */\nimport { EventNotifier } from './event-notifier';\nimport { EventSender, OnEvent__symbol } from './event-sender';\nimport { OnEvent, onEventBy } from './on-event';\n\n/**\n * Event emitter is a handy implementation of [[OnEvent]] sender.\n *\n * Extends [[EventNotifier]] by making its [[EventNotifier.on]] method implement an [[OnEvent]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<E extends any[]> extends EventNotifier<E> implements EventSender<E> {\n\n  /**\n   * An [[OnEvent]] sender.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  readonly on = onEventBy<E>(receiver => super.on(receiver));\n\n  readonly [OnEvent__symbol]: OnEvent<E> = this.on;\n\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterNever, afterSupplied } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper } from '../event-keeper';\nimport { EventNotifier } from '../event-notifier';\nimport { EventReceiver } from '../event-receiver';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeparam S  A type of `sources` map.\n * @param sources  A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each event keeper. Each event in this map has the\n * same name as its originating event keeper in `sources`.\n */\nexport function afterAll<S extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: S,\n): AfterEvent<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  if (!keys.length) {\n    return afterNever;\n  }\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>,\n  ): void {\n\n    const notifier = new EventNotifier<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>();\n    const supply = notifier.on(receiver);\n    let send: () => void = noop;\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach(readFrom);\n\n    if (!supply.isOff) {\n      send = () => notifier.send(result);\n    }\n\n    function readFrom(key: keyof S) {\n      supply.needs(sources[key][AfterEvent__symbol]((...event) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    }\n  }\n\n  function latestEvent(): [{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }] {\n\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach(key =>\n        afterSupplied(sources[key])\n            .once((...event) => result[key as keyof S] = event));\n\n    return [result];\n  }\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy, afterNever, afterSupplied } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper } from '../event-keeper';\nimport { EventNotifier } from '../event-notifier';\nimport { EventReceiver } from '../event-receiver';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeparam E  A type of events sent by each source.\n * @param sources  An array of source event keepers.\n *\n * @returns An event keeper sending events received from each event keeper. Each event item is an event tuple originated\n * from event keeper under the same index in `sources` array.\n */\nexport function afterEach<E extends any[]>(...sources: EventKeeper<E>[]): AfterEvent<E[]> {\n  if (!sources.length) {\n    return afterNever;\n  }\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(receiver: EventReceiver.Generic<E[]>): void {\n\n    const notifier = new EventNotifier<E[]>();\n    const supply = notifier.on(receiver);\n    let send: () => void = noop;\n    const result: E[] = [];\n\n    sources.forEach(readFrom);\n\n    if (!supply.isOff) {\n      send = () => notifier.send(...result);\n    }\n\n    function readFrom(source: EventKeeper<E>, index: number) {\n      supply.needs(source[AfterEvent__symbol]((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    }\n  }\n\n  function latestEvent() {\n\n    const result: E[] = [];\n\n    sources.forEach(source =>\n        afterSupplied(source)\n            .once((...event) => result.push(event)));\n\n    return result;\n  }\n}\n","/**\n * @module fun-events\n */\nimport { EventReceiver } from '../event-receiver';\nimport { EventSupplier } from '../event-supplier';\nimport { eventSupply } from '../event-supply';\nimport { OnEvent, onEventBy, onNever, onSupplied } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param suppliers  Original event suppliers.\n *\n * @returns An [[OnEvent]] sender of all supplied events.\n */\nexport function onAny<E extends any[]>(...suppliers: EventSupplier<E>[]): OnEvent<E> {\n  if (!suppliers.length) {\n    return onNever;\n  }\n\n  return onEventBy<E>(receiver => {\n\n    const { supply } = receiver;\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any) => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n    const receive = (context: EventReceiver.Context<E>, ...event: E) => {\n      receiver.receive(context, ...event);\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier)({\n          supply: eventSupply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  }).share();\n}\n","/**\n * @module fun-events\n */\n/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @param key  A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<K extends PropertyKey>(key: K): [K];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path  Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return Array.isArray(path) ? path : [path];\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { EventEmitter } from '../event-emitter';\nimport { EventSender, OnEvent__symbol } from '../event-sender';\nimport { eventSupply, EventSupply } from '../event-supply';\nimport { onEventBy } from '../on-event';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n      path = statePath(path);\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): EventSupply {\n\n    const entry = this;\n    const supply = this.emitter.on(receiver);\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      entry._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: any) {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.done(reason);\n  }\n\n  private _remove(key: PropertyKey) {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty() {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): EventSupply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<V>(path: StatePath.Normalized, newValue: V, oldValue: V) {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: any) {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void = (<V>(path: StatePath, newValue: V, oldValue: V) => {\n    this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n  });\n\n  readonly onUpdate: OnStateUpdate =\n      onEventBy<[StatePath, any, any]>(receiver => this._trackers.on(this._path, receiver));\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  get _tracker() {\n    return this;\n  }\n\n  get [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: any) {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under [[StatePath]].\n *\n * When node modified a [[StateTracker.update]] should be called. Then all state update receivers registered by\n * [[StateTracker.onUpdate]] will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * A {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   */\n  get onUpdate(): OnStateUpdate {\n    return this._tracker.onUpdate;\n  }\n\n  get [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with [[onUpdate]] will receive this update.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  get update(): <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path  A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason  An optional reason to stop tracking.\n   */\n  done(reason?: any) {\n    this._tracker.done(reason);\n  }\n\n}\n","/**\n * @module fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, isEventKeeper } from '../event-keeper';\nimport { EventReceiver } from '../event-receiver';\nimport { EventSender, OnEvent__symbol } from '../event-sender';\nimport { EventSupplier } from '../event-supplier';\nimport { EventSupply, noEventSupply } from '../event-supply';\nimport { OnEvent, onSupplied } from '../on-event';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an [[EventSender]] interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an [[EventKeeper]] interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeparam T  Tracked value type.\n * @typeparam N  New (updated) value type.\n */\nexport abstract class ValueTracker<T = any, N extends T = T> implements EventSender<[N, T]>, EventKeeper<[T]> {\n\n  /**\n   * @internal\n   */\n  private _by = noEventSupply();\n\n  /**\n   * An [[OnEvent]] sender of value changes. The new value is sent as first argument, and the old value as a second one.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[N, T]>;\n\n  /**\n   * An [[AfterEvent]] keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  readonly read: AfterEvent<[T]> = afterEventBy<[T]>(\n      receiver => this.on(receiveNewValue(receiver)),\n      () => [this.it],\n  );\n\n  get [OnEvent__symbol](): OnEvent<[N, T]> {\n    return this.on;\n  }\n\n  get [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.off]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier  The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.off]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeparam S  Source value type.\n   * @param supplier  The event supplier to extract value suppliers from.\n   * @param extract  A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<S extends any[]>(\n      supplier: EventSupplier<S>,\n      extract: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<S extends any[]>(\n      supplier: EventSupplier<S> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const self = this;\n\n    this.byNone();\n\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<S>;\n\n      this._by = onSupplied(container).consume((...event: S) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      });\n    }\n    this._by.whenOff(() => this._by = noEventSupply());\n\n    return this;\n\n    function acceptValuesFrom(sender: EventSupplier<[T]>): EventSupply {\n\n      const registrar = isEventKeeper(sender) ? sender[AfterEvent__symbol] : sender[OnEvent__symbol];\n\n      return registrar(value => self.it = value);\n    }\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason  Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive events.\n\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nfunction receiveNewValue<T, N extends T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[N, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    }\n  };\n}\n","/**\n * @module fun-events\n */\nimport { EventEmitter } from '../event-emitter';\nimport { EventSupplier } from '../event-supplier';\nimport { ValueTracker } from './value-tracker';\n\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get on() {\n    return this._on.on;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n  done(reason?: any): this {\n    this._on.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.off]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier  The source value sender or keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventSupplier<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value suppliers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.off]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeparam S  Source value type.\n * @param supplier  The event supplier to extract value suppliers from.\n * @param extract  A function extracting value supplier from event received from `supplier`.\n * May return `undefined` to suspend receiving values.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventSupplier<S>,\n    extract: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventSupplier<S> | EventSupplier<[T]>,\n    extract?: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n): ValueTracker<T> {\n  return (trackValue() as any).by(supplier, extract);\n}\n","/**\n * @module fun-events\n */\nimport { afterSupplied } from '../after-event';\nimport { EventEmitter } from '../event-emitter';\nimport { EventKeeper, isEventKeeper } from '../event-keeper';\nimport { EventSender } from '../event-sender';\nimport { EventSupplier } from '../event-supplier';\nimport { eventSupply, EventSupply } from '../event-supply';\nimport { OnEvent, onSupplied } from '../on-event';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * Synchronizes tracked values with each other.\n *\n * Any change to any of the added tracked values would update all the others.\n *\n * @category Value Tracking\n */\nexport class ValueSync<T> extends ValueTracker<T> {\n\n  /**\n   * @internal\n   */\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  /**\n   * @internal\n   */\n  private _it: T;\n\n  constructor(initial: T) {\n    super();\n    this._it = initial;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._on.on;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const old = this.it;\n\n    if (old !== value) {\n      this._it = value;\n      this._on.send(value, old);\n    }\n  }\n\n  /**\n   * Synchronizes the tracked value with the others.\n   *\n   * Applies the value from this sync to the given tracker first.\n   *\n   * @param tracker  A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync(tracker: ValueTracker<T, any>): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the others in the given direction.\n   *\n   * @param direction  If set to `\"in\"` the value from the given tracker takes precedence over the one in [[ValueSync]].\n   * Otherwise the value from the sync is applied to the given tracker first.\n   * @param tracker  A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync(direction: 'in' | 'out', tracker: ValueTracker<T, any>): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * Applies the value from this sync to extracted trackers.\n   *\n   * @param supplier  The event supplier to extract value trackers from.\n   * @param extract  A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync<U extends any[]>(\n      supplier: EventSupplier<U>,\n      extract: (this: void, ...event: U) => ValueTracker<T, any> | undefined,\n  ): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`\n   * in the given direction.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * @param direction  If set to `\"in\"` the value from extracted tracker takes precedence over the one in\n   * [[ValueSync]]. Otherwise the value from the sync is applied to extracted trackers first.\n   * @param supplier  The event supplier to extract value trackers from.\n   * @param extract  A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync<U extends any[]>(\n      direction: 'in' | 'out',\n      supplier: EventSupplier<U>,\n      extract: (this: void, ...event: U) => ValueTracker<T, any> | undefined,\n  ): EventSupply;\n\n  sync<U extends any[]>(\n      first: 'in' | 'out' | ValueTracker<T, any> | EventSupplier<U>,\n      second?: ValueTracker<T, any>\n          | EventSender<U>\n          | EventKeeper<U>\n          | ((this: void, ...event: U) => ValueTracker<T, any> | undefined),\n      third?: (this: void, ...event: U) => ValueTracker<T, any> | undefined,\n  ): EventSupply {\n\n    let syncWithTracker = (tracker: ValueTracker<T, any>) => syncTrackers(this, tracker);\n    let source: ValueTracker<T, any> | EventSupplier<U>;\n    let extract: ((this: void, ...event: U) => ValueTracker<T, any> | undefined) | undefined;\n\n    if (typeof first === 'string') {\n      if (first === 'in') {\n        syncWithTracker = tracker => syncTrackers(tracker, this);\n      }\n      source = second as ValueTracker<T, any> | EventSender<U> | EventKeeper<U>;\n      extract = third;\n    } else {\n      source = first;\n      extract = second as (this: void, ...event: U) => ValueTracker<T, any> | undefined;\n    }\n\n    const extractTracker = extract;\n\n    if (!extractTracker) {\n      return syncWithTracker(source as ValueTracker<T, any>);\n    }\n\n    const supplier = source as EventSupplier<U>;\n\n    return (isEventKeeper(supplier) ? afterSupplied(supplier) : onSupplied(supplier)).consume((...event) => {\n\n      const tracker = extractTracker(...event);\n\n      return tracker && syncWithTracker(tracker);\n    });\n\n    function syncTrackers(tracker1: ValueTracker<T, any>, tracker2: ValueTracker<T, any>) {\n\n      const supply1 = tracker1.read(value => {\n        tracker2.it = value;\n      });\n      const supply2 = tracker2.on(value => {\n        tracker1.it = value;\n      });\n\n      return eventSupply(reason => {\n        supply2.off(reason);\n        supply1.off(reason);\n      }).needs(supply1).needs(supply2);\n    }\n  }\n\n  done(reason?: any): this {\n    this._on.done(reason);\n    return this;\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [[ContextKey]] instance.\n */\nexport const ContextKey__symbol = /*#__PURE__*/ Symbol('context-key');\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextKey<Value, Src = Value, Seed = unknown> implements ContextRef<Value, Src, Seed> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<Src, Seed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @typeparam Ctx  Context type.\n   * @param opts  Context value growth options.\n   *\n   * @returns Single context value, or `undefined` if there is no default value.\n   */\n  abstract grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Value, Src, Seed>): Value | null | undefined;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value growth options.\n *\n * An instance of these options is passed to [[ContextKey.grow]] method to provide the necessary value growth context.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport interface ContextValueOpts<Ctx extends ContextValues, Value, Src, Seed> {\n\n  /**\n   * Target context.\n   */\n  readonly context: Ctx;\n\n  /**\n   * Context value seeder.\n   */\n  readonly seeder: ContextSeeder<Ctx, Src, Seed>;\n\n  /**\n   * Context value seed.\n   */\n  readonly seed: Seed;\n\n  /**\n   * Handles missing context value.\n   *\n   * It can be called to prefer a fallback value over the default one specified in the value key.\n   *\n   * @param defaultProvider  Default value provider. It is called unless a fallback value is specified.\n   * If it returns a non-null/non-undefined value, then the returned value will be associated with the context key.\n   */\n  byDefault(defaultProvider: () => Value | null | undefined): Value | null | undefined;\n\n}\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Key  Context key type.\n */\nexport type ContextKeyDefault<Value, Key extends ContextKey<any, any, any>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: Key) => Value | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextSeedKey<Src, Seed> extends ContextKey<Seed, Src, Seed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<any, Src>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeparam Ctx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src, Seed>;\n\n  grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Seed, Src, Seed>): Seed | null | undefined {\n\n    const { seeder, seed } = opts;\n\n    return seeder.isEmpty(seed) ? opts.byDefault(() => seed) : seed;\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message: string = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { valueProvider } from 'call-thru';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Src  Source value type.\n */\nexport type ContextValueProvider<Ctx extends ContextValues, Src> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: Ctx) => Src | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSpec<\n    Ctx extends ContextValues,\n    Value,\n    Deps extends any[] = unknown[],\n    Src = Value,\n    Seed = unknown> =\n    | ContextValueSpec.IsConstant<Src, Seed>\n    | ContextValueSpec.ViaAlias<Src, Seed>\n    | ContextValueSpec.ByProvider<Ctx, Src, Seed>\n    | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.AsInstance<Ctx, Src, Seed>\n    | ContextValueSpec.SelfInstance<Ctx, Src, Seed>\n    | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface IsConstant<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Constant context value.\n     */\n    is: Src;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeparam Sec  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ViaAlias<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<Src, Seed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProvider<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<Ctx, Src>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProviderWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: Deps) => Src | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: Ctx) => Src;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (context: Ctx) => Src);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: Deps) => Src;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (...args: Deps) => Src);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   */\n  export type DepsRequests<Deps extends any[]> = {\n    [K in keyof Deps]: ContextRequest<Deps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<Ctx extends ContextValues, Value, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, Value, Deps, Src, Seed>,\n): ContextValueSpec.ByProvider<Ctx, Src, Seed> {\n  if (byProvider(spec)) {\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: Ctx) {\n        return by(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n  if (isConstant<Src, Seed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: Ctx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<Ctx, Deps, Src, Seed>(spec)) {\n    if (selfInstance<Ctx, Deps, Src, Seed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n\n      const { a, as: type } = spec;\n\n      return {\n        a,\n        by(ctx: Ctx) {\n          return new type(ctx);\n        },\n      };\n    } else {\n\n      const { a, as: type, with: deps } = spec;\n\n      return {\n        a,\n        by(this: void, context: Ctx) {\n          return new type(...deps.map(dep => context.get(dep)) as Deps);\n        },\n      };\n    }\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${spec}`);\n}\n\nfunction byProvider<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed> {\n  return 'by' in spec;\n}\n\nfunction asInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return 'as' in spec;\n}\n\nfunction selfInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed> {\n  return !('a' in spec);\n}\n\nfunction toAsInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>,\n): ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n}\n\nfunction isConstant<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.IsConstant<Src, Seed> {\n  return 'is' in spec;\n}\n\nfunction viaAlias<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.ViaAlias<Src, Seed> {\n  return 'via' in spec;\n}\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>;\n\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @module context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrNull<Value>): Value | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrUndefined<Value>): Value | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts?: ContextRequest.OrFallback<Value>): Value;\n\n}\n","/**\n * @module context-values\n */\nimport { noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\ntype SeedFactory<Ctx extends ContextValues, Seed> = (this: void, context: Ctx) => Seed;\n\ntype Seeding<Ctx extends ContextValues, Src, Seed> = [ContextSeeder<Ctx, Src, Seed>, SeedFactory<Ctx, Seed>];\n\n/**\n * A registry of context value providers.\n *\n * @typeparam Ctx  Context type.\n */\nexport class ContextRegistry<Ctx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _initial: ContextSeeds<Ctx>;\n\n  /** @internal */\n  private readonly _seeds = new Map<ContextSeedKey<any, any>, Seeding<Ctx, any, any>>();\n\n  /** @internal */\n  private _nonCachedValues?: ContextValues;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<Ctx> | ContextValues) {\n    if (initial == null) {\n      this._initial = noop;\n    } else if (typeof initial === 'function') {\n      this._initial = initial;\n    } else {\n      this._initial = seedKey => initial.get(seedKey);\n    }\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<Deps extends any[], Src, Seed>(spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeding<Src, Seed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * @internal\n   */\n  private _seeding<Src, Seed>(seedKey: ContextSeedKey<Src, Seed>): Seeding<Ctx, Src, Seed> {\n\n    const found: Seeding<Ctx, Src, Seed> | undefined = this._seeds.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<Ctx, Src, Seed> = seedKey.seeder();\n    const factory: SeedFactory<Ctx, Seed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seeding: Seeding<Ctx, Src, Seed> = [seeder, factory];\n\n    this._seeds.set(seedKey, seeding);\n\n    return seeding;\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<Src, Seed>(context: Ctx, key: ContextSeedKey<Src, Seed>): Seed {\n\n    const [, factory] = this._seeding(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: Ctx, cache?: boolean): <Src, Seed>(this: void, key: ContextSeedKey<Src, Seed>) => Seed | undefined {\n\n    const values = this.newValues(cache);\n\n    return <Src, Seed>(key: ContextSeedKey<Src, Seed>) =>\n        values.get.call<Ctx, [ContextSeedKey<Src, Seed>], Seed>(context, key);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(cache = true): ContextValues & ThisType<Ctx> {\n    if (!cache && this._nonCachedValues) {\n      return this._nonCachedValues;\n    }\n\n    const values = new Map<ContextKey<any>, any>();\n    const registry = this;\n\n    class Values extends ContextValues {\n\n      get<Value, Src>(\n          this: Ctx,\n          { [ContextKey__symbol]: key }: ContextRef<Value, Src>,\n          opts?: ContextRequest.Opts<Value>,\n      ): Value | null | undefined {\n\n        const context = this;\n        const cached: Value | undefined = values.get(key);\n\n        if (cached != null) {\n          return cached;\n        }\n\n        const [constructed, defaultUsed] = growValue(context, key, opts);\n\n        if (cache && !defaultUsed) {\n          values.set(key, constructed);\n        }\n\n        return constructed;\n      }\n\n    }\n\n    if (!cache) {\n      return this._nonCachedValues = new Values();\n    }\n\n    return new Values();\n\n    function growValue<Value, Src, Seed>(\n        context: Ctx,\n        key: ContextKey<Value, Src, Seed>,\n        opts: ContextRequest.Opts<Value> | undefined,\n    ): [Value | null | undefined, boolean] {\n\n      const [seeder, seed] = findSeed<Src, Seed>(context, key);\n      let defaultUsed = false;\n\n      const valueOpts: ContextValueOpts<Ctx, Value, Src, Seed> = {\n        context,\n        seeder,\n        seed,\n        byDefault: (opts && 'or' in opts)\n            ? () => {\n              defaultUsed = true;\n              return opts.or;\n            } : defaultProvider => {\n\n              const defaultValue = defaultProvider();\n\n              if (defaultValue == null) {\n                throw new ContextKeyError(key);\n              }\n\n              return defaultValue;\n            }\n      };\n\n      return [\n        key.grow(valueOpts),\n        defaultUsed,\n      ];\n    }\n\n    function findSeed<Src, Seed>(\n        context: Ctx,\n        key: ContextKey<any, Src, Seed>,\n    ): [ContextSeeder<Ctx, Src, Seed>, Seed] {\n\n      const { seedKey } = key;\n      const [seeder, factory] = registry._seeding(seedKey);\n\n      if (seedKey !== key as any) {\n        // This is not a seed key\n        // Retrieve the seed by seed key\n        return [seeder, context.get(seedKey)];\n      }\n\n      return [seeder, factory(context)];\n    }\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<Ctx>): ContextRegistry<Ctx> {\n\n    const self = this;\n\n    return new ContextRegistry<Ctx>(combine);\n\n    function combine<Src, Seed>(key: ContextSeedKey<Src, Seed>, context: Ctx): Seed {\n\n      const [seeder] = self._seeding(key);\n\n      return seeder.combine(self.seed(context, key), other.seed(context, key), context);\n    }\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { flatMapIt, mapIt, overArray } from 'a-iterable';\nimport { asis, NextArgs, nextArgs, noop } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\nclass ContextUpSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AfterEvent<Src[]> = afterThe<Src[]>()): AfterEvent<Src[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<Src[]>, second: AfterEvent<Src[]>): AfterEvent<Src[]> {\n    return afterEach(\n        first,\n        second,\n    ).keep.thru(\n        (...sources) => flatUpSources(sources),\n    );\n  }\n\n}\n\nfunction upSrcKeepers<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providersTracker: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]>,\n): AfterEvent<Src[]> {\n  return providersTracker.read.keep.dig(\n      providers => !providers.length ? afterThe() : afterEach(\n          ...mapIt(\n              mapIt(\n                  overArray(providers),\n                  prov => prov(context),\n              ),\n              toUpSrcKeeper,\n          ),\n      ).keep.thru(\n          (...sources) => flatUpSources(sources),\n      ));\n}\n\nfunction toUpSrcKeeper<Src>(src: null | undefined | Src | EventKeeper<Src[]>): AfterEvent<Src[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\nfunction isUpSrcKeeper<Src>(src: Src | EventKeeper<Src[]>): src is EventKeeper<Src[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as (object | Function));\n}\n\nfunction flatUpSources<Src, NextReturn>(sources: Src[][]): NextArgs<Src[], NextReturn> {\n  return nextArgs<Src[], NextReturn>(\n      ...flatMapIt(overArray(sources), asis)\n  );\n}\n\nclass ContextSeedUpKey<Src> extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextUpRef<Value, Src, Seed = unknown> = ContextRef<Value, Src | EventKeeper<Src[]>, Seed>;\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class ContextUpKey<Value, Src>\n    extends ContextKey<Value, Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpRef<Value, Src, AfterEvent<Src[]>> {\n\n  readonly seedKey: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey(this);\n  }\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Seed  Value seed type.\n */\nexport type SingleContextUpRef<Value, Seed = unknown> = ContextUpRef<AfterEvent<[Value]>, Value, Seed>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextUpKey<Value>\n    extends ContextUpKey<AfterEvent<[Value]>, Value>\n    implements SingleContextUpRef<Value, AfterEvent<Value[]>> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value | EventKeeper<Value[]>, AfterEvent<Value[]>>,\n        byDefault?: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<[Value]>, EventKeeper<Value[]> | Value, AfterEvent<Value[]>>,\n  ): AfterEvent<[Value]> {\n    return opts.seed.keep.dig((...sources) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return afterThe(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue && afterThe(defaultValue);\n      });\n\n      if (backup != null) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<[Value]>(() => {\n        throw new ContextKeyError(this);\n      });\n    });\n  }\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type MultiContextUpRef<Src, Seed = unknown> = ContextUpRef<AfterEvent<Src[]>, Src, Seed>;\n\n/**\n * Multiple updatable context values key.\n *\n * The associated value is an `AfterEvent` keeper of the source values. It is always present, even though\n * the array can be empty.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Src  Source value type.\n */\nexport class MultiContextUpKey<Src>\n    extends ContextUpKey<AfterEvent<Src[]>, Src>\n    implements MultiContextUpRef<Src, AfterEvent<Src[]>> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>;\n\n  /**\n   * Constructs multiple updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>,\n        byDefault?: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<Src[]>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n  ): AfterEvent<Src[]> {\n    return opts.seed.keep.dig((...sources) => {\n      if (sources.length) {\n        // Sources present. Use them.\n        return afterThe(...sources);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue ? afterThe(...defaultValue) : afterThe();\n      });\n\n      if (backup != null) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<Src[]>(() => {\n        throw new ContextKeyError(this);\n      });\n    });\n  }\n\n}\n","import { noop } from 'call-thru';\nimport { AfterEvent, EventKeeper } from 'fun-events';\nimport { ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\nimport { ContextValues } from './context-values';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n * @typeparam Seed  Value seed type.\n */\nexport type FnContextRef<Args extends any[], Ret = void, Seed = unknown> =\n    ContextUpRef<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret, Seed>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport class FnContextKey<Args extends any[], Ret = void>\n    extends ContextUpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>\n    implements FnContextRef<Args, Ret, AfterEvent<((this: void, ...args: Args) => Ret)[]>> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<Args, Ret>) =>\n      (this: void, ...args: Args) => Ret;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<\n            ((this: void, ...args: Args) => Ret) | EventKeeper<((this: void, ...args: Args) => Ret)[]>,\n            AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n        byDefault?: ContextKeyDefault<(this: void, ...args: Args) => Ret, FnContextKey<Args, Ret>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          (this: void, ...args: Args) => Ret,\n          EventKeeper<((this: void, ...args: Args) => Ret)[]> | ((this: void, ...args: Args) => Ret),\n          AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n  ): (this: void, ...args: Args) => Ret {\n\n    let delegated!: (this: void, ...args: Args) => Ret;\n\n    opts.seed((...fns) => {\n      if (fns.length) {\n        delegated = fns[fns.length - 1];\n      } else {\n\n        const defaultProvider = () => this.byDefault(opts.context, this);\n        const fallback = opts.byDefault(defaultProvider);\n\n        delegated = fallback || defaultProvider();\n      }\n    });\n\n    return (...args) => delegated(...args);\n  }\n\n}\n","/**\n * @module context-values\n */\nimport { AIterable, itsEmpty, itsLast, overArray, overNone } from 'a-iterable';\nimport { asis, isPresent, noop, valuesProvider } from 'call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\nclass SimpleContextSeeder<Ctx extends ContextValues, Src> implements ContextSeeder<Ctx, Src, AIterable<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.push(provider);\n    return () => {\n\n      const found = this._providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AIterable<Src> = AIterable.from(overNone())): AIterable<Src> {\n    return AIterable.from([\n      initial,\n      sourceValues(context, this._providers),\n    ]).flatMap(asis);\n  }\n\n  isEmpty(seed: AIterable<Src>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: AIterable<Src>, second: AIterable<Src>): AIterable<Src> {\n    return AIterable.from([first, second]).flatMap(asis);\n  }\n\n}\n\nclass SimpleSeedKey<Src> extends ContextSeedKey<Src, AIterable<Src>> {\n\n  seeder<Ctx extends ContextValues>(): SimpleContextSeeder<Ctx, Src> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects value sources into iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class SimpleContextKey<Value, Src = Value> extends ContextKey<Value, Src, AIterable<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, AIterable<Src>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, AIterable<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\n/**\n * Single context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Seed  Value seed type.\n */\nexport type SingleContextRef<Value, Seed = unknown> = ContextRef<Value, Value, Seed>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextKey<Value>\n    extends SimpleContextKey<Value>\n    implements SingleContextRef<Value, AIterable<Value>> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextKey<Value>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value, AIterable<Value>>,\n        byDefault?: ContextKeyDefault<Value, ContextKey<Value>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, Value, Value, AIterable<Value>>,\n  ): Value | null | undefined {\n\n    const value = itsLast(opts.seed);\n\n    if (value != null) {\n      return value;\n    }\n\n    return opts.byDefault(() => this.byDefault(opts.context, this));\n  }\n\n}\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeparam Src  Value source type and context value item type.\n * @typeparam Seed  Value seed type.\n */\nexport type MultiContextRef<Src, Seed = unknown> = ContextRef<readonly Src[], Src, Seed>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport class MultiContextKey<Src>\n    extends SimpleContextKey<readonly Src[], Src>\n    implements MultiContextRef<Src, AIterable<Src>> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<Src, AIterable<Src>>,\n        byDefault?: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>,\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, readonly Src[], Src, AIterable<Src>>,\n  ): readonly Src[] | null | undefined {\n\n    const result = [...opts.seed];\n\n    if (result.length) {\n      return result;\n    }\n\n    return opts.byDefault(() => {\n\n      const defaultSources = this.byDefault(opts.context, this);\n\n      if (defaultSources) {\n        return [...defaultSources];\n      }\n\n      return;\n    });\n  }\n\n}\n\n// Context value provider and cached context value source.\ntype SourceEntry<Ctx extends ContextValues, Src> = [ContextValueProvider<Ctx, Src>, (Src | null | undefined)?];\n\nfunction sourceValues<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providers: ContextValueProvider<Ctx, Src>[],\n): AIterable<Src> {\n  return AIterable.from(overArray(providers.map<SourceEntry<Ctx, Src>>(provider => [provider])))\n      .map(entry => {\n        if (entry.length > 1) {\n          return entry[1];\n        }\n\n        const source = entry[0](context);\n\n        entry.push(source);\n\n        return source;\n      })\n      .filter<Src>(isPresent);\n}\n","/**\n * @module namespace-aliaser\n */\nimport { QualifiedName } from './name';\nimport { NamespaceDef } from './namespace';\nimport { NamespaceAliaser } from './namespace-aliaser';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\n\nclass DefaultNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}-${name}`;\n  }\n\n}\n\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const default__naming: Naming = /*#__PURE__*/ new DefaultNaming();\n\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const html__naming: Naming = /*#__PURE__*/ new DefaultNaming();\n\nclass XmlNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}:${name}`;\n  }\n\n}\n\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const xml__naming: Naming = /*#__PURE__*/ new XmlNaming();\n\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const id__naming: Naming = /*#__PURE__*/ new XmlNaming();\n\nclass CssNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${name}@${alias}`;\n  }\n\n}\n\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nexport const css__naming: Naming = /*#__PURE__*/ new CssNaming();\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\nimport { default__naming } from './namings';\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nexport class NamespaceDef {\n\n  /**\n   * Unique namespace URL.\n   */\n  readonly url: string;\n\n  /**\n   * Preferred namespace aliases.\n   */\n  readonly aliases: readonly string[];\n\n  /**\n   * The most preferred namespace alias.\n   *\n   * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n   */\n  get alias(): string {\n    return this.aliases[0] || 'ns';\n  }\n\n  /**\n   * Constructs new namespace definition.\n   *\n   * @param url  Unique namespace URL.\n   * @param aliases  Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n   * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n   * is reserved for [default namespace][[DEFAULT__NS]].\n   */\n  constructor(url: string, ...aliases: string[]) {\n    this.url = url;\n    this.aliases = aliases;\n  }\n\n  /**\n   * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n   *\n   * Calls [[Naming.applyAlias]] by default.\n   *\n   * @param alias  Namespace alias to apply to the name.\n   * @param name  A name to convert.\n   * @param naming  Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n   *\n   * @returns A simple name with this namespace alias applied.\n   */\n  name(alias: string, name: string, naming: Naming = default__naming): string {\n    return naming.applyAlias(name, alias, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { NamespaceDef } from './namespace';\n\nclass DefaultNs extends NamespaceDef {\n\n  constructor() {\n    super('');\n  }\n\n  name(_alias: string, name: string): string {\n    return name;\n  }\n\n}\n\n/**\n * Default namespace.\n *\n * This namespace is assumed for names without namespace specified.\n *\n * Its URL is empty. And it does not alter names, i.e. its [[NamespaceDef.name]] method returns the name as is.\n */\nexport const DEFAULT__NS: NamespaceDef = /*#__PURE__*/ new DefaultNs();\n","/**\n * @module namespace-aliaser\n */\nimport { DEFAULT__NS } from './default.ns';\nimport { NamespaceDef } from './namespace';\n\n/**\n * A name qualified with namespace.\n *\n * This can be either:\n * - a simple name string, which means a name in default namespace, or\n * - a name+namespace tuple.\n */\nexport type QualifiedName = string | NameAndNamespace;\n\n/**\n * A local name and namespace tuple.\n *\n * Consists of a local name string and namespace definition this name belongs to.\n */\nexport type NameAndNamespace = readonly [string, NamespaceDef];\n\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of [[NamespaceDef]]. Or `false` otherwise.\n */\nexport function isNameAndNamespace(value: any): value is NameAndNamespace {\n  return Array.isArray(value)\n      && value.length === 2\n      && typeof value[0] === 'string'\n      && value[1] instanceof NamespaceDef;\n}\n\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is a non-empty string or an array consisting of exactly two elements,\n * where the first element is a non-empty string, and the second element is an instance of [[NamespaceDef]].\n * Or `false` otherwise.\n */\nexport function isQualifiedName(value: any): value is QualifiedName {\n  return typeof value === 'string' || isNameAndNamespace(value);\n}\n\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name  Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function namespaceOf(name: QualifiedName): NamespaceDef {\n  return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name  Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function nameAndNamespace(name: QualifiedName): NameAndNamespace {\n  return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nexport function namesEqual(first: QualifiedName, second: QualifiedName): boolean {\n  if (typeof first === 'string') {\n    return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    return !firstUrl && firstName === second;\n  }\n\n  return firstName === second[0] && firstUrl === second[1].url;\n}\n\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nexport function compareNames(first: QualifiedName, second: QualifiedName): -1 | 0 | 1 {\n  if (typeof first === 'string') {\n    if (typeof second === 'string') {\n      return compareStrings(first, second);\n    }\n    if (!second[1].url) {\n      return compareStrings(first, second[0]);\n    }\n    return -1;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    if (!firstUrl) {\n      return compareStrings(firstName, second);\n    }\n    return 1;\n  }\n\n  return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n\nfunction compareStrings(first: string, second: string): -1 | 0 | 1 {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\n","/**\n * @module namespace-aliaser\n */\nimport { NamespaceDef } from './namespace';\n\n/**\n * Namespace aliaser function interface.\n *\n * Maps namespaces to their unique aliases.\n */\nexport type NamespaceAliaser =\n/**\n * @param ns  A definition of namespace to find alias for.\n *\n * @returns Namespace alias.\n */\n    (ns: NamespaceDef) => string;\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nexport function newNamespaceAliaser(): NamespaceAliaser {\n\n  const aliasesByNs = new Map<string, string>();\n  const nsNumPerAlias = new Map<string, number>();\n\n  return function nsAlias(ns: NamespaceDef): string {\n\n    const found = aliasesByNs.get(ns.url);\n\n    if (found) {\n      return found;\n    }\n\n    const mostPreferred = ns.alias;\n    let nsNumRegistered = 0;\n\n    for (const preferred of [mostPreferred, ...ns.aliases]) {\n\n      const ids = nsNumPerAlias.get(preferred);\n\n      if (!ids) {\n        aliasesByNs.set(ns.url, preferred);\n        nsNumPerAlias.set(preferred, 1);\n        return preferred;\n      }\n      if (!nsNumRegistered) {\n        // Use the first one\n        nsNumRegistered = ids;\n      }\n    }\n\n    const generated = mostPreferred + (++nsNumRegistered);\n\n    aliasesByNs.set(ns.url, generated);\n    nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n\n    return generated;\n  };\n}\n","import { HthvItem } from './hthv-item';\n\n/**\n * @internal\n */\nexport interface HthvPartial<I extends HthvItem<any, any, any> = HthvItem> {\n  $: I['$'];\n  n?: I['n'];\n  t?: I['t'];\n  v: I['v'];\n  x?: I['x'];\n  p?: I['p'];\n  pl?: I['pl'];\n}\n\n/**\n * @internal\n */\nexport function hthvItem<I extends HthvItem<any, any, any>>(\n    {\n      $,\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<I>,\n): I {\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as I;\n}\n","import { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam({ p, pl }: HthvItem, param: HthvParamItem) {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","import { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = config.delimiterOf(c);\n\n    return c;\n  };\n}\n","// tslint:disable-next-line:max-line-length\nimport { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (input.s.match(datePattern)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","/**\n * @internal\n */\nexport const parseNone = () => false;\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseDateTime } from './parse-date-time';\nimport { parseNone } from './parse-none';\nimport { quotedStringParser } from './quoted-string-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport interface ItemParserOpts {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserOpts = {}\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseQuotedString = quotedStringParser(config);\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem),\n    )) ; // tslint:disable-line:curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (config.delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (config.delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = config.delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = config.delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser(config: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(config.delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport { HthvDelimitConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  delimiterOf(char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n    }: {\n      delimit?: HthvDelimitConfig;\n    } = {}): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = /*#__PURE__*/ buildParserConfig();\n\n/**\n * @internal\n */\nexport const commentParserConfig = /*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n});\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiterChar } from './hthv-delimiter';\nimport { HthvItem } from './hthv-item';\nimport { hthvItem } from './hthv-partial.impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeparam N  Whether parsed items have {@link HthvItem.n names}.\n * @typeparam T  Whether parsed items have {@link HthvItem.t tags}.\n * @typeparam P  Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    N extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    T extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    P extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value  HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<N, T, P>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse comments.\n   *\n   * `false` by default.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config  New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // tslint:disable-line\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (config.delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport { spacesParser } from './spaces-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const commentParserOpts: ItemParserOpts = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserOpts);\n  const parseParam = paramParser(config, commentParserOpts);\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while (\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            }\n        )\n        || parseItem(input, item => result = item)\n        ) ; /* tslint:disable-line:curly */\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","import { HthvParser, newHthvParser } from '../hthv-parser';\n\n/**\n * Parses HTTP header value that may contain comments.\n *\n * This is particularly useful when parsing headers such as:\n * - `User-Agent`\n * - `Server`\n */\nexport const hthvParseCommented: HthvParser = /*#__PURE__*/ newHthvParser({ comments: true });\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParser, newHthvParser } from '../hthv-parser';\n\n/**\n * Parses HTTP header values containing directives.\n *\n * Directives are parameterized items using spaces instead of semicolons to delimit parameters. While semicolons and\n * colons are used to delimit items.\n *\n * This is particularly useful when parsing headers such as:\n * - `Content-Security-Policy`\n * - `Content-Security-Policy-Report-Only`\n * - `Feature-Policy`\n * - `Via`\n * - `Warning`\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma-separated value items with space-separated parameters.\n */\nexport const hthvParseDirectives: HthvParser = /*#__PURE__*/ newHthvParser({\n  delimit: {\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Parameter,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Parameter,\n    ';': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  },\n});\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParser, newHthvParser } from '../hthv-parser';\n\n/**\n * Parses HTTP header value containing URI(s) without parameters.\n *\n * `,`, `;`, '(', ')', and `=` symbols can be part of URI. This function returns multiple items only if URIs are\n * space-separated.\n *\n * This is particularly useful when parsing headers such as:\n * - `Content-Location`\n * - `Location`\n * - `Referef`\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of space-separated value items without parameters.\n */\nexport const hthvParseURIs: HthvParser<'no-name', 'no-tag', 'no-params'> = /*#__PURE__*/ newHthvParser({\n  delimit: {\n    ',': HthvDelimiter.NonToken,\n    ';': HthvDelimiter.NonToken,\n    '=': HthvDelimiter.NonToken,\n  },\n}) as HthvParser<'no-name', 'no-tag', 'no-params'>;\n","/**\n * @module http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser = /*#__PURE__*/ newHthvParser();\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string  A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = defaultParserConfig.delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If its not a printable ASCII character\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// Its a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// Its an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since theyre redundant. Note that this is only possible if the escape\n\t// sequence isnt preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// Its not safe to remove the space, so dont.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n","/* eslint-disable no-var, prefer-template */\nvar uppercasePattern = /[A-Z]/g\nvar msPattern = /^ms-/\nvar cache = {}\n\nfunction toHyphenLower(match) {\n  return '-' + match.toLowerCase()\n}\n\nfunction hyphenateStyleName(name) {\n  if (cache.hasOwnProperty(name)) {\n    return cache[name]\n  }\n\n  var hName = name.replace(uppercasePattern, toHyphenLower)\n  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)\n}\n\nexport default hyphenateStyleName\n","import cssesc from 'cssesc';\n\n/**\n * @internal\n */\nexport function cssescId(id: string): string {\n  return cssesc(id, { isIdentifier: true });\n}\n\nexport const IMPORTANT_CSS_SUFFIX = '!important';\n","/**\n * @internal\n */\nexport function isReadonlyArray<T>(value: any): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): array is readonly [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: T[]): array is [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): boolean {\n  return !!array.length;\n}\n","/**\n * @module style-producer\n */\nimport { StypColor } from './color';\nimport { StypNumeric } from './numeric';\nimport { StypPriority } from './priority';\nimport { StypURL } from './url';\n\n/**\n * CSS property value.\n *\n * This is either a scalar value, or {@link StypValueStruct structured} one.\n *\n * @category CSS Value\n */\nexport type StypValue =\n    | string\n    | number\n    | boolean\n    | undefined\n    | StypNumeric<any>\n    | StypURL\n    | StypColor;\n\n/**\n * Structured property CSS value. E.g. [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length),\n * [percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage),\n * [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value), etc.\n *\n * @category CSS Value\n * @typeparam Self  A type of itself.\n */\nexport abstract class StypValueStruct<Self extends StypValueStruct<Self>> {\n\n  /**\n   * CSS property value priority.\n   *\n   * The value [[StypPriority.Important]] and above means the property is `!important`. Everything else means normal\n   * priority.\n   *\n   * The property value with higher priority number takes precedence over the one with lower one.\n   */\n  readonly priority: number;\n\n  /**\n   * Constructs structured CSS property value.\n   *\n   * @param opts  Construction options.\n   */\n  protected constructor(opts?: StypValue.Opts) {\n    this.priority = opts && opts.priority || StypPriority.Default;\n  }\n\n  /**\n   * Checks whether this value equals to CSS property value.\n   *\n   * @param other  CSS property value to compare with.\n   */\n  abstract is(other: StypValue): boolean;\n\n  /**\n   * Creates structured CSS value with the given `priority`.\n   *\n   * @param priority  New priority.\n   *\n   * @returns Either a new value equal to this one but having the given `priority`, or this one if `priority` did\n   * not change.\n   */\n  abstract prioritize(priority: number): Self;\n\n  /**\n   * Creates `!important` variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to [[StypPriority.Important]],\n   * or this one if already the case.\n   */\n  important(): Self {\n    return this.prioritize(StypPriority.Important);\n  }\n\n  /**\n   * Creates usual (not `!important`) variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to [[StypPriority.Usual]],\n   * or this one if already the case.\n   */\n  usual(): Self {\n    return this.prioritize(StypPriority.Usual);\n  }\n\n  /**\n   * Maps the given CSS property value to the value of this one's type. Defaults to this value if mapping is not\n   * possible.\n   *\n   * This method allows to use an structured value instance as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value.\n   */\n  abstract by(source: StypValue): StypValue;\n\n  /**\n   * Returns textual representation of this value.\n   *\n   * Textual representation never contains an `!important` suffix.\n   *\n   * @returns A textual representation of this value to use as CSS property value.\n   */\n  abstract toString(): string;\n\n}\n\nexport namespace StypValue {\n\n  /**\n   * Construction options of structured property CSS value.\n   */\n  export interface Opts {\n\n    /**\n     * Constructed value priority.\n     *\n     * The value [[StypPriority.Important]] and above means the property is `!important`. Everything else means normal\n     * priority.\n     */\n    readonly priority?: number;\n\n  }\n\n}\n\n/**\n * Checks whether two CSS property values are equal.\n *\n * Compares scalar values verbatim. Compares structured values using their [[StypValueStruct.is]] method. The latter\n * method is applied when at least one of the values is structured.\n *\n * @category CSS Value\n * @param first  The first CSS property value to compare.\n * @param second  The second CSS property value to compare.\n *\n * @returns `true` if `first` equals to `second`, or `false otherwise.\n */\nexport function stypValuesEqual(first: StypValue, second: StypValue): boolean {\n  if (first === second) {\n    return true;\n  }\n  if (typeof first === 'object') {\n    return first.is(second);\n  }\n  if (typeof second === 'object') {\n    return second.is(first);\n  }\n  return false;\n}\n","/**\n * @module style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\n\n/**\n * Structured [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) CSS property value.\n *\n * Colors are represented by either `rgb()`, or `hsl()` functional notations.\n *\n * @category CSS Value\n */\nexport type StypColor = StypRGB | StypHSL;\n\n/**\n * Structured color CSS property value base.\n *\n * @category CSS Value\n */\nexport abstract class StypColorStruct<Self extends StypColorStruct<Self, Coords>, Coords>\n    extends StypValueStruct<Self> {\n\n  /**\n   * Color value type corresponding to color coordinates. Either `rgb` or `hsl`\n   */\n  abstract readonly type: 'rgb' | 'hsl';\n\n  /**\n   * This color in RGB coordinates.\n   */\n  abstract readonly rgb: StypRGB;\n\n  /**\n   * This color in HSL coordinates.\n   */\n  abstract readonly hsl: StypHSL;\n\n  /**\n   * Constructs another color value with updated coordinates.\n   *\n   * @param coords  Either partial color coordinates to apply or a function returning them and accepting this color\n   * instance as its only argument. Missing values are taken from this color.\n   *\n   * @returns Updated color value.\n   */\n  abstract set(coords: Partial<Coords> | ((this: void, color: this) => Partial<Coords>)): Self;\n\n}\n\n/**\n * CSS property value representing [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors)\n * in `rgb()` or `rgba()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypRGB extends StypColorStruct<StypRGB, StypRGB.Coords> implements StypRGB.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  /**\n   * `rgb` value type.\n   */\n  get type(): 'rgb' {\n    return 'rgb';\n  }\n\n  /**\n   * Red color value between `0` and `255`.\n   */\n  readonly r: number;\n\n  /**\n   * Green color value between `0` and `255`.\n   */\n  readonly g: number;\n\n  /**\n   * Blue color value between `0` and `255`.\n   */\n  readonly b: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs RGB color value.\n   *\n   * @param coords  Color coordinates.\n   * @param opts  Construction options.\n   */\n  constructor(coords: StypRGB.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.r = intCoord(coords.r, 255);\n    this.g = intCoord(coords.g, 255);\n    this.b = intCoord(coords.b, 255);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get rgb(): this {\n    return this;\n  }\n\n  /**\n   * This color in HSL coordinates.\n   */\n  get hsl(): StypHSL {\n\n    const { a } = this;\n    const r = this.r * 100 / 255;\n    const g = this.g * 100 / 255;\n    const b = this.b * 100 / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = Math.round((max + min) / 2);\n\n    if (max === min) {\n      return new StypHSL({ h: 0, s: 0, l, a }, this);\n    }\n\n    const d = max - min;\n    const s = Math.round(l > 50 ? d * 100 / (200 - max - min) : d * 100 / (max + min));\n    let h: number;\n\n    switch (max) {\n      case r:\n        h = ((g - b) / d) + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = ((b - r) / d) + 2;\n        break;\n      default:\n        h = ((r - g) / d) + 4;\n        break;\n    }\n    h *= 60;\n    h = Math.round(h);\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  by(source: StypValue): StypColor {\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.r === this.r\n        && other.g === this.g\n        && other.b === this.b\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypRGB {\n    return this.priority === priority ? this : new StypRGB(this, { priority });\n  }\n\n  set(coords: Partial<StypRGB.Coords> | ((this: void, color: this) => Partial<StypRGB.Coords>)): StypRGB {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { r = this.r, g = this.g, b = this.b, a = this.a } = coords;\n\n    return new StypRGB({ r, g, b, a }, this);\n  }\n\n  toString(): string {\n\n    const rgb = `${this.r}, ${this.g}, ${this.b}`;\n\n    return this.a === 1 ? `rgb(${rgb})` : `rgba(${rgb}, ${this.a})`;\n\n  }\n\n}\n\nexport namespace StypRGB {\n\n  /**\n   * [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Red color value between `0` and `255`.\n     */\n    r: number;\n\n    /**\n     * Green color value between `0` and `255`.\n     */\n    g: number;\n\n    /**\n     * Blue color value between `0` and `255`.\n     */\n    b: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * CSS property value representing [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors)\n * in `hsl()` or `hsla()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypHSL extends StypColorStruct<StypHSL, StypHSL.Coords> implements StypHSL.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'hsl' {\n    return 'hsl';\n  }\n\n  /**\n   * Hue angle value in degrees between `0` and `360`.\n   */\n  readonly h: number;\n\n  /**\n   * Saturation percentage.\n   */\n  readonly s: number;\n\n  /**\n   * Lightness percentage.\n   */\n  readonly l: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs HSL color value.\n   *\n   * @param coords  Color coordinates.\n   * @param opts  Construction options.\n   */\n  constructor(coords: StypHSL.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.h = angleCoord(coords.h);\n    this.s = coord(coords.s, 100);\n    this.l = coord(coords.l, 100);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   */\n  get rgb(): StypRGB {\n\n    const { a } = this;\n    const s = this.s / 100;\n    const l = this.l / 100;\n\n    if (!s) {\n\n      const c = l * 255;\n\n      return new StypRGB({ r: c, g: c, b: c, a }, this);\n    }\n\n    const q = l < 0.5 ? l * (1 + s) : (l + s) - (l * s);\n    const p = (2 * l) - q;\n    const hueAsFraction = this.h / 360;\n\n    return new StypRGB(\n        {\n          r: hueToRgb(p, q, hueAsFraction + (1.0 / 3.0)),\n          g: hueToRgb(p, q, hueAsFraction),\n          b: hueToRgb(p, q, hueAsFraction - (1.0 / 3.0)),\n          a,\n        },\n        this);\n  }\n\n  /**\n   * This color in HSL coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get hsl(): this {\n    return this;\n  }\n\n  by(source: StypValue): StypColor {\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.h === this.h\n        && other.s === this.s\n        && other.l === this.l\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypHSL {\n    return this.priority === priority ? this : new StypHSL(this, { priority });\n  }\n\n  set(coords: Partial<StypHSL.Coords> | ((this: void, color: this) => Partial<StypHSL.Coords>)): StypHSL {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { h = this.h, s = this.s, l = this.l, a = this.a } = coords;\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  toString(): string {\n\n    const hsl = `${this.h}, ${this.s}%, ${this.l}%`;\n\n    return this.a === 1 ? `hsl(${hsl})` : `hsla(${hsl}, ${this.a})`;\n  }\n\n}\n\nexport namespace StypHSL {\n\n  /**\n   * [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Hue angle value in degrees.\n     */\n    h: number;\n\n    /**\n     * Saturation percentage.\n     */\n    s: number;\n\n    /**\n     * Lightness percentage.\n     */\n    l: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypColor = {\n\n  /**\n   * Maps the given CSS property value to color. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a [[StypColor]] object as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  by(source: StypValue): StypColor | undefined {\n    if (typeof source === 'object' && (source.type === 'rgb' || source.type === 'hsl')) {\n      return source;\n    }\n    return;\n  },\n\n};\n\nfunction angleCoord(value: number): number {\n  value = value % 360;\n  return value < 0 ? 360 + value : value;\n}\n\nfunction intCoord(value: number, max: number): number {\n  return coord(Math.round(value), max);\n}\n\nfunction coord(value: number, max: number): number {\n  return Math.max(Math.min(value, max), 0);\n}\n\nfunction hueToRgb(p: number, q: number, t: number) {\n\n  let newT = t;\n\n  if (newT < 0) {\n    newT += 1;\n  } else if (newT > 1) {\n    newT -= 1;\n  }\n\n  let result;\n\n  if (newT < 1.0 / 6.0) {\n    result = p + ((q - p) * (6 * newT));\n  } else if (newT < 1.0 / 2.0) {\n    result = q;\n  } else if (newT < 2.0 / 3.0) {\n    result = p + (((q - p) * ((2.0 / 3.0) - newT)) * 6);\n  } else {\n    result = p;\n  }\n\n  return result * 255;\n}\n","/**\n * @module style-producer\n */\nimport { StypColor, StypRGB } from './color';\n\n/**\n * Mixes two colors.\n *\n * Both the `weight` and the relative opacity of each color determines how much of each color is in the result.\n *\n * @category CSS Value\n * @param color1  First color to mix\n * @param color2  Second color to mix.\n * @param weight  A number between `0` and `1`. A larger weight indicates that more of `color1` should be used, and a\n * smaller weight indicates that more of `color2` should be used.\n *\n * @returns Mixed color.\n */\nexport function mixStypColors(color1: StypColor, color2: StypColor, weight: number): StypColor {\n\n  const w = weight * 2 - 1;\n  const rgba1 = color1.rgb;\n  const rgba2 = color2.rgb;\n  const aDiff = rgba1.a - rgba2.a;\n  const w1 = (((w * aDiff === -1) ? w : (w + aDiff) / (1 + w * aDiff)) + 1) / 2.0;\n  const w2 = 1 - w1;\n  return new StypRGB(\n      {\n        r: rgba1.r * w1 + rgba2.r * w2,\n        g: rgba1.g * w1 + rgba2.g * w2,\n        b: rgba1.b * w1 + rgba2.b * w2,\n        a: rgba1.a * weight + rgba2.a * (1 - weight),\n      },\n      color1);\n}\n","/**\n * @module style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\nimport { StypZero } from './zero';\n\n/**\n * Structured numeric CSS property value.\n *\n * This represents either dimension, zero value, or a `calc()` CSS function call.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n * @typeparam Zero  A type of zero value. [[StypZero]] by default.\n */\nexport type StypNumeric<Unit extends string, Zero extends StypZero<Unit> | StypDimension<Unit> = StypZero<Unit>> =\n    | StypDimension<Unit>\n    | StypCalc<Unit>\n    | Zero;\n\n/**\n * Base implementation of structured numeric CSS property value.\n *\n * @category CSS Value\n * @typeparam Self  A type of itself.\n * @typeparam Unit  Allowed unit type.\n */\nexport abstract class StypNumericStruct<Self extends StypNumericStruct<Self, Unit>, Unit extends string>\n    extends StypValueStruct<Self> {\n\n  /**\n   * A type of structured numeric CSS property value.\n   */\n  abstract type: 'dimension' | 'calc' | 0;\n\n  readonly dim: StypDimension.Kind<Unit>;\n\n  constructor(opts: StypDimension.Opts<Unit>) {\n    super(opts);\n    this.dim = opts.dim;\n  }\n\n  /**\n   * Tries to converts this numeric value to another dimension.\n   *\n   * Does not actually construct a value in another dimension, as long as dimension unit supported by both dimensions.\n   *\n   * @typeparam U  A unit type allowed in target dimension.\n   * @param dim  Target dimension.\n   *\n   * @returns Either a value in dimension compatible with `dim`, or `undefined` if this value's unit is not supported\n   * by `dim`.\n   */\n  abstract toDim<U extends string>(dim: StypDimension.Kind<U>): StypNumeric<U> | undefined;\n\n  abstract add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  abstract add(addendum: number, unit: Unit): StypNumeric<Unit>;\n\n  abstract sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  abstract sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  abstract mul(multiplier: number): StypNumeric<Unit>;\n\n  abstract div(divisor: number): StypNumeric<Unit>;\n\n  abstract negate(): StypNumeric<Unit>;\n\n  by(source: StypValue): StypNumeric<Unit> {\n    return this.dim.by(source) || this as StypNumeric<Unit>;\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns CSS value text without `!important` or `calc()`.\n   */\n  abstract toFormula(): string;\n\n  toString() {\n    return this.toFormula();\n  }\n\n}\n\n/**\n * Structured [dimension](https://developer.mozilla.org/en-US/docs/Web/CSS/dimension) value with unit.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed units type.\n */\nexport interface StypDimension<Unit extends string>\n    extends StypValueStruct<StypDimension<Unit>>, StypNumericStruct<StypDimension<Unit>, Unit> {\n\n  readonly type: 'dimension';\n\n  readonly dim: StypDimension.Kind<Unit>;\n\n  /**\n   * Dimension value.\n   */\n  readonly val: number;\n\n  /**\n   * Dimension unit.\n   */\n  readonly unit: Unit;\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit?: Unit): StypNumeric<Unit>;\n\n  by(source: StypValue): StypNumeric<Unit>;\n\n}\n\nexport namespace StypDimension {\n\n  /**\n   * A kind of dimensions. E.g. angle, length, percentage, etc.\n   *\n   * It is perfectly fine to use dimensions interchangeably as long as dimension units are compatible.\n   *\n   * @typeparam Unit  Allowed units type.\n   */\n  export interface Kind<Unit extends string> {\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports and, in addition, supporting percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if supports percents.\n     */\n    readonly pt?: Kind<Unit | '%'>;\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports, except percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if does not support percents.\n     */\n    readonly noPt: Kind<Exclude<Unit, '%'>>;\n\n    /**\n     * Zero value of this kind.\n     *\n     * Typically, this is unit-less [[StypZero]]. But some dimensions require units.\n     */\n    readonly zero: StypDimension<Unit> | StypZero<Unit>;\n\n    /**\n     * Constructs dimension value.\n     *\n     * @param val  Numeric dimension value.\n     * @param unit  Dimension unit.\n     *\n     * @returns Constructed dimension value. Either [[StypDimension]] instance, or [[StypZero]] if `val` is `0` and\n     * this dimension kind supports unitless zero.\n     */\n    of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit>;\n\n    /**\n     * Maps the given CSS property value to the one compatible with this dimension kind. Defaults to `undefined`\n     * if mapping is not possible.\n     *\n     * This method allows to use a dimension kind as {@link StypMapper.Mapping CSS property mapping}.\n     *\n     * Any scalar or non-numeric value is mapped to `undefined`. A numeric value is converted to this dimension by\n     * [[StypNumeric.toDim]] method.\n     *\n     * @param source  A raw property value that should be converted.\n     *\n     * @returns Mapped property value or `undefined`.\n     */\n    by(source: StypValue): StypNumeric<Unit, StypDimension<Unit> | StypZero<Unit>> | undefined;\n\n  }\n\n  export namespace Kind {\n\n    /**\n     * A kind of dimension with unit-less zero. E.g. angle or length.\n     *\n     * @typeparam Unit  Allowed units type.\n     */\n    export interface UnitlessZero<Unit extends string> extends Kind<Unit> {\n\n      readonly pt?: UnitlessZero<Unit | '%'>;\n\n      readonly noPt: UnitlessZero<Exclude<Unit, '%'>>;\n\n      /**\n       * Zero value of this kind without unit.\n       */\n      readonly zero: StypZero<Unit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val  Numeric dimension value.\n       * @param unit  Dimension unit.\n       *\n       * @returns Constructed dimension value. Either [[StypDimension]] instance, or [[StypZero]] if `val` is `0`.\n       */\n      of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit>;\n\n      by(source: StypValue): StypNumeric<Unit> | undefined;\n\n    }\n\n    /**\n     * A kind of dimension which zero value has unit. E.g. frequency or resolution.\n     *\n     * @typeparam Unit  Allowed units type.\n     */\n    export interface UnitZero<Unit extends string> extends Kind<Unit> {\n\n      readonly pt?: UnitZero<Unit | '%'>;\n\n      readonly noPt: UnitZero<Exclude<Unit, '%'>>;\n\n      /**\n       * Zero value of this kind that has unit.\n       */\n      readonly zero: StypDimension<Unit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val  Numeric dimension value.\n       * @param unit  Dimension unit.\n       *\n       * @returns Constructed dimension value as a [[StypDimension]] instance.\n       */\n      of(val: number, unit: Unit): StypDimension<Unit>;\n\n      by(source: StypValue): StypNumeric<Unit, StypDimension<Unit>> | undefined;\n\n    }\n\n  }\n\n  /**\n   * Construction options of dimensions.\n   *\n   * @typeparam Unit  Allowed units type.\n   */\n  export interface Opts<Unit extends string> extends StypValue.Opts {\n\n    /**\n     * A kind of dimension.\n     */\n    dim: Kind<Unit>;\n\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation.\n *\n * This is either a {@link StypAddSub addition/subtraction}, or {@link StypMulDiv multiplication/division}.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport type StypCalc<Unit extends string> = StypAddSub<Unit> | StypMulDiv<Unit>;\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport interface StypAddSub<Unit extends string> extends StypNumericStruct<StypAddSub<Unit>, Unit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<Unit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '+' | '-';\n\n  /**\n   * Right operand.\n   */\n  readonly right: StypNumeric<Unit>;\n\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport interface StypMulDiv<Unit extends string> extends StypNumericStruct<StypMulDiv<Unit>, Unit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<Unit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '*' | '/';\n\n  /**\n   * Right operand.\n   */\n  readonly right: number;\n\n}\n","/**\n * @module style-producer\n */\nimport { itsEach, overKeys } from 'a-iterable';\nimport { StypProperties } from '../rule';\nimport { StypValue } from './value';\n\n/**\n * A type of function that maps CSS properties to something else.\n *\n * @category CSS Value\n * @typeparam R  A type of mapped properties. This is a mapping result type.\n */\nexport type StypMapper<R> =\n/**\n * @param from  CSS properties to map.\n *\n * @returns Mapping result.\n */\n    (this: void, from: StypProperties) => R;\n\nexport namespace StypMapper {\n\n  /**\n   * CSS property mapping.\n   *\n   * It is used to recognize raw property value and convert it to the one of the given type.\n   *\n   * It is one of:\n   * - Default property value. Replaces the source property value, unless the the have the same type.\n   * - A mapping function. Replaces the source property value with the result of this function call.\n   * - An object containing mapping method called `by()`. Replaces the source property value with the result of this\n   *   method call.\n   *\n   * @typeparam R  A type of mapped properties. This is an object containing mapped properties.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export type Mapping<R, K extends keyof R> =\n      | MappingFunction<R, K>\n      | MappingObject<R, K>\n      | R[K];\n\n  /**\n   * CSS property mapping function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export type MappingFunction<R, K extends keyof R> =\n  /**\n   * @param source  A raw property value that should be converted.\n   * @param mapped  An object granting access to other mapped properties.\n   * @param key  A key of converted property.\n   *\n   * @returns Mapped property value.\n   */\n      (this: void, source: StypValue, mapped: Mapped<R>, key: K) => R[K];\n\n  /**\n   * CSS property mapping object.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export interface MappingObject<R, K extends keyof R> {\n\n    /**\n     * Maps CSS property value.\n     *\n     * @param source  A raw property value that should be converted.\n     * @param mapped  An object granting access to other mapped properties.\n     * @param key  A key of converted property.\n     *\n     * @returns Mapped property value.\n     */\n    by(source: StypValue, mapped: Mapped<R>, key: K): R[K];\n\n  }\n\n  /**\n   * Grants access to mapped values.\n   *\n   * Passed as a second argument to mapping function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   */\n  export interface Mapped<R> {\n\n    /**\n     * Original properties to convert.\n     */\n    from: StypProperties;\n\n    /**\n     * Maps the property with the given type accordingly to mapping instruction.\n     *\n     * The mapping is performed at most once per property.\n     *\n     * @param key  Mapped property key.\n     *\n     * @returns Mapped property value.\n     */\n    get<K extends keyof R>(key: K): R[K];\n\n  }\n\n  /**\n   * Mappings of CSS properties.\n   *\n   * Contains mappings for each mapped CSS property with that property name as a key.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   */\n  export type Mappings<R> = { readonly [key in keyof R]: Mapping<R, key>; };\n\n}\n\nexport const StypMapper = {\n\n  /**\n   * Maps CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   *\n   * @param mappings  Mappings of CSS properties.\n   * @param from  Raw CSS properties to map.\n   *\n   * @returns Mapped properties.\n   */\n  map<R>(mappings: StypMapper.Mappings<R>, from: StypProperties): R {\n\n    const result: { [key in keyof R]: R[key] } = {} as any;\n    const mapped = {\n      from,\n      get<K extends keyof R>(key: K): R[K] {\n        if (key in result) {\n          return result[key];\n        }\n\n        const mapper = mappingBy<R, K>(mappings[key]);\n        const mappedValue = mapper(from[key as string], this, key);\n\n        result[key] = mappedValue;\n\n        return mappedValue;\n      }\n    };\n\n    itsEach(overKeys(mappings), key => mapped.get(key));\n\n    return result;\n  },\n\n  /**\n   * Creates CSS properties mapper function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @param mappings  Mappings of CSS properties.\n   *\n   * @returns A function that maps CSS properties accordingly to the given `mappings`.\n   */\n  by<R>(mappings: StypMapper.Mappings<R>): StypMapper<R> {\n    return StypMapper.map.bind<void, StypMapper.Mappings<R>, [StypProperties], R>(undefined, mappings);\n  },\n\n};\n\nfunction mappingBy<R, K extends keyof R>(\n    mapping: StypMapper.Mapping<R, K> | undefined):\n    StypMapper.MappingFunction<R, K> {\n  switch (typeof mapping) {\n  case 'function':\n    return mapping as StypMapper.MappingFunction<R, K>;\n  case 'object':\n    return (mapping as StypMapper.MappingObject<R, K>).by.bind(mapping);\n  }\n\n  const type = typeof mapping;\n\n  return (from: StypValue): R[K] => {\n    return typeof from === type ? from as any : mapping;\n  };\n}\n","import { StypPriority } from '../priority';\nimport { StypValue, stypValuesEqual } from '../value';\nimport {\n  StypAddSub as StypAddSub_,\n  StypDimension as StypDimension_,\n  StypMulDiv as StypMulDiv_,\n  StypNumeric,\n  StypNumericStruct,\n} from './numeric';\nimport { StypZero } from './zero';\n\n/**\n * @internal\n */\nexport class StypDimension<Unit extends string>\n    extends StypNumericStruct<StypDimension<Unit>, Unit>\n    implements StypDimension_<Unit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'dimension' {\n    return 'dimension';\n  }\n\n  /**\n   * The number value.\n   */\n  readonly val: number;\n\n  /**\n   * The unit.\n   */\n  readonly unit: Unit;\n\n  /**\n   * Constructs new structured dimension value.\n   *\n   * @param val  The numeric value.\n   * @param unit  The unit.\n   * @param opts  CSS value options.\n   */\n  constructor(val: number, unit: Unit, opts: StypDimension_.Opts<Unit>) {\n    super(opts);\n    this.val = val;\n    this.unit = unit;\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypDimension_<U> | undefined {\n\n    const thisDim: StypDimension_.Kind<any> = this.dim;\n\n    if (dim === thisDim /* same dimension */\n        || dim === thisDim.pt /* !% to compatible +% */\n        || dim === (this.unit === '%' ? dim.pt /* % to any +% */ : thisDim.noPt /* !% to compatible -% */)) {\n      return this as StypDimension_<any>;\n    }\n\n    return;\n  }\n\n  is(other: StypValue): boolean {\n    if (other === this) {\n      return true;\n    }\n    return typeof other === 'object'\n        && other.type === this.type\n        && this.unit === other.unit\n        && this.val === other.val\n        && this.priority === other.priority;\n  }\n\n  prioritize(priority: number): StypDimension<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypDimension(this.val, this.unit, { dim: this.dim, priority });\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit || this.unit, this);\n    }\n    if (addendum.type === 'dimension' && this.unit === addendum.unit) {\n      return stypDimension(this.val + addendum.val, this.unit, this);\n    }\n    return stypAddSub(this, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit?: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit || this.unit, this);\n    }\n    if (subtrahend.type === 'dimension' && this.unit === subtrahend.unit) {\n      return stypDimension(this.val - subtrahend.val, this.unit, this);\n    }\n    return stypAddSub(this, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return multiplier === 1 ? this : stypDimension(this.val * multiplier, this.unit, this);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return divisor === 1 ? this : stypDimension(this.val / divisor, this.unit, this);\n  }\n\n  negate(): StypNumeric<Unit> {\n    return stypDimension(-this.val, this.unit, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `<value><unit>` or just `0`.\n   */\n  toFormula(): string {\n    return this.val + this.unit;\n  }\n\n}\n\n/**\n * Constructs structured [dimension] CSS property value.\n *\n * @param val  Numeric value.\n * @param unit  Value unit.\n * @param opts  Construction options.\n *\n * @returns Either [[StypDimension]], or [[StypZero]] if `val === 0`.\n *\n * [dimension]: https://developer.mozilla.org/en-US/docs/Web/CSS/dimension\n *\n * @internal\n */\nexport function stypDimension<Unit extends string>(\n    val: number,\n    unit: Unit,\n    opts: StypDimension_.Opts<Unit>): StypDimension_<Unit> | StypZero<Unit> {\n  return val\n      ? new StypDimension<Unit>(val, unit, opts)\n      : opts.dim.zero.prioritize(opts.priority || StypPriority.Default);\n}\n\n/**\n * @internal\n */\nexport abstract class StypCalcBase<\n    Self extends StypCalcBase<Self, Op, Right, Unit>,\n    Op extends '+' | '-' | '*' | '/',\n    Right extends number | StypNumeric<Unit>,\n    Unit extends string>\n    extends StypNumericStruct<Self, Unit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'calc' {\n    return 'calc';\n  }\n\n  readonly left: StypNumeric<Unit>;\n  readonly op: Op;\n  readonly right: Right;\n\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(\n      left: StypNumeric<Unit>,\n      op: Op,\n      right: Right,\n      opts: StypDimension_.Opts<Unit>) {\n    super(opts);\n    this.left = left.usual();\n    this.op = op;\n    this.right = right;\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object' && other.type === this.type) {\n      return this.op === other.op\n          && this.left.is(other.left)\n          && stypValuesEqual(this.right, other.right)\n          && this.priority === other.priority;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as Unit, this);\n    }\n    return stypAddSub(this as StypNumeric<Unit>, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as Unit, this);\n    }\n    return stypAddSub(this as StypNumeric<Unit>, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return stypMul(this as StypNumeric<Unit>, multiplier);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return stypDiv(this as StypNumeric<Unit>, divisor);\n  }\n\n  abstract negate(): StypNumeric<Unit>;\n\n  abstract prioritize(priority: number): Self;\n\n  abstract toFormula(): string;\n\n  toString() {\n    return 'calc' + super.toString();\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @typeparam Unit  Allowed unit type.\n *\n * @internal\n */\nexport class StypAddSub<Unit extends string>\n    extends StypCalcBase<StypAddSub<Unit>, '+' | '-', StypNumeric<Unit>, Unit>\n    implements StypAddSub_<Unit> {\n\n  constructor(left: StypNumeric<Unit>, op: '+' | '-', right: StypNumeric<Unit>, opts: StypDimension_.Opts<Unit>) {\n    super(left, op, right.usual(), opts);\n  }\n\n  prioritize(priority: number): StypAddSub<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypAddSub(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypAddSub<U> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    const right = this.right.toDim(dim);\n\n    if (!right) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any> && right === this.right as StypNumeric<any>) {\n      return this as StypAddSub<any>;\n    }\n\n    return new StypAddSub<U>(left, this.op, right, { dim, priority: this.priority });\n  }\n\n  negate(): StypNumeric<Unit> {\n    return this.op === '-'\n        ? new StypAddSub(this.right, this.op, this.left, this)\n        : new StypAddSub(this.left.negate(), '-', this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right.toFormula()})`;\n  }\n\n}\n\nfunction stypAddSub<Unit extends string>(\n    left: StypNumeric<Unit>,\n    op: '+' | '-',\n    right: StypNumeric<Unit>): StypNumeric<Unit> {\n  return !right.type ? left : new StypAddSub(left, op, right, left);\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @typeparam Unit  Allowed unit type.\n *\n * @internal\n */\nexport class StypMulDiv<Unit extends string>\n    extends StypCalcBase<StypMulDiv<Unit>, '*' | '/', number, Unit>\n    implements StypMulDiv_<Unit> {\n\n  prioritize(priority: number): StypMulDiv<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypMulDiv(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypMulDiv<U> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any>) {\n      return this as StypMulDiv<any>;\n    }\n\n    return new StypMulDiv<U>(left, this.op, this.right, { dim, priority: this.priority });\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return (this.op === '*'\n        ? stypMul(this.left, this.right * multiplier)\n        : stypDiv(this.left, this.right / multiplier))\n        .prioritize(this.priority);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return (this.op === '/'\n        ? stypDiv(this.left, this.right * divisor)\n        : stypMul(this.left, this.right / divisor))\n        .prioritize(this.priority);\n  }\n\n  negate(): StypNumeric<Unit> {\n    return new StypMulDiv(this.left, this.op, -this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right})`;\n  }\n\n}\n\nfunction stypMul<Unit extends string>(left: StypNumeric<Unit>, right: number): StypNumeric<Unit> {\n  return !right\n      ? left.dim.zero.prioritize(left.priority)\n      : right === 1\n          ? left.prioritize(left.priority)\n          : new StypMulDiv(left, '*', right, left);\n}\n\nfunction stypDiv<Unit extends string>(left: StypNumeric<Unit>, right: number): StypNumeric<Unit> {\n  return right === 1\n      ? left.prioritize(left.priority)\n      : new StypMulDiv(left, '/', right, left);\n}\n\n/**\n * @internal\n */\nexport function isStypNumeric(source: StypValue): source is StypNumeric<any, any> {\n  return typeof source === 'object' && (source.type === 'dimension' || source.type === 'calc' || source.type === 0);\n}\n","import { StypPriority } from '../priority';\nimport { StypValue } from '../value';\nimport { StypDimension, StypNumeric, StypNumericStruct } from './';\nimport { stypDimension } from './numeric.impl';\nimport { StypZero } from './zero';\n\nclass Zero<Unit extends string> extends StypNumericStruct<Zero<Unit>, Unit> implements StypZero<Unit> {\n\n  constructor(private readonly _byPriority: ZeroByPriority<Unit>, opts: StypDimension.Opts<Unit>) {\n    super(opts);\n  }\n\n  get type(): 0 {\n    return 0;\n  }\n\n  toDim<U extends string>(dim: StypDimension.Kind<U>): StypDimension<U> | StypZero<U> {\n    return dim.zero.prioritize(this.priority);\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object') {\n      return other.type === this.type && other.priority === this.priority;\n    }\n    if (other === 0 || other === '0') {\n      return this.priority === StypPriority.Usual;\n    }\n    if (other === '0 !important') {\n      return this.priority === StypPriority.Important;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as Unit, this);\n    }\n    return addendum.prioritize(this.priority);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as Unit, this);\n    }\n    return subtrahend.negate().prioritize(this.priority);\n  }\n\n  mul(): this {\n    return this;\n  }\n\n  div(): this {\n    return this;\n  }\n\n  negate(): this {\n    return this;\n  }\n\n  prioritize(priority: number): Zero<Unit> {\n    return this._byPriority.get(priority);\n  }\n\n  important(): Zero<Unit> {\n    return this._byPriority.important;\n  }\n\n  usual(): Zero<Unit> {\n    return this._byPriority.usual;\n  }\n\n  toFormula(): string {\n    return '0';\n  }\n\n}\n\nclass ZeroByPriority<Unit extends string> {\n\n  readonly usual: Zero<Unit>;\n  readonly important: Zero<Unit>;\n\n  constructor(readonly dim: StypDimension.Kind<Unit>) {\n    this.usual = new Zero(this, { dim });\n    this.important = new Zero(this, { dim, priority: StypPriority.Important });\n  }\n\n  get(priority: number): Zero<Unit> {\n    switch (priority) {\n      case StypPriority.Usual: return this.usual;\n      case StypPriority.Important: return this.important;\n    }\n    return new Zero(this, { dim: this.dim, priority });\n  }\n\n}\n\n/**\n * @internal\n */\nexport function newStypZero<Unit extends string>(dim: StypDimension.Kind.UnitlessZero<Unit>): StypZero<Unit> {\n  return new ZeroByPriority<Unit>(dim).usual;\n}\n","import { StypValue } from '../value';\nimport { StypDimension, StypNumeric } from './numeric';\nimport { isStypNumeric, StypDimension as StypDimension_ } from './numeric.impl';\nimport { StypZero } from './zero';\nimport { newStypZero } from './zero.impl';\n\n/**\n * @internal\n */\nexport function unitlessZeroDimensionKind<Unit extends string>(\n    {\n      pt,\n      noPt,\n    }: {\n      pt: () => StypDimension.Kind.UnitlessZero<Unit | '%'>,\n      noPt: () => StypDimension.Kind.UnitlessZero<Exclude<Unit, '%'>>,\n    }\n): StypDimension.Kind.UnitlessZero<Unit> {\n\n  const dimension: StypDimension.Kind.UnitlessZero<Unit> = {\n\n    get zero(): StypZero<Unit> {\n      return zero;\n    },\n\n    get pt() {\n      return pt();\n    },\n\n    get noPt() {\n      return noPt();\n    },\n\n    of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit> {\n      return val ? new StypDimension_(val, unit, { dim: this }) : zero;\n    },\n\n    by(source: StypValue): StypNumeric<Unit> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n\n      const numeric: StypNumeric<any, any> = source;\n\n      return numeric.toDim(this);\n    }\n\n  };\n\n  const zero = newStypZero<Unit>(dimension);\n\n  return dimension;\n}\n\n/**\n * @internal\n */\nexport function unitZeroDimensionKind<Unit extends string>(\n    {\n      zeroUnit,\n      withPercent,\n      noPercent,\n    }: {\n      zeroUnit: Unit,\n      withPercent?: () => StypDimension.Kind.UnitZero<Unit | '%'>,\n      noPercent?: () => StypDimension.Kind.UnitZero<Exclude<Unit, '%'>>,\n    }): StypDimension.Kind.UnitZero<Unit> {\n\n  const dimension: StypDimension.Kind.UnitZero<Unit> = {\n\n    get pt() {\n      return withPercent && withPercent();\n    },\n\n    get noPt() {\n      return noPercent ? noPercent() : this as StypDimension.Kind.UnitZero<Exclude<Unit, '%'>>;\n    },\n\n    get zero(): StypDimension<Unit> {\n      return zero;\n    },\n\n    of(val: number, unit: Unit): StypDimension<Unit> {\n      return new StypDimension_(val, unit, { dim: this });\n    },\n\n    by(source: StypValue): StypNumeric<Unit, StypDimension<Unit>> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n\n      const numeric: StypNumeric<any, any> = source;\n\n      return numeric.toDim(this);\n    },\n\n  };\n\n  const zero = new StypDimension_(0, zeroUnit, { dim: dimension });\n\n  return dimension;\n}\n","/**\n * @module style-producer\n */\nimport { StypDimension, StypNumeric } from '../numeric';\nimport { unitlessZeroDimensionKind } from '../numeric/dimension-kind.impl';\n\n/**\n * Structured [angle](https://developer.mozilla.org/en-US/docs/Web/CSS/angle) property value.\n *\n * Can be constructed using `StypAngle.of()` function.\n *\n * @category CSS Value\n */\nexport type StypAngle = StypNumeric<StypAngle.Unit>;\n\nexport namespace StypAngle {\n\n  /**\n   * Supported angle units, excluding percent.\n   */\n  export type Unit = 'deg' | 'grad' | 'rad' | 'turn';\n\n}\n\nexport const StypAngle: StypDimension.Kind.UnitlessZero<StypAngle.Unit> = /*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypAnglePt;\n  },\n  noPt() {\n    return StypAngle;\n  },\n});\n\n/**\n * Structured [angle-percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/angle-percentage) CSS property value.\n *\n * Can be constructed using `StypAnglePt.of()` function.\n *\n * @category CSS Value\n */\nexport type StypAnglePt = StypNumeric<StypAnglePt.Unit>;\n\nexport namespace StypAnglePt {\n\n  /**\n   * Supported angle units, including percent.\n   */\n  export type Unit = StypAngle.Unit | '%';\n\n}\n\nexport const StypAnglePt: StypDimension.Kind.UnitlessZero<StypAnglePt.Unit> =\n    /*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypAnglePt;\n  },\n  noPt() {\n    return StypAngle;\n  },\n});\n","/**\n * @module style-producer\n */\nimport { StypDimension, StypNumeric } from '../numeric';\nimport { unitZeroDimensionKind } from '../numeric/dimension-kind.impl';\n\n/**\n * Structured [frequency](https://developer.mozilla.org/en-US/docs/Web/CSS/frequency) CSS property value.\n *\n * Can be constructed using `StypFrequency.of()` function.\n *\n * @category CSS Value\n */\nexport type StypFrequency = StypNumeric<StypFrequency.Unit, StypDimension<StypFrequency.Unit>>;\n\nexport namespace StypFrequency {\n\n  /**\n   * Supported frequency units, excluding percent.\n   */\n  export type Unit = 'Hz' | 'kHz';\n\n}\n\nexport const StypFrequency: StypDimension.Kind.UnitZero<StypFrequency.Unit> = /*#__PURE__*/ unitZeroDimensionKind({\n  zeroUnit: 'kHz',\n  withPercent() {\n    return StypFrequencyPt;\n  },\n  noPercent() {\n    return StypFrequency;\n  },\n});\n\n/**\n * Structured [frequency-percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/frequency-percentage) CSS\n * property value.\n *\n * Can be constructed using `StypFrequencyPt.of()` function.\n *\n * @category CSS Value\n */\nexport type StypFrequencyPt = StypNumeric<StypFrequencyPt.Unit, StypDimension<StypFrequencyPt.Unit>>;\n\nexport namespace StypFrequencyPt {\n\n  /**\n   * Supported frequency units, including percent.\n   */\n  export type Unit = StypFrequency.Unit | '%';\n\n}\n\nexport const StypFrequencyPt: StypDimension.Kind.UnitZero<StypFrequencyPt.Unit> = /*#__PURE__*/ unitZeroDimensionKind({\n  zeroUnit: 'kHz',\n  withPercent() {\n    return StypFrequencyPt;\n  },\n  noPercent() {\n    return StypFrequency;\n  },\n});\n","/**\n * @module style-producer\n */\nimport { StypDimension, StypNumeric } from '../numeric';\nimport { unitlessZeroDimensionKind } from '../numeric/dimension-kind.impl';\n\n/**\n * Structured [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) property value.\n *\n * Can be constructed using `StypLength.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLength = StypNumeric<StypLength.Unit>;\n\nexport namespace StypLength {\n\n  /**\n   * Supported length units, excluding percent.\n   */\n  export type Unit = 'cap' | 'ch' | 'em' | 'ex' | 'ic' | 'lh' | 'rem' | 'rlh'\n      | 'vh' | 'vw' | 'vi' | 'vb' | 'vmin' | 'vmax'\n      | 'px' | 'cm' | 'mm' | 'Q' | 'in' | 'pc' | 'pt';\n\n}\n\nexport const StypLength: StypDimension.Kind.UnitlessZero<StypLength.Unit> =\n    /*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypLengthPt;\n  },\n  noPt() {\n    return StypLength;\n  },\n});\n\n/**\n * Structured [length-percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage) CSS property\n * value.\n *\n * Can be constructed using `StypLengthPt.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLengthPt = StypNumeric<StypLengthPt.Unit>;\n\nexport namespace StypLengthPt {\n\n  /**\n   * Supported length units, including percent.\n   */\n  export type Unit = StypLength.Unit | '%';\n\n}\n\nexport const StypLengthPt: StypDimension.Kind.UnitlessZero<StypLengthPt.Unit> =\n    /*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypLengthPt;\n  },\n  noPt() {\n    return StypLength;\n  },\n});\n","import { filterIt, itsIterator, itsReduction, overEntries } from 'a-iterable';\nimport { asis, isPresent, nextSkip, NextSkip, valuesProvider } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  isEventSender,\n} from 'fun-events';\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue, stypValuesEqual } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * @internal\n */\nexport const noStypProperties: AfterEvent<[StypProperties]> = /*#__PURE__*/ afterThe({});\n\n/**\n * @internal\n */\nexport function noStypPropertiesSpec() {\n  return noStypProperties;\n}\n\n/**\n * @internal\n */\nexport function stypPropertiesBySpec(rule: StypRule, spec?: StypProperties.Spec): AfterEvent<[StypProperties]> {\n  if (!spec) {\n    return noStypProperties;\n  }\n  if (typeof spec !== 'string') {\n    if (isEventKeeper(spec)) {\n      return preventDuplicates(spec);\n    }\n    if (isEventSender(spec)) {\n      return preventDuplicates(propertiesKeeper(spec));\n    }\n    if (typeof spec === 'function') {\n\n      const senderOrProperties = spec(rule);\n\n      if (typeof senderOrProperties !== 'string') {\n        if (isEventKeeper(senderOrProperties)) {\n          return preventDuplicates(senderOrProperties);\n        }\n        if (isEventSender(senderOrProperties)) {\n          return preventDuplicates(propertiesKeeper(senderOrProperties));\n        }\n      }\n\n      return afterThe(propertiesMap(senderOrProperties));\n    }\n  }\n\n  return afterThe(propertiesMap(spec));\n}\n\nfunction propertiesKeeper(sender: EventSender<[string | StypProperties]>): AfterEvent<[string | StypProperties]> {\n  return afterSupplied(sender, valuesProvider({}));\n}\n\nfunction preventDuplicates(properties: EventKeeper<[string | StypProperties]>): AfterEvent<[StypProperties]> {\n  return afterSupplied(properties).keep.thru(\n      propertiesMap,\n      passNonDuplicate(),\n      asis as (props: StypProperties) => StypProperties, // Needed to satisfy signature\n  );\n}\n\nfunction passNonDuplicate(): (update: StypProperties) => StypProperties | NextSkip<[StypProperties], StypProperties> {\n\n  let stored: StypProperties | undefined;\n\n  return update => {\n    if (stored && propertiesEqual(update, stored)) {\n      return nextSkip();\n    }\n    return stored = { ...update };\n  };\n}\n\nfunction propertiesMap(properties: string | StypProperties): StypProperties {\n  return typeof properties === 'string' ? { $$css: properties } : properties;\n}\n\nfunction propertiesEqual(first: StypProperties, second: StypProperties): boolean {\n\n  const s = itsIterator(propertyEntries(second));\n\n  for (const [key, value] of propertyEntries(first)) {\n\n    const { value: sentry } = s.next();\n\n    if (!sentry || key !== sentry[0] || !stypValuesEqual(value, sentry[1])) {\n      return false;\n    }\n  }\n\n  return !s.next().value;\n}\n\nfunction propertyEntries(properties: StypProperties): Iterable<[keyof StypProperties, StypValue]> {\n  return filterIt(overEntries(properties), isPresent);\n}\n\n/**\n * @internal\n */\nexport function mergeStypProperties(\n    base: AfterEvent<[StypProperties]>,\n    addendum: AfterEvent<[StypProperties]>):\n    AfterEvent<[StypProperties]> {\n  return preventDuplicates(\n      afterAll({ base, addendum })\n          .keep.thru(({ base: [baseProperties], addendum: [addendumProperties] }) =>\n              addValues(baseProperties, addendumProperties)));\n}\n\nfunction addValues(base: StypProperties, addendum: StypProperties): StypProperties {\n  return itsReduction(\n      overEntries(addendum),\n      (result, [k, v]) => addValue(result, k, v),\n      { ...base });\n}\n\nfunction addValue(\n    properties: StypProperties.Mutable,\n    key: keyof StypProperties,\n    value: StypValue): StypProperties.Mutable {\n  if (priorityOf(properties[key]) <= priorityOf(value)) {\n    delete properties[key];\n    properties[key] = value;\n  }\n  return properties;\n}\n\nfunction priorityOf(value: StypValue): number {\n  switch (typeof value) {\n    case 'string':\n      return value.endsWith(IMPORTANT_CSS_SUFFIX) ? 1 : 0;\n    case 'object':\n      return value.priority;\n  }\n  return 0;\n}\n","import { flatMapIt, itsReduction } from 'a-iterable';\nimport { compareNames, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { isNotEmptyArray, isReadonlyArray } from '../internal';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\n\n/**\n * @internal\n */\nexport function isCombinator(item: string | StypSelector.Part | StypSelector.Combinator):\n    item is StypSelector.Combinator {\n  return item === '>' || item === '+' || item === '~';\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelectorPart(part: StypSelector.Part): StypSelector.NormalizedPart {\n  return {\n    ns: part.ns || undefined,\n    e: normalizeElement(part.e),\n    i: part.i || undefined,\n    s: part.s || undefined,\n    c: normalizeClasses(part.c),\n    $: normalizeQualifiers(part.$)\n  };\n}\n\nfunction normalizeElement(e: QualifiedName | undefined): QualifiedName | undefined {\n  return e !== '*' && e || undefined;\n}\n\nfunction normalizeClasses(classes: QualifiedName | readonly QualifiedName[] | undefined):\n    readonly [QualifiedName, ...QualifiedName[]] | undefined {\n  if (!classes) {\n    return;\n  }\n  if (isQualifiedName(classes)) {\n    return [classes];\n  }\n\n  const result = classes.filter(c => !!c);\n\n  return isNotEmptyArray(result) ? result.sort(compareNames) : undefined;\n}\n\nfunction normalizeQualifiers(qualifiers: string | readonly string[] | undefined):\n    readonly [string, ...string[]] | undefined {\n  if (!qualifiers) {\n    return;\n  }\n\n  if (!isReadonlyArray(qualifiers)) {\n    qualifiers = [...exposeQualifier(qualifiers)];\n  } else {\n    qualifiers = [\n      ...itsReduction(\n          flatMapIt(qualifiers, exposeQualifier),\n          (set, qualifier) => set.add(qualifier),\n          new Set<string>())\n    ].sort();\n  }\n\n  return isNotEmptyArray(qualifiers) ? qualifiers : undefined;\n}\n\nconst noQualifiers: Set<string> = new Set();\n\nfunction exposeQualifier(qualifier: string): Set<string> {\n  if (!qualifier) {\n    return noQualifiers;\n  }\n\n  const eqIdx = qualifier.indexOf('=');\n  const name = eqIdx < 0 ? qualifier : qualifier.substring(0, eqIdx);\n  const exposed = new Set<string>();\n  let lastExposed: string | undefined;\n\n  for (const part of name.split(':')) {\n    if (lastExposed) {\n      lastExposed += ':' + part;\n    } else {\n      lastExposed = part;\n    }\n    exposed.add(lastExposed);\n  }\n  if (eqIdx >= 0) {\n    exposed.add(qualifier);\n  }\n\n  return exposed;\n}\n\nconst noKeyAndTail: [[]] = [[]];\n\n/**\n * @internal\n */\nexport function stypRuleKeyAndTail(\n    selector: StypSelector.Normalized):\n    [[]] | [StypRuleKey.Nested, StypSelector.Normalized?] {\n  if (!selector.length) {\n    return noKeyAndTail;\n  }\n\n  let i = 0;\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (;;) {\n\n    const part = selector[i++];\n\n    if (isCombinator(part)) {\n      combinator = part;\n      continue;\n    }\n\n    const key: StypRuleKey = combinator ? [combinator, part] : [part];\n\n    return [key, selector.slice(i)];\n  }\n}\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * @internal\n */\nexport function stypOuterSelector(selector: StypSelector.Normalized): StypSelector.Normalized | undefined {\n\n  let i = selector.length - 1;\n\n  if (i <= 0) {\n    return i ? undefined : rootSelector;\n  }\n\n  do {\n    --i;\n    switch (selector[i]) {\n      case '>':\n        return selector.slice(0, i);\n      case '+':\n      case '~':\n        --i;\n        continue;\n      default:\n        return selector.slice(0, i + 1);\n    }\n  } while (i > 0);\n\n  return;\n}\n","/**\n * @module style-producer\n */\nimport { namesEqual, NamespaceDef, QualifiedName } from 'namespace-aliaser';\nimport { StypSelector } from './selector';\nimport { normalizeStypSelectorPart } from './selector.impl';\n\n/**\n * CSS rule query.\n *\n * It may represent a selector like `element-name#id.class1.classN` with any of sub-parts omitted.\n *\n * Queries are used to grab a subset of matching rules from `StypRule`.\n *\n * All of its properties are optional.\n *\n * @category CSS Rule\n */\nexport interface StypQuery {\n\n  /**\n   * Element namespace.\n   */\n  readonly ns?: string | NamespaceDef;\n\n  /**\n   * Element name.\n   *\n   * This is the same as `*` when absent.\n   */\n  readonly e?: QualifiedName;\n\n  /**\n   * Element identifier.\n   */\n  readonly i?: QualifiedName;\n\n  /**\n   * Element class name or names.\n   */\n  readonly c?: QualifiedName | readonly QualifiedName[];\n\n  /**\n   * Qualifier or qualifiers.\n   */\n  readonly $?: string | readonly string[];\n\n}\n\nexport namespace StypQuery {\n\n  /**\n   * Normalized CSS rule query.\n   */\n  export type Normalized = StypQuery & StypSelector.NormalizedPart;\n\n}\n\n/**\n * Normalizes arbitrary CSS rule query.\n *\n * @category CSS Rule\n * @param query  CSS rule query to normalize.\n *\n * @returns Normalized CSS rule query.\n */\nexport function stypQuery(query: StypQuery): StypQuery.Normalized {\n  return normalizeStypSelectorPart(query);\n}\n\n/**\n * Checks whether the given structured CSS `selector` matches the target `query`.\n *\n * @category CSS Rule\n * @param selector  Normalized structured CSS selector.\n * @param query  Normalized CSS rule query.\n *\n * @returns `true` if `selector` matches the `query`, or `false` otherwise.\n */\nexport function stypSelectorMatches(selector: StypSelector.Normalized, query: StypQuery.Normalized): boolean {\n  if (!selector.length) {\n    return false;\n  }\n\n  const part = selector[selector.length - 1] as StypSelector.NormalizedPart;\n\n  if (query.ns && part.ns !== query.ns) {\n    return false;\n  }\n  if (query.e && part.e !== query.e) {\n    return false;\n  }\n  if (query.i && part.i !== query.i) {\n    return false;\n  }\n  if (query.c && !classesMatch(part.c, query.c)) {\n    return false;\n  }\n  // noinspection RedundantIfStatementJS\n  if (query.$ && !classesMatch(part.$, query.$)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction classesMatch(classes: readonly QualifiedName[] | undefined, query: readonly QualifiedName[]) {\n  return classes && query.every(qClass => classes.find(mClass => namesEqual(qClass, mClass)));\n}\n","import { isReadonlyArray } from '../internal';\nimport { StypSelector } from './index';\nimport { isCombinator, normalizeStypSelectorPart } from './selector.impl';\n\n/**\n * Converts normalized CSS selector part to normalized CSS selector.\n *\n * @category CSS Rule\n * @param selector  Normalized CSS selector part.\n *\n * @returns Normalized structured CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * Normalizes arbitrary structured CSS selector.\n *\n * @param selector  CSS selector to normalize.\n *\n * @returns Normalized structured CSS selector.\n */\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized {\n  if (!isReadonlyArray(selector)) {\n    return [normalizeKey(selector)];\n  }\n\n  const normalized: StypSelector.Mutable = [];\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (const item of selector) {\n\n    const prevCombinator = combinator;\n\n    if (combinator) {\n      normalized.push(combinator);\n      combinator = undefined;\n    }\n\n    let part: StypSelector.NormalizedPart;\n\n    if (isCombinator(item)) {\n      combinator = item;\n      if (!prevCombinator) {\n        continue;\n      }\n      part = {};\n    } else {\n      part = normalizeKey(item);\n    }\n\n    normalized.push(part);\n  }\n  if (combinator) {\n    normalized.push(combinator, {});\n  }\n\n  return normalized;\n}\n\nfunction normalizeKey(key: StypSelector.Part | string): StypSelector.NormalizedPart {\n  if (typeof key === 'string') {\n    if (!key) {\n      return {};\n    }\n    return { s: key };\n  }\n  return normalizeStypSelectorPart(key);\n}\n","import {\n  css__naming,\n  html__naming,\n  id__naming,\n  NamespaceAliaser,\n  NamespaceDef,\n  newNamespaceAliaser,\n} from 'namespace-aliaser';\nimport { cssescId } from '../internal';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSelectorFormat } from './selector-text';\nimport { isCombinator } from './selector.impl';\n\nconst ruleKeyTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${cssescId(qualifier)}`;\n  }\n};\n\n/**\n * @internal\n */\nexport function stypRuleKeyText(key: StypRuleKey): string {\n  return formatStypSelector(key, ruleKeyTextOpts);\n}\n\nconst displayTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${qualifier}`;\n  }\n};\n\n/**\n * @internal\n */\nexport function stypSelectorDisplayText(selector: StypSelector.Normalized): string {\n  return formatStypSelector(selector, displayTextOpts);\n}\n\nconst defaultFormat: StypSelectorFormat = {};\n\n/**\n * @internal\n */\nexport function formatStypSelector(\n    selector: StypSelector.Normalized,\n    {\n      qualify,\n      nsAlias = newNamespaceAliaser(),\n    }: StypSelectorFormat = defaultFormat): string {\n\n  const format: ItemFormat = { qualify, nsAlias };\n\n  return selector.reduce(\n      (result, item) => {\n        if (isCombinator(item)) {\n          return result + item;\n        }\n        if (result && !isCombinator(result[result.length - 1])) {\n          result += ' ';\n        }\n        return result + formatItem(item, format);\n      },\n      '');\n}\n\ninterface ItemFormat extends StypSelectorFormat {\n  nsAlias: NamespaceAliaser;\n}\n\nfunction formatItem(\n    item: StypSelector.NormalizedPart,\n    {\n      qualify,\n      nsAlias,\n    }: ItemFormat): string {\n\n  const { ns, e, i, c, s, $ } = item;\n  let hasProperties = false;\n  let string = '';\n\n  if (i) {\n    hasProperties = true;\n    string += `#${cssescId(id__naming.name(i, nsAlias))}`;\n  }\n  if (c) {\n    hasProperties = true;\n    string = c.reduce<string>(\n        (result, className) => `${result}.${cssescId(css__naming.name(className, nsAlias))}`,\n        string);\n  }\n  if (s) {\n    hasProperties = true;\n    string += s;\n  }\n  if (qualify && $) {\n    string = $.reduce((result, qualifier) => result + qualify(qualifier), string);\n  }\n  if (ns) {\n\n    const alias = xmlNs(ns, nsAlias);\n\n    if (alias) {\n      string = `${alias}|${e || '*'}${string}`;\n    } else {\n      string = qualifyElement();\n    }\n  } else {\n    string = qualifyElement();\n  }\n\n  return string;\n\n  function qualifyElement(): string {\n    if (hasProperties) {\n      return `${e ? html__naming.name(e, nsAlias) : ''}${string}`;\n    }\n    return `${e ? html__naming.name(e, nsAlias) : '*'}${string}`;\n  }\n}\n\nfunction xmlNs(ns: string | NamespaceDef, nsAlias: NamespaceAliaser): string | undefined {\n  return typeof ns === 'string' ? ns : ns.url ? nsAlias(ns) : undefined;\n}\n","/**\n * @module style-producer\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from 'a-iterable';\nimport hyphenateStyleName from 'hyphenate-style-name';\nimport { StypProperties } from '../rule';\nimport { StypPriority, stypSplitPriority } from '../value';\nimport { StyleProducer } from './style-producer';\n\n/**\n * Renders CSS properties.\n *\n * This render is always present, so there is typically no need to use it explicitly.\n *\n * @category Rendering\n */\nexport function stypRenderProperties(producer: StyleProducer, properties: StypProperties): void {\n\n  const cssRule = producer.addRule() as CSSStyleRule;\n  const { style } = cssRule;\n\n  itsEach(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          notCustomProperty),\n      ([k, v]) => {\n\n        const [value, priority] = stypSplitPriority(v);\n\n        style.setProperty(\n            hyphenateStyleName(k),\n            `${value}`,\n            priority >= StypPriority.Important ? 'important' : undefined);\n      });\n\n  producer.render(properties, { target: cssRule });\n}\n\nfunction notCustomProperty(entry: ObjectEntry<StypProperties>): entry is ObjectEntry<Required<StypProperties>, string> {\n\n  const [key, value] = entry;\n\n  if (value == null) {\n    return false;\n  }\n\n  const first = String(key)[0];\n\n  return first >= 'a' && first <= 'z' || first >= 'A' && first <= 'Z';\n}\n","/**\n * @module style-producer\n */\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue } from './value';\n\n/**\n * Predefined CSS property value priorities.\n *\n * @category CSS Value\n */\nexport const enum StypPriority {\n\n  /**\n   * Usual, non-important priority.\n   *\n   * This priority is assigned to values by [[StypValueStruct.usual]] method.\n   */\n  Usual = 0,\n\n  /**\n   * Default priority.\n   *\n   * The same as `Usual`. This priority is assigned to values by default.\n   */\n  Default = Usual,\n\n  /**\n   * Important priority.\n   *\n   * This priority corresponds to values with `!important` suffix. It is applied to string values with `!important`\n   * suffix, and can be assigned to structured values using [[StypValueStruct.important]] method.\n   *\n   * All numeric priorities with higher values are rendered as `!important` ones.\n   */\n  Important = 1,\n\n}\n\n/**\n * Splits undefined CSS property value onto non-prioritized value and priority.\n *\n * @category CSS Value\n * @param value  Undefined CSS property value to split.\n *\n * @returns An `[undefined, 0]` tuple.\n */\nexport function stypSplitPriority<T extends StypValue>(value: undefined): [undefined, 0];\n\n/**\n * Splits string CSS property value onto non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value without `!priority` suffix, and numeric priority (0 or 1).\n */\nexport function stypSplitPriority(value: string): [string, 0 | 1];\n\n/**\n * Splits scalar CSS property value onto non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value and `0` priority.\n */\nexport function stypSplitPriority<T extends number | boolean>(value: T): [T, 0];\n\n/**\n * Splits arbitrary CSS property value onto value non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value and numeric priority.\n */\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number];\n\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number] {\n  if (value == null) {\n    return [undefined as T, StypPriority.Default];\n  }\n\n  switch (typeof value) {\n    case 'object':\n      return [value, value.priority];\n    case 'string':\n      if (value.endsWith(IMPORTANT_CSS_SUFFIX)) {\n        return[value.substring(0, value.length - IMPORTANT_CSS_SUFFIX.length).trim() as T, StypPriority.Important];\n      }\n  }\n\n  return [value, StypPriority.Default];\n}\n","import { isReadonlyArray } from '../internal';\nimport { StypRule } from '../rule';\nimport { stypRenderProperties } from './properties.render';\nimport { StypRender } from './render';\nimport { StypOptions } from './style-producer';\n\nexport interface StypRenderSpecFactory extends StypRender.Factory {\n  create(rule: StypRule): StypRender.Spec;\n}\n\n/**\n * @internal\n */\nexport function stypRenderFactories(opts: StypOptions): readonly StypRenderSpecFactory[] {\n\n  const factories = new Map<StypRender, StypRenderSpecFactory>();\n\n  addRenders(opts.render);\n  factories.delete(stypRenderProperties);\n\n  return [...factories.values(), renderFactory(stypRenderProperties)].sort(compareRenders);\n\n  function addRenders(renders: StypRender | readonly StypRender[] | undefined) {\n    if (renders) {\n      if (isReadonlyArray(renders)) {\n        renders.forEach(addRender);\n      } else {\n        addRender(renders);\n      }\n    }\n  }\n\n  function addRender(render: StypRender) {\n    if (factories.has(render)) {\n      return;\n    }\n\n    const factory = renderFactory(render);\n\n    factories.set(render, factory);\n    addRenders(factory.needs);\n  }\n}\n\nfunction renderFactory(render: StypRender): StypRenderSpecFactory {\n  if (typeof render === 'function') {\n    return {\n      create() {\n        return { render: render as StypRender.Function<any> };\n      }\n    };\n  }\n  if (isFactory(render)) {\n    return {\n      order: render.order,\n      needs: render.needs,\n      create(rule) {\n        return renderSpec(render.create(rule));\n      },\n    };\n  }\n\n  const doRender = render.render.bind(render);\n\n  return {\n    order: render.order,\n    needs: render.needs,\n    create() {\n      return { render: doRender };\n    },\n  };\n}\n\nfunction isFactory(render: StypRender): render is StypRender.Factory {\n  return 'create' in render;\n}\n\nfunction compareRenders(first: StypRender.Factory, second: StypRender.Factory): number {\n\n  const firstOrder = first.order || 0;\n  const secondOrder = second.order || 0;\n\n  return firstOrder > secondOrder ? 1 : firstOrder < secondOrder ? -1 : 0;\n}\n\nfunction renderSpec(render: ReturnType<StypRender.Factory['create']>): StypRender.Spec {\n  return typeof render === 'function' ? { render: render as StypRender.Function<any> } : render;\n}\n","/**\n * @module style-producer\n */\nimport { itsEach, itsReduction, mapIt } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterSupplied, eventSupply, EventSupply, onSupplied } from 'fun-events';\nimport { NamespaceDef, newNamespaceAliaser } from 'namespace-aliaser';\nimport { StypProperties, StypRule, StypRules } from '../rule';\nimport { StypSelector, stypSelector, StypSelectorFormat, stypSelectorText } from '../selector';\nimport { isCombinator } from '../selector/selector.impl';\nimport { stypRenderFactories } from './options.impl';\nimport { StypRender } from './render';\nimport { isCSSRuleGroup } from './render.impl';\nimport { StyleProducer, StyleSheetRef, StypOptions } from './style-producer';\n\n/**\n * Produces and dynamically updates basic CSS stylesheets based on the given CSS rules.\n *\n * Unlike [[produceStyle]], this function does not enable renders but the basic one which just renders CSS properties.\n * You can enable only renders you need. This is useful only if you are not going to use all of them and want to save\n * the bundle size.\n *\n * @category Rendering\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a [[StypRule.rules]] to render all rules,\n * or a result of [[StypRuleList.grab]] method call to render only matching ones.\n * @param opts  Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceBasicStyle(rules: StypRules, opts: StypOptions = {}): EventSupply {\n\n  const {\n    document = window.document,\n    rootSelector = { e: 'body' },\n    addStyleSheet = addStyleElement,\n    schedule = scheduleInAnimationFrame,\n    nsAlias = newNamespaceAliaser(),\n  } = opts;\n  const {\n    parent = document.head,\n  } = opts;\n  const view = document.defaultView || window;\n  const format: StypSelectorFormat = { nsAlias };\n  const factories = stypRenderFactories(opts);\n  const renderSupply = renderRules(rules);\n  const trackSupply = trackRules();\n\n  return eventSupply(reason => {\n    trackSupply.off(reason);\n    renderSupply.off(reason);\n  }).needs(renderSupply).needs(trackSupply);\n\n  function styleProducer(\n      rule: StypRule,\n      render: StypRender.Function,\n      production: {\n        styleSheet: CSSStyleSheet,\n        target: CSSStyleSheet | CSSRule,\n        selector: StypSelector.Normalized,\n      }) {\n\n    class Styp implements StyleProducer {\n\n      constructor() {\n      }\n\n      get document() {\n        return document;\n      }\n\n      get parent() {\n        return parent;\n      }\n\n      get rule() {\n        return rule;\n      }\n\n      get styleSheet() {\n        return production.styleSheet;\n      }\n\n      get target() {\n        return production.target;\n      }\n\n      get selector() {\n        return production.selector;\n      }\n\n      nsAlias(ns: NamespaceDef): string {\n        return nsAlias(ns);\n      }\n\n      render(properties: StypProperties, options?: StypRender.Options): void {\n        if (!options) {\n          render(this, properties);\n        } else {\n          render(\n              styleProducer(rule, render, {\n                styleSheet: production.styleSheet,\n                target: options.target || production.target,\n                selector: options.selector || production.selector,\n              }),\n              properties);\n        }\n      }\n\n      addRule(_selector: StypSelector.Normalized = production.selector): CSSRule {\n\n        const target = production.target;\n\n        if (!isCSSRuleGroup(target)) {\n          return target;\n        }\n\n        const ruleIndex = target.insertRule(`${selectorText(_selector)}{}`, target.cssRules.length);\n\n        return target.cssRules[ruleIndex];\n      }\n\n    }\n\n    return new Styp();\n  }\n\n  function selectorText(selector: StypSelector.Normalized) {\n    return stypSelectorText(selector, format);\n  }\n\n  function renderRules(rulesToRender: Iterable<StypRule>): EventSupply {\n    return itsReduction<EventSupply, EventSupply>(\n        mapIt(rulesToRender, renderRule),\n        (prev, supply) => eventSupply(reason => {\n          supply.off(reason);\n          prev.off(reason);\n        }),\n        eventSupply(),\n    );\n  }\n\n  function trackRules(): EventSupply {\n\n    const tracked = new Map<StypRule, EventSupply>();\n    const supply = onSupplied(rules)((added, removed) => {\n      added.forEach(r => tracked.set(r, renderRule(r)));\n      removed.forEach(r => tracked.delete(r));\n    });\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      itsEach(tracked.values(), i => i.off(reason));\n      tracked.clear();\n    }).needs(supply);\n  }\n\n  function renderRule(rule: StypRule): EventSupply {\n\n    const [ reader, render ] = renderForRule(rule);\n    let _sheetRef: StyleSheetRef | undefined;\n    let _rev = 0;\n    const selector = ruleSelector(rule);\n\n    return reader(renderProperties).whenOff(removeStyle);\n\n    function renderProperties(properties: StypProperties) {\n\n      const rev = ++_rev;\n\n      schedule(renderScheduled);\n\n      function renderScheduled() {\n        if (_rev !== rev) {\n          // Properties changed since this operation scheduled.\n          // Skip their rendering.\n          return;\n        }\n\n        if (_sheetRef) {\n          clearProperties(_sheetRef.styleSheet);\n        }\n\n        const producer = styleProducer(\n            rule,\n            render,\n            {\n              get styleSheet() {\n                if (!_sheetRef) {\n                  _sheetRef = addStyleSheet(producer);\n                }\n                return _sheetRef.styleSheet;\n              },\n              get target() {\n                return this.styleSheet;\n              },\n              selector,\n            });\n\n        producer.render(properties);\n      }\n    }\n\n    function removeStyle() {\n      ++_rev;\n\n      const sheetRef = _sheetRef;\n\n      if (sheetRef) {\n        // Element removed before anything rendered.\n        // Should never happen for properly constructed rule.\n        _sheetRef = undefined;\n        return sheetRef.remove();\n      }\n    }\n\n    function clearProperties(sheet: CSSStyleSheet) {\n      while (sheet.cssRules.length) {\n        sheet.deleteRule(sheet.cssRules.length - 1);\n      }\n    }\n  }\n\n  function ruleSelector(rule: StypRule): StypSelector.Normalized {\n\n    const selector = rule.selector;\n\n    if (!selector.length) {\n      // Use configured root selector\n      return stypSelector(rootSelector);\n    }\n    if (isCombinator(selector[0])) {\n      // First combinator is relative to root selector\n      return [...stypSelector(rootSelector), ...selector];\n    }\n\n    return selector;\n  }\n\n  function renderForRule(rule: StypRule): [AfterEvent<[StypProperties]>, StypRender.Function] {\n\n    const specs = factories.map(factory => factory.create(rule));\n    const reader = specs.reduce(\n        (read, spec) => spec.read ? afterSupplied(spec.read(read)) : read,\n        rule.read);\n\n    return [reader, renderAt(0)];\n\n    function renderAt(index: number): StypRender.Function {\n      return (producer, properties) => {\n\n        const nextIndex = index + 1;\n        let nextRender: StypRender.Function;\n\n        if (nextIndex === factories.length) {\n          nextRender = noop;\n        } else {\n          nextRender = renderAt(nextIndex);\n        }\n\n        const nextProducer = styleProducer(producer.rule, nextRender, producer);\n\n        specs[index].render(nextProducer, properties);\n      };\n    }\n  }\n\n  function scheduleInAnimationFrame(operation: () => void) {\n    view.requestAnimationFrame(operation);\n  }\n}\n\nfunction addStyleElement(producer: StyleProducer): StyleSheetRef {\n\n  const { document, parent } = producer;\n  const element = document.createElement('style');\n\n  element.setAttribute('type', 'text/css');\n  element.append(document.createTextNode(''));\n\n  parent.append(element);\n\n  return {\n    styleSheet: element.sheet as CSSStyleSheet,\n    remove() {\n      element.parentElement!.removeChild(element);\n    }\n  };\n}\n","/**\n * @internal\n */\nexport const FIRST_RENDER_ORDER = -0xffff;\n\n/**\n * @internal\n */\nexport function isCSSRuleGroup(sheetOrRule: CSSStyleSheet | CSSRule): sheetOrRule is (CSSGroupingRule | CSSStyleSheet) {\n  return 'cssRules' in sheetOrRule;\n}\n","/**\n * @module style-producer\n */\nimport { NamespaceAliaser } from 'namespace-aliaser';\nimport { StypSelector } from './selector';\nimport { stypSelector } from './selector-constructor';\nimport { formatStypSelector } from './selector-text.impl';\n\n/**\n * Structured CSS selector textual format.\n *\n * @category CSS Rule\n */\nexport interface StypSelectorFormat {\n\n  /**\n   * Qualifier formatting function. When present, it is called for each qualifier to build its\n   * textual representation. When unspecified, the qualifiers won't be attached to resulting CSS selector text.\n   *\n   * @param qualifier  Qualifier to format.\n   *\n   * @returns Textual representation of `qualifier`.\n   */\n  qualify?: (qualifier: string) => string;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * New instance will be created if not specified.\n   */\n  nsAlias?: NamespaceAliaser;\n\n}\n\n/**\n * Converts structured CSS selector to its textual representation.\n *\n * @category CSS Rule\n * @param selector  Target CSS selector.\n * @param format  CSS selector format.\n *\n * @returns CSS selector string.\n */\nexport function stypSelectorText(selector: StypSelector, format?: StypSelectorFormat): string {\n  return formatStypSelector(stypSelector(selector), format);\n}\n","/**\n * @module style-producer\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { StypQuery, StypRuleKey, StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { StypRules } from './rules';\n\n/**\n * CSS rule.\n *\n * Represents CSS selector and corresponding CSS properties.\n *\n * @category CSS Rule\n */\nexport abstract class StypRule implements EventKeeper<[StypProperties]> {\n\n  /**\n   * A reference to the root CSS rule.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * A reference to outer CSS rule.\n   *\n   * The outer rule is the one for enclosing element.\n   * I.e. for the rule with selector is `a b+c` the parent one is `a b`, while the outer one is `a`.\n   *\n   * This is `null` for the root rule and may be `null` for the rule removed from hierarchy.\n   */\n  abstract readonly outer: StypRule | null;\n\n  /**\n   * CSS selector of this rule.\n   */\n  abstract readonly selector: StypSelector.Normalized;\n\n  /**\n   * A key of this rule in the enclosing one.\n   */\n  abstract readonly key: StypRuleKey;\n\n  /**\n   * Whether this rule's properties are empty.\n   *\n   * This is `true` when the rule properties are constant and empty.\n   *\n   * Empty CSS rules returned from `rule()` method when there is no matching rule found.\n   */\n  abstract readonly empty: boolean;\n\n  /**\n   * `AfterEvent` CSS properties receiver registrar.\n   */\n  abstract readonly read: AfterEvent<[StypProperties]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[StypProperties]> {\n    return this.read;\n  }\n\n  /**\n   * Dynamic list of all CSS rules in hierarchy starting from this one.\n   */\n  abstract readonly rules: StypRuleHierarchy;\n\n  /**\n   * Sets CSS properties of this rule.\n   *\n   * @param properties  CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: StypProperties.Spec): this;\n\n  /**\n   * Appends CSS properties to this rule.\n   *\n   * @param properties  CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  add(properties: StypProperties.Spec): this {\n    return this.rules.add([], properties) as this;\n  }\n\n  /**\n   * Clears CSS properties of this rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n  /**\n   * Removes this rule from hierarchy along with all nested rules.\n   *\n   * @param reason  Optional removal reason.\n   *\n   * @returns `this` (just removed) rule instance.\n   */\n  abstract remove(reason?: any): this;\n\n}\n\n/**\n * Dynamically updated list of CSS rules.\n *\n * This is an iterable of rules, an EventSender` of their updates, and an `EventKeeper` of itself.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleList implements StypRules, EventKeeper<[StypRuleList]> {\n\n  /**\n   * An `AfterEvent` registrar of rule list receiver.\n   *\n   * An `[AfterEvent__symbol]` property is just an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[StypRuleList]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[StypRuleList]> {\n    return this.read;\n  }\n\n  /**\n   * An `OnEvent` registrar of list updates receiver.\n   *\n   * The list updates receiver accepts two arguments:\n   * - An array of added rules\n   * - An array of removed rules.\n   *\n   * An `[OnEvent__symbol]` property is just an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n    return this.onUpdate;\n  }\n\n  abstract [Symbol.iterator](): IterableIterator<StypRule>;\n\n  /**\n   * Grabs rules from this list matching the given `query`.\n   *\n   * @param query  CSS rule query to match.\n   *\n   * @returns Dynamic list of rules in this list matching the given query.\n   */\n  abstract grab(query: StypQuery): StypRuleList;\n\n}\n\n/**\n * Dynamic list of all CSS rules in hierarchy starting from its root.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleHierarchy extends StypRuleList {\n\n  /**\n   * Dynamic list containing only root CSS rule.\n   *\n   * This list never changes actually.\n   */\n  abstract readonly self: StypRuleList;\n\n  /**\n   * Dynamic list of all CSS rules directly nested within the root one.\n   */\n  abstract readonly nested: StypRuleList;\n\n  /**\n   * Appends CSS properties to nested rule.\n   *\n   * Creates target rule if necessary.\n   *\n   * @param selector  Target rule selector.\n   * @param properties  Optional CSS properties specifier.\n   *\n   * @returns Modified CSS rule.\n   */\n  abstract add(selector: StypSelector, properties?: StypProperties.Spec): StypRule;\n\n  /**\n   * Returns nested CSS rule matching the given `selector`.\n   *\n   * @param selector  Target rule selector.\n   *\n   * @returns Either matching CSS rule, or `undefined` if not found.\n   */\n  abstract get(selector: StypSelector): StypRule | undefined;\n\n  /**\n   * Watches for CSS rule properties.\n   *\n   * The properties are empty when the watched rule does not exist.\n   *\n   * @param selector  CSS selector of watched rule.\n   *\n   * @returns An `AfterEvent` registrar of CSS properties receiver.\n   */\n  abstract watch(selector: StypSelector): AfterEvent<[StypProperties]>;\n\n}\n","import { filterIt, itsIterable } from 'a-iterable';\nimport { asis, valueProvider, valuesProvider } from 'call-thru';\nimport { AfterEvent, afterSupplied, OnEvent, onEventBy, onSupplied } from 'fun-events';\nimport { stypQuery, StypQuery, stypSelectorMatches } from '../selector';\nimport { StypRule, StypRuleList } from './rule';\nimport { StypRules } from './rules';\n\n/**\n * @internal\n */\nexport class Rules extends StypRuleList {\n\n  readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n  readonly read: AfterEvent<[Rules]>;\n  readonly [Symbol.iterator]: () => IterableIterator<StypRule>;\n\n  constructor(list: StypRules, ruleMatches?: (rule: StypRule) => boolean) {\n    super();\n\n    let buildList: () => Iterable<StypRule>;\n    let filterArray: (rules: StypRule[]) => StypRule[];\n\n    if (ruleMatches) {\n      buildList = () => filterIt(list, ruleMatches);\n      filterArray = rules => rules.filter(ruleMatches);\n    } else {\n      buildList = () => list;\n      filterArray = asis;\n    }\n\n    let ruleSet: Set<StypRule> | undefined; // `undefined` updates are not tracked\n\n    this.onUpdate = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n      const rules = ruleSet || (ruleSet = new Set(buildList()));\n\n      onSupplied(list)({\n        supply: receiver.supply.whenOff(() => ruleSet = undefined),\n        receive(context, added, removed) {\n          added = filterArray(added);\n          removed = filterArray(removed);\n          if (removed.length || added.length) {\n            removed.forEach(rule => rules.delete(rule));\n            added.forEach(rule => rules.add(rule));\n            receiver.receive(context, added, removed);\n          }\n        },\n      });\n    }).share();\n\n    this.read = afterSupplied<[Rules]>(this.onUpdate.thru(valueProvider(this)), valuesProvider(this));\n\n    this[Symbol.iterator] = () => {\n      if (ruleSet) {\n        // List changes are tracked.\n        return ruleSet.values();\n      }\n      // List changes are not currently tracked.\n      // Request the rules explicitly.\n      return itsIterable(buildList());\n    };\n\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function grabRules(list: StypRuleList, query: StypQuery): StypRuleList {\n\n  const q = stypQuery(query);\n\n  return new Rules(list, rule => stypSelectorMatches(rule.selector, q));\n}\n","import { itsIterable } from 'a-iterable';\nimport { valueProvider, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  OnEvent__symbol,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { StypQuery, StypRuleKey, stypSelector, StypSelector } from '../selector';\nimport { stypRuleKeyText } from '../selector/selector-text.impl';\nimport { stypOuterSelector, stypRuleKeyAndTail } from '../selector/selector.impl';\nimport { StypProperties } from './properties';\nimport { mergeStypProperties, noStypPropertiesSpec, stypPropertiesBySpec } from './properties.impl';\nimport { StypRule as StypRule_, StypRuleHierarchy, StypRuleList } from './rule';\nimport { StypRules } from './rules';\nimport { grabRules, Rules } from './rules.impl';\n\nclass AllRules extends StypRuleHierarchy {\n\n  private readonly _updates = new EventEmitter<[StypRule[], StypRule[]]>();\n  readonly self: StypRuleList;\n  readonly read: AfterEvent<[AllRules]>;\n\n  get onUpdate() {\n    return this._updates.on;\n  }\n\n  constructor(private readonly _root: StypRule, readonly nested: NestedRules) {\n    super();\n    this.self = selfRuleList(_root, this);\n    this.read = afterSupplied<[AllRules]>(this._updates.on.thru(valueProvider(this)), valuesProvider(this));\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return iterateAllRules(this._root);\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  add(selector: StypSelector, properties?: StypProperties.Spec): StypRule {\n    return extendRule(this._root, stypSelector(selector), properties, true);\n  }\n\n  get(selector: StypSelector): StypRule | undefined {\n    return this._get(stypSelector(selector));\n  }\n\n  private _get(selector: StypSelector.Normalized): StypRule | undefined {\n\n    const [key, tail] = stypRuleKeyAndTail(selector);\n\n    if (!tail) {\n      return this._root;\n    }\n\n    const found = this.nested._rule(stypRuleKeyText(key));\n\n    if (!found) {\n      return;\n    }\n\n    return found.rules.get(tail);\n  }\n\n  watch(selector: StypSelector): AfterEvent<[StypProperties]> {\n\n    const request = stypSelector(selector);\n\n    return afterEventBy<[StypProperties]>(receiver => {\n\n      const tracker = trackValue<StypProperties>({});\n      const propertiesSupply = this.read.consume(() => {\n\n        const found = this._get(request);\n\n        return found && found\n            .read(properties => tracker.it = properties)\n            .whenOff(() => tracker.it = {});\n      });\n\n      const supply = tracker.read(receiver);\n\n      propertiesSupply.needs(supply);\n\n      return supply;\n    }).share();\n  }\n\n  _add(rule: StypRule, sendUpdate: boolean) {\n    rule.rules.onUpdate((added, removed) => this._updates.send(added, removed));\n    if (sendUpdate) {\n      this._updates.send(allRules(rule), []);\n    }\n  }\n\n  _remove(reason?: any) {\n\n    const removed = allRules(this._root);\n\n    this._updates.send([], removed);\n    removed.forEach(rule => {\n      rule.rules._updates.done(reason);\n      rule._spec.done(reason);\n    });\n  }\n\n}\n\nfunction selfRuleList(rule: StypRule, all: AllRules): StypRuleList {\n\n  const onUpdate = new EventEmitter<[StypRule[], StypRule[]]>();\n  const rules = [rule];\n\n  all.onUpdate((_added, removed) => {\n    if (removed[0] === rule) {\n      rules.length = 0;\n      onUpdate.send([], [rule]);\n    }\n  }).whenOff(reason => onUpdate.done(reason));\n\n  class Self implements StypRules {\n\n    get [OnEvent__symbol]() {\n      return onUpdate.on;\n    }\n\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return itsIterable(rules);\n    }\n\n  }\n\n  return new Rules(new Self());\n}\n\nfunction allRules(rule: StypRule): StypRule[] {\n  return [...iterateAllRules(rule)];\n}\n\nfunction *iterateAllRules(rule: StypRule): IterableIterator<StypRule> {\n  yield rule;\n  for (const nested of rule.rules.nested) {\n    yield *allRules(nested);\n  }\n}\n\nclass NestedRules extends StypRuleList {\n\n  readonly _all: AllRules;\n  readonly read: AfterEvent<[NestedRules]>;\n  private readonly _updates = new EventEmitter<[StypRule[], StypRule[]]>();\n  private readonly _byKey = new Map<string, StypRule>();\n\n  get onUpdate() {\n    return this._updates.on;\n  }\n\n  constructor(root: StypRule) {\n    super();\n    this._all = new AllRules(root, this);\n    this.read = afterSupplied<[NestedRules]>(this._updates.on.thru(valueProvider(this)), valuesProvider(this));\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return this._byKey.values();\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  _rule(key: string): StypRule | undefined {\n    return this._byKey.get(key);\n  }\n\n  _add(key: string, rule: StypRule, sendUpdate: boolean) {\n    this._byKey.set(key, rule);\n    rule.rules.onUpdate((_added, removed) => {\n      if (removed[0] === rule) {\n        this._byKey.delete(key);\n        this._updates.send([], [rule]);\n      }\n    });\n    if (sendUpdate) {\n      this._updates.send([rule], []);\n    }\n    this._all._add(rule, sendUpdate);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class StypRule extends StypRule_ {\n\n  private readonly _root: StypRule;\n  private _outer?: StypRule | null;\n  private readonly _selector: StypSelector.Normalized;\n  private readonly _key: StypRuleKey;\n  readonly _spec: ValueTracker<StypProperties.Builder>;\n  private readonly _read: AfterEvent<[StypProperties]>;\n  private readonly _nested: NestedRules;\n\n  get root(): StypRule {\n    return this._root;\n  }\n\n  get outer(): StypRule | null {\n    if (this._outer !== undefined) {\n      return this._outer;\n    }\n\n    const outerSelector = stypOuterSelector(this.selector);\n\n    return this._outer = outerSelector && this.root.rules.get(outerSelector) || null;\n  }\n\n  get selector(): StypSelector.Normalized {\n    return this._selector;\n  }\n\n  get key(): StypRuleKey {\n    return this._key;\n  }\n\n  get empty() {\n    return this._spec.it === noStypPropertiesSpec;\n  }\n\n  get read(): AfterEvent<[StypProperties]> {\n    return this._read;\n  }\n\n  get rules(): AllRules {\n    return this._nested._all;\n  }\n\n  constructor(\n      root: StypRule | undefined,\n      selector: StypSelector.Normalized,\n      key: StypRuleKey,\n      spec: StypProperties.Builder = noStypPropertiesSpec) {\n    super();\n    this._root = root || this;\n    this._selector = selector;\n    this._key = key;\n    this._spec = trackValue(spec);\n    this._read = this._spec.read.keep.dig(builder => builder(this));\n    this._nested = new NestedRules(this);\n  }\n\n  set(properties?: StypProperties.Spec): this {\n    this._spec.it = properties ? r => stypPropertiesBySpec(r, properties) : noStypPropertiesSpec;\n    return this;\n  }\n\n  remove(reason?: any) {\n    this.rules._remove(reason);\n    return this;\n  }\n\n}\n\nfunction extendRule(\n    rule: StypRule,\n    targetSelector: StypSelector.Normalized,\n    properties: StypProperties.Spec | undefined,\n    sendUpdate: boolean): StypRule {\n\n  const [key, tail] = stypRuleKeyAndTail(targetSelector);\n\n  if (!tail) {\n    // Target rule\n    rule._spec.it = extendSpec(rule, properties);\n    return rule;\n  }\n\n  const keyText = stypRuleKeyText(key);\n  const found = rule.rules.nested._rule(keyText);\n\n  if (found) {\n    return extendRule(found, tail, properties, sendUpdate);\n  }\n\n  const newNested = new StypRule(rule.root, [...rule.selector, ...key], key);\n  const result = extendRule(newNested, tail, properties, false); // Send only a top-level update\n\n  rule.rules.nested._add(keyText, newNested, sendUpdate);\n\n  return result;\n}\n\nfunction extendSpec(rule: StypRule, properties: StypProperties.Spec | undefined): StypProperties.Builder {\n\n  const oldSpec = rule._spec.it;\n\n  if (!properties) {\n    return oldSpec;\n  }\n\n  if (rule.empty) {\n    return r => stypPropertiesBySpec(r, properties);\n  }\n\n  return r => mergeStypProperties(oldSpec(r), stypPropertiesBySpec(r, properties));\n}\n","/**\n * @module style-producer\n */\nimport { StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { stypPropertiesBySpec } from './properties.impl';\nimport { StypRule } from './rule';\nimport { StypRule as StypRule_ } from './rule.impl';\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * Constructs root CSS rule representing global CSS declarations.\n *\n * All other rules are nested within single root.\n *\n * The root CSS rule selector is empty.\n *\n * @category CSS Rule\n * @param properties  Initial CSS rule properties specifier.\n *\n * @returns New root CSS rule.\n */\nexport function stypRoot(properties?: StypProperties.Spec): StypRule {\n  return new StypRule_(undefined, rootSelector, [], properties ? r => stypPropertiesBySpec(r, properties) : undefined);\n}\n","/**\n * @module style-producer\n */\nimport { valueProvider } from 'call-thru';\nimport { afterAll, AfterEvent, AfterEvent__symbol, afterThe, EventKeeper, isEventKeeper } from 'fun-events';\nimport { StypSelector } from '../selector';\nimport { StypMapper } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * A type safe reference to CSS rule.\n *\n * Allows to access an modify CSS properties of the rule in a type safe manner.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties structure of referenced rule.\n */\nexport abstract class StypRuleRef<T extends StypProperties<T>> implements EventKeeper<[T]> {\n\n  /**\n   * `AfterEvent` CSS properties receiver registrar.\n   */\n  abstract readonly read: AfterEvent<[T]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * Sets CSS properties of the referenced rule.\n   *\n   * @param properties  CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Appends CSS properties to the references CSS rule.\n   *\n   * @param properties  CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract add(properties: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Clears CSS properties of the referenced rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n}\n\n/**\n * CSS rule referrer.\n *\n * This is a function that obtains CSS rule reference relative to the given root.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties interface of referenced rule.\n */\nexport type RefStypRule<T extends StypProperties<T>> =\n/**\n * @param root  Root CSS rule the constructed reference will be relative to.\n *\n * @returns CSS rule reference.\n */\n    (this: void, root: StypRule) => StypRuleRef<T>;\n\n/**\n * @category CSS Rule\n */\nexport const RefStypRule = {\n\n  /**\n   * Constructs a CSS rule referrer that maps original CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam T  CSS properties structure of referenced rule.\n   * @param selector  CSS selector of target rule.\n   * @param mappings  Either a mappings of CSS properties, an event keeper sending such mappings, or a function\n   * returning one of them and accepting a root CSS rule as its only argument.\n   * The constructed reference will be relative to as its only parameter.\n   *\n   * @returns New CSS rule key instance.\n   */\n  by<T extends StypProperties<T>>(\n      selector: StypSelector,\n      mappings:\n          | StypMapper.Mappings<T>\n          | EventKeeper<[StypMapper.Mappings<T>]>\n          | ((this: void, root: StypRule) => StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>)\n  ): RefStypRule<T> {\n\n    let createMappings: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>;\n\n    if (typeof mappings === 'function') {\n      createMappings = root => mappingsKeeper(mappings(root));\n    } else {\n      createMappings = valueProvider(mappingsKeeper(mappings));\n    }\n\n    return ref;\n\n    function ref(root: StypRule): StypRuleRef<T> {\n\n      const read = afterAll({\n        ms: createMappings(root),\n        ps: root.rules.watch(selector),\n      }).keep.thru(\n          ({\n             ms: [_mappings],\n             ps: [_properties],\n           }) => StypMapper.map(_mappings, _properties)\n      );\n\n      class Ref extends StypRuleRef<T> {\n\n        // noinspection JSMethodCanBeStatic\n        get read() {\n          return read;\n        }\n\n        add(properties: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n          root.rules.add(selector, properties);\n          return this;\n        }\n\n        set(properties?: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n          root.rules.add(selector).set(properties);\n          return this;\n        }\n\n      }\n\n      return new Ref();\n    }\n  },\n\n};\n\nfunction mappingsKeeper<T extends StypProperties<T>>(\n    mappings: StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>):\n    EventKeeper<[StypMapper.Mappings<T>]> {\n  return isEventKeeper(mappings) ? mappings : afterThe(mappings);\n}\n","/**\n * @module style-producer\n */\nimport { afterAll, AfterEvent, AfterEvent__symbol, EventKeeper } from 'fun-events';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\nimport { RefStypRule, StypRuleRef } from './rule-ref';\n\n/**\n * Named CSS rule references complying to the CSS properties structure.\n *\n * Implements an event keeper interface by sending named CSS properties structures for each CSS rule reference.\n *\n * @category CSS Rule\n * @typeparam R  A type of target map of named CSS properties structures.\n */\nexport class StypRuleRefs<R extends StypRuleRefs.Struct<R>> implements EventKeeper<[R]> {\n\n  private _read?: AfterEvent<[R]>;\n\n  /**\n   * CSS rule references by name.\n   *\n   * Each property in this map is a CSS rule reference corresponding to the same named property in properties structure.\n   * I.e. it has the same name and the same properties structure of referenced rule.\n   */\n  readonly refs: { readonly [K in keyof R]: StypRuleRef<R[K]> };\n\n  /**\n   * Constructs named CSS rules by resolving CSS rule referrers.\n   *\n   * @typeparam R  A type of target map of named CSS properties structures.\n   * @param referrers  Named CSS rule referrers to resolve.\n   * @param root  A root CSS rule the references will be relative to.\n   *\n   * @returns New names CSS rules instance.\n   */\n  static by<R extends StypRuleRefs.Struct<R>>(\n      referrers: { readonly [K in keyof R]: RefStypRule<R[K]> },\n      root: StypRule): StypRuleRefs<R>;\n\n  static by<R extends StypRuleRefs.Struct<R>>(\n      referrers: { readonly [name: string]: RefStypRule<any> },\n      root: StypRule): StypRuleRefs<R> {\n\n    const refs: { [K in keyof R]?: StypRuleRef<any> } = {};\n\n    for (const key of Object.keys(referrers)) {\n      refs[key as keyof R] = referrers[key](root) as StypRuleRef<any>;\n    }\n\n    return new StypRuleRefs<R>(refs as { [K in keyof R]: StypRuleRef<R[K]> });\n  }\n\n  /**\n   * Constructs named CSS rules.\n   *\n   * @param refs  A map of named CSS rule references.\n   */\n  constructor(refs: { readonly [K in keyof R]: StypRuleRef<R[K]> }) {\n    this.refs = refs;\n  }\n\n  /**\n   * An `AfterEvent` registrar of the receivers of named CSS properties structures for each CSS rule reference.\n   */\n  get read(): AfterEvent<[R]> {\n    if (this._read) {\n      return this._read;\n    }\n\n    const fromAll: AfterEvent<[{ [K in keyof R]: [StypProperties<any>] }]> = afterAll(this.refs);\n\n    return this._read = fromAll.keep.thru(flattenProperties) as AfterEvent<[R]>;\n  }\n\n  get [AfterEvent__symbol](): AfterEvent<[R]> {\n    return this.read;\n  }\n\n}\n\nfunction flattenProperties<R extends StypRuleRefs.Struct<R>>(\n    propertiesMap: { readonly [name: string]: [StypProperties<any>] }): R {\n\n  const result: { [name: string]: StypProperties<any> } = {};\n\n  for (const name of Object.keys(propertiesMap)) {\n    result[name] = propertiesMap[name][0];\n  }\n\n  return result as R;\n}\n\nexport namespace StypRuleRefs {\n\n  /**\n   * A map of named CSS properties structures.\n   *\n   * Each property in this map corresponds to CSS rule reference with the same CSS properties structure.\n   */\n  export type Struct<R = { readonly [name: string]: StypProperties<any> }> = {\n    readonly [K in keyof R]: StypProperties<any>;\n  };\n\n  /**\n   * A map of named CSS rule referrers.\n   *\n   * These referrers then resolved to the same named CSS rule references.\n   *\n   * @typeparam R  A type of target map of named CSS properties structures.\n   */\n  export type Referrers<R extends Struct<R>> = {\n    readonly [K in keyof R]: RefStypRule<R[K]>;\n  };\n\n}\n","/**\n * @module style-producer\n */\nimport { itsEach } from 'a-iterable';\nimport {\n  EventNotifier,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  isEventSender,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  onEventBy, onNever,\n  onSupplied,\n} from 'fun-events';\nimport { StypRule, StypRuleList } from './rule';\nimport { Rules } from './rules.impl';\n\n/**\n * Dynamically updated CSS rule set.\n *\n * This is an iterable of rules, and an `EventSender` of their updates.\n *\n * @category CSS Rule\n */\nexport interface StypRules extends Iterable<StypRule>, EventSender<[StypRule[], StypRule[]]> {\n\n  [Symbol.iterator](): IterableIterator<StypRule>;\n\n}\n\nexport namespace StypRules {\n\n  /**\n   * A source of CSS rules.\n   *\n   * A dynamically updated CSS rule set can be constructed out of one or more sources by [[stypRules]] and\n   * [[lazyStypRules]] functions.\n   *\n   * This can be one of:\n   * - Single `StypRule` instance.\n   *   A `StypRule.rules.self` is used instead. I.e. a list containing only the rule itself.\n   * - A `StypRules` instance.\n   *   It is used as is.\n   * - A promise of one of the above.\n   *   The resolved value is used as an actual source.\n   *   No rules are available until resolution.\n   * - A function returning one of the above.\n   *   The function call result is used as an actual source.\n   *   The function will be called lazily upon rules access.\n   */\n  export type Source =\n      | StypRule\n      | StypRules\n      | Promise<StypRule | StypRules>\n      | ((this: void) => StypRule | StypRules | Promise<StypRule | StypRules>);\n\n}\n\nconst noStypRules: StypRuleList = /*#__PURE__*/ new Rules({\n  [OnEvent__symbol]: onNever,\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return [][Symbol.iterator]();\n  },\n});\n\n/**\n * Constructs dynamically updated CSS rule list out of rule sources.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function stypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(rulesFromSource)) : noStypRules;\n}\n\nfunction rulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? evalRules(source) : rulesByValue(source);\n}\n\n/**\n * Constructs lazily updated CSS rule list out of rule sources.\n *\n * In contrast to [[stypRules]] this one does not evaluate sources (e.g. does not call source functions) until there\n * is an updates receiver registered.\n *\n * This means that the constructed rule set won't necessary contain the rules from all sources originally. It will\n * report them as updates instead.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function lazyStypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(lazyRulesFromSource)) : noStypRules;\n}\n\nfunction lazyRulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? lazyRules(source) : rulesByValue(source);\n}\n\nfunction rulesByList(sources: StypRules[]): StypRuleList {\n  if (sources.length === 1) {\n\n    const source = sources[0];\n\n    return source instanceof StypRuleList ? source : new Rules(source);\n  }\n  return new Rules({\n    * [Symbol.iterator](): IterableIterator<StypRule> {\n      for (const rules of sources) {\n        yield* rules;\n      }\n    },\n    get [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n      return onEventBy<[StypRule[], StypRule[]]>(receiver => {\n        sources.forEach(source => onSupplied(source)({\n          supply: eventSupply().needs(receiver.supply),\n          receive(context, added, removed) {\n            receiver.receive(context, added, removed);\n          }\n        }));\n      }).share();\n    },\n  });\n}\n\nfunction evalRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  let _rules: StypRules | undefined;\n\n  return {\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return rules()[Symbol.iterator]();\n    },\n    get [OnEvent__symbol]() {\n      return rules()[OnEvent__symbol];\n    }\n  };\n\n  function rules(): StypRules {\n    return _rules || (_rules = rulesByValue(source()));\n  }\n}\n\nfunction lazyRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy(receiver => {\n\n    const rules = rulesByValue(source());\n\n    reportExistingRules(rules, ruleSet, receiver);\n    rules[OnEvent__symbol]({\n      supply: receiver.supply.whenOff(() => ruleSet.clear()),\n      receive(context, added, removed) {\n        removed.forEach(rule => ruleSet.delete(rule));\n        added.forEach(rule => ruleSet.add(rule));\n        receiver.receive(context, added, removed);\n      },\n    });\n  }).share();\n\n  return {\n    [OnEvent__symbol]: onEvent,\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\nfunction rulesByValue(source: StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n  return source instanceof StypRule ? source.rules.self : isEventSender(source) ? source : asyncRules(source);\n}\n\nfunction asyncRules(source: Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    let sourceSupply = noEventSupply();\n    const { supply } = receiver;\n\n    supply.whenOff(reason => {\n      sourceSupply.off(reason);\n      ruleSet.clear();\n    });\n\n    source.then(resolution => {\n      if (!supply.isOff) {\n\n        const rules = resolution instanceof StypRule ? resolution.rules : resolution;\n\n        reportExistingRules(rules, ruleSet, receiver);\n\n        sourceSupply = onSupplied(rules)({\n          receive(context, added, removed) {\n            removed.forEach(rule => ruleSet.delete(rule));\n            added.forEach(rule => ruleSet.add(rule));\n            receiver.receive(context, added, removed);\n          }\n        }).needs(supply);\n      }\n    });\n  }).share();\n\n  return {\n    [OnEvent__symbol]: onEvent,\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\nfunction reportExistingRules(\n    rules: StypRules,\n    ruleSet: Set<StypRule>,\n    receiver: EventReceiver.Generic<[StypRule[], StypRule[]]>,\n) {\n\n  const existing: StypRule[] = [];\n\n  itsEach(rules, rule => {\n    existing.push(rule);\n    ruleSet.add(rule);\n  });\n  if (existing.length) {\n\n    const dispatcher = new EventNotifier<[StypRule[], StypRule[]]>();\n\n    dispatcher.on(receiver);\n    dispatcher.send(existing, []); // Report existing rules as just added\n  }\n}\n","/**\n * @module input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeparam Instance  Aspect instance type.\n * @typeparam Kind  Aspect application kind.\n */\nexport interface InAspect<Instance, Kind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeparam Value  Input value type.\n   * @param control  Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Instance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = /*#__PURE__*/ Symbol('in-aspect');\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   */\n  export interface Key<Instance, Kind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<Instance, Kind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam ConvertedInstance  A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<Instance, ConvertedInstance extends Instance = Instance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: Instance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by `InControl.convert()` method.\n     *\n     * @typeparam To  Converted input value type.\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<To>(target: InControl<To>): Applied<ConvertedInstance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Result<OfInstance, OfValue, OfKind extends Kind> =\n        Applied<Instance<OfInstance, OfValue, OfKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Instance<OfInstance, OfValue, OfKind extends Kind> =\n        ReturnType<Map<OfInstance, OfValue>[OfKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     */\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): OfInstance;\n\n    }\n\n  }\n\n}\n","import { noop } from 'call-thru';\nimport { InAspect } from './aspect';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectValue<Instance>(instance: Instance): InAspect.Applied<Instance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @module input-aspects\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InControl<Value> extends ValueTracker<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: Value;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n  ): InAspect.Application.Instance<Instance, Value, Kind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup  A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to set up.\n   * @param setup  A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<Instance, Value, Kind>, control: this) => void,\n  ): this;\n\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<Instance, Kind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<Instance, Value, Kind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one with value of different type.\n   *\n   * The converted control's value bound to this one and wise versa.\n   *\n   * @typeparam To  Converted input value type.\n   * @param set  Value conversion function accepting this control's value an returning converted one.\n   * @param get  Reverse value conversion function accepting converted value and returning this control's one.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(\n      set: (this: void, value: Value) => To,\n      get: (this: void, value: To) => Value,\n  ): InControl<To>;\n\n  /**\n   * Converts this control to another one with value of different type potentially depending on various input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control converter.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(by: InControl.Converter<Value, To>): InControl<To>;\n\n  convert<To>(\n      setOrBy: ((this: void, value: Value) => To) | InControl.Converter<Value, To>,\n      get?: (this: void, value: To) => Value,\n  ): InControl<To> {\n\n    let by: InControl.Converter<Value, To>;\n\n    if (!get) {\n      by = setOrBy as InControl.Converter<Value, To>;\n    } else {\n      by = valueProvider({ set: setOrBy as (value: Value) => To, get });\n    }\n\n    return new InConverted(this, by);\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>\n  ): InAspect.Application.Result<Instance, Value, Kind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<Instance, Value, Kind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<Instance, Value, Kind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param _aspect  An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      _aspect: InAspect<Instance, Kind>\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return;\n  }\n\n}\n\nfunction isAspectKey<Instance, Kind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<Instance, Kind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * Input control converter.\n   *\n   * It is a function called by `InControl.convert()` method to construct value converters.\n   *\n   * This function should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Converter<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns A tuple containing value conversion function and reverse value conversion function.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => Converters<From, To>;\n\n  /**\n   * Value converters.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Converters<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    readonly applyAspect?: <Instance, Kind extends InAspect.Application.Kind>(\n        this: this,\n        aspect: InAspect<Instance, Kind>\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(this: void, value: From): To;\n\n    /**\n     * Restores an original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(this: void, value: To): From;\n\n  }\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeparam Control  Input control type.\n   */\n  export type ValueType<Control extends InControl<any>> = Control extends InControl<infer Value> ? Value : never;\n\n}\n\nclass InConverted<From, To> extends InControl<To> {\n\n  readonly on: OnEvent<[To, To]>;\n  private readonly _it: ValueTracker<[To, number]>;\n  protected readonly _applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<Instance, Kind>\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  constructor(\n      src: InControl<From>,\n      by: InControl.Converter<From, To>,\n  ) {\n    super();\n\n    let lastRev = 0;\n    let backward: From | undefined;\n\n    const on = new EventEmitter<[To, To]>();\n\n    this.on = on.on;\n\n    const converters = by(src, this);\n    const { applyAspect } = converters;\n\n    this._applyAspect = applyAspect\n        ? function<Instance, Kind extends InAspect.Application.Kind>(\n            this: InConverted<From, To>,\n            aspect: InAspect<Instance, Kind>,\n        ) {\n          return (\n              applyAspect.call(converters, aspect) || convertAspect.call(this, aspect)\n          ) as InAspect.Application.Result<Instance, To, Kind> | undefined;\n        }\n        : convertAspect;\n\n    this._it = trackValue([converters.set(src.it), 0]);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        on.send(newValue, oldValue);\n      }\n    }).whenOff(reason => on.done(reason));\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [converters.set(value), ++lastRev];\n      }\n    }).whenOff(reason => this.done(reason));\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = converters.get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n\n    function convertAspect<Instance, Kind extends InAspect.Application.Kind>(\n        this: InConverted<From, To>,\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined {\n\n      const applied: InAspect.Applied<any, any> = src._aspect(aspect);\n\n      return applied.convertTo<Instance>(this as any) as InAspect.Application.Result<Instance, To, Kind> | undefined;\n    }\n  }\n\n  get it(): To {\n    return this._it.it[0];\n  }\n\n  set it(value: To) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  done(reason?: any): this {\n    this._it.done(reason);\n    return this;\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventSender, OnEvent, OnEvent__symbol } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectNull, inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\n\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo() {\n    return inAspectNull;\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as aspect of itself.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InContainer<Value> extends InControl<Value> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectValue(this) as InAspect.Application.Result<Instance, Value, Kind>\n        : undefined;\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   *\n   * @typeparam L  Input container layout interface.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * An `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InContainer.Snapshot]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read;\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InContainer } from './container.control';\n\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(): InAspect.Applied<InParents> {\n    return inAspectValue(new InControlParents());\n  }\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InParents.All]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read;\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry  Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): EventSupply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\nclass InControlParents extends InParents {\n\n  private readonly _map = new Map<InParents.Entry, EventSupply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n  readonly read: AfterEvent<[InParents.All]>;\n\n  constructor() {\n    super();\n\n    const map = this._map;\n\n    this.read = afterEventBy(\n        this._on.on.thru(\n            allParents,\n        ),\n        () => [allParents()]);\n\n    function allParents(): IterableIterator<InParents.Entry> {\n      return map.keys();\n    }\n  }\n\n  get on() {\n    return this._on.on;\n  }\n\n  add(entry: InParents.Entry): EventSupply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = eventSupply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply;\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { AfterEvent, DomEventDispatcher } from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectNull, inAspectValue } from './aspect.impl';\nimport { InControl } from './control';\n\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo() {\n    return inAspectNull;\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls. It is not available as aspect of other controls.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport abstract class InElement<Value, Elt = HTMLElement> extends InControl<Value> {\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: Elt;\n\n  /**\n   * An `AfterEvent` keeper of user input.\n   */\n  abstract readonly input: AfterEvent<[InElement.Input<Value>]>;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InElement__aspect as InAspect<any, any>\n        ? inAspectValue(this) as InAspect.Application.Result<Instance, Value, Kind>\n        : undefined;\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Input<Value> {\n\n    /**\n     * The value user entered.\n     */\n    value: Value;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { nextArgs, nextSkip, valuesProvider } from 'call-thru';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InParents } from '../container/parents.aspect';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<InMode> {\n    return inAspectValue(new InControlMode(control));\n  }\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of input mode updates. Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n\n  get [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InMode.Value]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read;\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode  Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source  A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: EventKeeper<[InMode.Value]>): EventSupply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason  Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.done(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n}\n\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element?: InElement<any>) {\n    super();\n    this._tracker = trackValue(element ? initialMode(element.element) : 'on');\n  }\n\n  get on() {\n    return this._tracker.on;\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n      case 'off':\n      case 'ro':\n      case '-on':\n      case '-ro':\n        break;\n      default:\n        value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  done(reason?: any): this {\n    this._tracker.done(reason);\n    return this;\n  }\n\n}\n\nclass DerivedModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterEventBy(\n        this._on.on.thru(() => this._all),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.keep.dig(set => afterEach(...set).keep.thru(mergeModes));\n  }\n\n  add(source: EventKeeper<[InMode.Value]>): EventSupply {\n\n    const src = afterSupplied(source);\n    const supply = eventSupply(() => {\n      this._all.delete(src);\n      this._on.send();\n    });\n\n    this._all.add(src);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  readonly read: AfterEvent<[InMode.Value]>;\n  readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n  private readonly _derived = new DerivedModes();\n\n  constructor(control: InControl<any>) {\n    super();\n\n    const element = control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    this.derive(control.aspect(InParents).read.keep.dig_(parentsMode));\n\n    let last: InMode.Value = 'on';\n\n    this.read = afterEventBy<[InMode.Value]>(\n        afterAll({\n          derived: this._derived.read,\n          own: this.own,\n        }).thru(({ derived: [derived], own: [own] }) => {\n\n          let next: InMode.Value;\n\n          if (own === 'off' || derived === 'off') {\n            next = 'off';\n          } else {\n\n            let off = false;\n\n            if (own[0] === '-') {\n              off = true;\n              own = own.substring(1) as InMode.Value;\n            }\n            if (derived[0] === '-') {\n              off = true;\n              derived = derived.substring(1) as InMode.Value;\n            }\n            next = derived === 'ro' ? 'ro' : own;\n            if (off) {\n              next = '-' + next as InMode.Value;\n            }\n          }\n\n          return last === next ? nextSkip() : nextArgs(last = next);\n        }),\n        valuesProvider<[InMode.Value]>(last),\n    );\n    if (element) {\n      this.read(value => applyMode(element.element, value));\n    }\n\n    let lastUpdate: InMode.Value = 'on';\n\n    this.on = this.read.thru(value => {\n\n      const old = lastUpdate;\n\n      return old === value ? nextSkip() : nextArgs(lastUpdate = value, old);\n    });\n  }\n\n  derive(source: EventKeeper<[InMode.Value]>): EventSupply {\n    return this._derived.add(source);\n  }\n\n}\n\nfunction initialMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off' : (\n          element.getAttribute('readonly') != null ? 'ro' : 'on'\n      );\n}\n\nfunction applyMode(element: HTMLElement, value: InMode.Value) {\n  switch (value) {\n    case 'off':\n      element.setAttribute('disabled', '');\n      break;\n    case 'ro':\n    case '-ro':\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      element.setAttribute('readonly', '');\n      break;\n    default:\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('readonly', '');\n      element.removeAttribute('readonly');\n  }\n}\n\nfunction parentsMode(parents: InParents.All): AfterEvent<[InMode.Value]> {\n\n  const parentList = [...parents];\n\n  if (!parentList.length) {\n    return afterThe('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return afterEach(...parentModes).keep.thru_(mergeModes);\n}\n\nfunction mergeModes(...modes: [InMode.Value][]) {\n\n  let ro = false;\n  let off = false;\n\n  for (const [mode] of modes) {\n    switch (mode) {\n      case 'off':\n        return 'off';\n      case 'ro':\n        ro = true;\n        break;\n      case '-on':\n        off = true;\n        break;\n      case '-ro':\n        off = true;\n        ro = true;\n        break;\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @module input-aspects\n */\nimport { NextArgs, nextArgs, noop } from 'call-thru';\nimport { afterAll, AfterEvent } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport type InData<Value> = AfterEvent<[InData.DataType<Value>?]>;\n\nconst InData__symbol: Aspect = {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n\n    const instance: InData<Value> = afterAll({\n      value: control,\n      mode: control.aspect(InMode),\n    }).keep.thru(\n        ({ value: [value], mode: [mode] }) => dataByValue(value, mode),\n    );\n\n    return {\n      instance,\n      convertTo: noop,\n    };\n  }\n\n};\n\nfunction dataByValue<Value, NextReturn>(\n    value: Value,\n    mode: InMode.Value,\n): NextArgs<[InData.DataType<Value>?], NextReturn> {\n  return InMode.hasData(mode) ? nextArgs(value as InData.DataType<Value>) : nextArgs();\n}\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<InData<Value>, InData<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__symbol;\n  }\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeparam Value  Input value type.\n   */\n  export type DataType<Value> =\n      | (Value extends object ? { [K in keyof Value]?: DataType<Value[K]> } : Value)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { itsEach, itsIterable, mapIt, overEntries } from 'a-iterable';\nimport { nextArgs, noop } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterThe,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroup<Model extends object> extends InContainer<Model> {\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<Model>;\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Controls<Model> = {\n    readonly [K in keyof Model]?: InControl<Model[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Entry<Model, K extends keyof Model = any> = readonly [K, InControl<Model[K]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export interface Snapshot<Model> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<Model>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key  Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<Model>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>, EventKeeper<[InGroup.Snapshot<Model>]> {\n\n  abstract readonly on: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  abstract readonly read: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @param key  A key of input control to set. I.e. corresponding model property key.\n   * @param control  Input control to add, or `undefined` to remove control.\n   *\n   * @returns `this` controls instance.\n   */\n  abstract set<K extends keyof Model>(key: K, control: InControl<Model[K]> | undefined): this;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls  A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns `this` controls instance.\n   */\n  abstract set(controls: InGroup.Controls<Model>): this;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key  A key of input control to remove. I.e. corresponding model property key.\n   *\n   * @returns `this` controls instance.\n   */\n  remove(key: keyof Model): this {\n    return this.set(key, undefined);\n  }\n\n}\n\nexport interface InGroupControls<Model> {\n\n  readonly [OnEvent__symbol]: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  readonly [AfterEvent__symbol]: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n}\n\ntype ControlEntry = readonly [InControl<any>, EventSupply]; // When event supply is done the control is unused\n\nconst controlReplacedReason = {};\n\nclass InGroupSnapshot<Model> implements InGroup.Snapshot<Model> {\n\n  constructor(private readonly _map: Map<keyof Model, ControlEntry>) {\n  }\n\n  get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<Model>[K];\n  }\n\n  [Symbol.iterator](): IterableIterator<InControl<any>> {\n    return itsIterable(mapIt(this._map.values(), ([control]) => control));\n  }\n\n  entries(): IterableIterator<InGroup.Entry<Model>> {\n    return itsIterable(mapIt(this._map.entries(), ([key, [control]]) => [key, control]));\n  }\n\n}\n\nclass InGroupMap<Model extends object> {\n\n  readonly _supply = eventSupply();\n  private _map = new Map<keyof Model, ControlEntry>();\n  private _shot?: InGroupSnapshot<Model>;\n\n  constructor(private readonly _controls: InGroupControlControls<Model>) {\n  }\n\n  set<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]> | undefined,\n      added: [keyof Model, ControlEntry][],\n      removed: [keyof Model, ControlEntry][],\n  ) {\n\n    const self = this;\n    const replaced = this._map.get(key);\n\n    if (control) {\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not replace control with itself\n          return;\n        }\n        removed.push([key, replaced]);\n      }\n\n      const entry: ControlEntry = [control, eventSupply(reason => {\n        if (reason !== controlReplacedReason) {\n          self._controls.remove(key);\n        }\n      }).needs(self._supply)];\n\n      modify().set(key, entry);\n      added.push([key, entry]);\n    } else if (replaced) {\n      removed.push([key, replaced]);\n      modify().delete(key);\n    }\n    if (replaced) {\n      replaced[1].off(controlReplacedReason);\n    }\n\n    function modify(): Map<keyof Model, ControlEntry> {\n      if (self._shot) {\n\n        const map = new Map<keyof Model, ControlEntry>();\n\n        itsEach(self._map.entries(), ([k, e]) => map.set(k, e));\n        self._shot = undefined;\n        self._map = map;\n      }\n\n      return self._map;\n    }\n  }\n\n  snapshot(): InGroup.Snapshot<Model> {\n    return this._shot || (this._shot = new InGroupSnapshot<Model>(this._map));\n  }\n\n}\n\nclass InGroupControlControls<Model extends object> extends InGroupControls<Model> {\n\n  private readonly _map: InGroupMap<Model>;\n  private readonly _updates = new EventEmitter<[[keyof Model, ControlEntry][], [keyof Model, ControlEntry][]]>();\n  readonly on: OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  readonly read: AfterEvent<[InGroup.Snapshot<Model>]>;\n\n  constructor(private readonly _group: InGroupControl<Model>) {\n    super();\n\n    const self = this;\n\n    this._map = new InGroupMap<Model>(this);\n    this.on = this._updates.on.thru(\n        (added, removed) => nextArgs(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry)),\n    );\n    this.read = afterEventBy(\n        this._updates.on.thru(\n            () => this._map.snapshot(),\n        ),\n        () => [this._map.snapshot()]);\n    this._map._supply.needs(_group.read(applyModelToControls));\n\n    function applyModelToControls(model: Model) {\n      self.read.once(snapshot => {\n\n        const withValues = new Set<keyof Model>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    }\n  }\n\n  set<K extends keyof Model>(\n      keyOrControls: K | InGroup.Controls<Model>,\n      newControl?: InControl<Model[K]> | undefined): this {\n\n    const group = this._group;\n    const added: [keyof Model, ControlEntry][] = [];\n    const removed: [keyof Model, ControlEntry][] = [];\n\n    if (typeof keyOrControls === 'object') {\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed);\n      });\n    } else {\n      this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return this;\n\n    function applyControlsToModel() {\n\n      let newModel: Model | undefined;\n\n      added.forEach(([key, [control, supply]]) => {\n        supply.needs(control.aspect(InParents).add({ parent: group }).needs(supply));\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(([key, [control, supply]]) => {\n        supply.needs(control.read(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).needs(supply));\n      });\n    }\n  }\n\n}\n\nfunction controlEntryToGroupEntry<Model extends object>(\n    [key, [control]]: [keyof Model, ControlEntry],\n): InGroup.Entry<Model> {\n  return [key, control];\n}\n\nclass InGroupControl<Model extends object> extends InGroup<Model> {\n\n  private readonly _model: ValueTracker<Model>;\n  readonly controls: InGroupControlControls<Model>;\n\n  constructor(model: Model) {\n    super();\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n  }\n\n  get on() {\n    return this._model.on;\n  }\n\n  get it() {\n    return this._model.it;\n  }\n\n  set it(value: Model) {\n    this._model.it = value;\n  }\n\n  done(reason?: any): this {\n    this._model.done(reason);\n    return this;\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    if (aspect as InAspect<any> === InData[InAspect__symbol]) {\n      return {\n        instance: groupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\nfunction groupData<Model extends object>(group: InGroup<Model>): InData<Model> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).keep.dig_(\n      readGroupData,\n  );\n}\n\nfunction readGroupData<Model extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<Model>];\n      model: [Model];\n      mode: [InMode.Value];\n    }\n): InData<Model> {\n  if (!InMode.hasData(mode)) {\n    return afterThe();\n  }\n\n  const csData: { [key in keyof Model]: InData<any> } = {} as any;\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof Model] = control.aspect(InData);\n  });\n\n  return afterAll(csData).keep.thru(controlsData => {\n\n    const data: Partial<Model> = { ...model };\n\n    itsEach(overEntries(controlsData), ([key, [controlData]]) => {\n      data[key] = controlData;\n    });\n\n    return data as InData.DataType<Model>;\n  });\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n * @param model  Initial model of the group.\n *\n * @returns New input controls group.\n */\nexport function inGroup<Model extends object>(model: Model): InGroup<Model> {\n  return new InGroupControl(model);\n}\n","/**\n * @module input-aspects\n */\nimport { AfterEvent, afterThe } from 'fun-events';\n\nconst _requireNothing: AfterEvent<[]> = /*#__PURE__*/ afterThe<[]>();\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return _requireNothing;\n}\n","/**\n * @module input-aspects\n */\nimport { nextArgs, NextArgs, valueProvider } from 'call-thru';\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n */\nexport type InValidator<Value> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<Value>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<Value>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Simple<Value> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control  Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<Value>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n * @param validator  Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<Value>(\n    validator: InValidator<Value>\n): (this: void, control: InControl<Value>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n  return control => control.read.keep.thru(simpleValidator(control, validator));\n}\n\nfunction simpleValidator<Value>(\n    control: InControl<Value>,\n    validator: InValidator.Simple<Value>,\n): <NextReturn>(value: Value) => NextArgs<InValidation.Message[], NextReturn> | InValidation.Message {\n  return () => {\n\n    const messages = validator.validate(control);\n\n    return messages == null\n        ? nextArgs()\n        : Array.isArray(messages)\n            ? nextArgs(...messages)\n            : messages;\n  };\n}\n","import { flatMapIt, itsEach } from 'a-iterable';\nimport { asis, noop, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSupply,\n  eventSupply,\n} from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<Value> implements EventKeeper<InValidation.Message[]> {\n\n  readonly [AfterEvent__symbol]: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<Value>) => EventSupply;\n\n  constructor(control: InControl<Value>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, EventSupply>();\n    const validatorMessages = new Map<InValidator<Value>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => void = noop;\n\n    this[AfterEvent__symbol] = afterEventBy(receiver => {\n\n      // A validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => {\n\n        const supply = validator(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).share();\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = eventSupply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply;\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values(), asis);\n    }\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { flatMapIt, itsEach, mapIt, overEntries } from 'a-iterable';\nimport { asis, nextArgs } from 'call-thru';\nimport { afterEach, AfterEvent, AfterEvent__symbol, afterSupplied, EventKeeper, EventSupply } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InContainer } from '../container';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\nconst InValidation__aspect: Aspect = {\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n\n    const instance = new InControlValidation(control);\n\n    return {\n      instance,\n      convertTo<To>(target: InControl<To>) {\n        return convert(instance, target);\n      },\n    };\n\n    function convert<To>(\n        from: InControlValidation<any>,\n        to: InControl<To>,\n    ): Applied<To> {\n\n      const converted = new InControlValidation<To>(to);\n\n      converted.by(from._messages);\n\n      return {\n        instance: converted,\n        convertTo<CC>(target: InControl<CC>) {\n          return convert<CC>(converted, target);\n        },\n      };\n    }\n  },\n};\n\n/**\n * Input validation aspect.\n */\ninterface Aspect extends InAspect<InValidation<any>, 'validation'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input validation aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<InValidation<Value>, InValidation<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To>;\n\n}\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InValidation<Value> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  get [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InValidation.Result]>;\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators  Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<Value>[]): EventSupply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export interface Message {\n\n    [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code  Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code  Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\nconst noValidationErrors: InValidation.Result = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  [Symbol.iterator]() {\n    return [][Symbol.iterator]();\n  },\n};\n\nclass InValidationErrors implements InValidation.Result {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    itsEach(\n        messages,\n        message => {\n\n          let nonEmpty = false;\n\n          itsEach(overEntries(message), ([code, codePresent]) => {\n            if (codePresent) {\n              nonEmpty = true;\n\n              const prev = this._byCode.get(code as string);\n\n              if (prev) {\n                prev.push(message);\n              } else {\n                this._byCode.set(code as string, [message]);\n              }\n            }\n          });\n\n          if (nonEmpty) {\n            this._all.push(message);\n          }\n        }\n    );\n  }\n\n  get ok() {\n    return !this._all.length;\n  }\n\n  messages(code?: string) {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string) {\n    return code == null || this._byCode.has(code);\n  }\n\n  [Symbol.iterator]() {\n    return this._all[Symbol.iterator]();\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages  Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noValidationErrors;\n}\n\nclass InControlValidation<Value> extends InValidation<Value> {\n\n  readonly _messages: InValidationMessages<Value>;\n  readonly read: AfterEvent<[InValidation.Result]>;\n\n  constructor(control: InControl<Value>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    const container = control.aspect(InContainer);\n\n    if (container) {\n      this._messages.from(nestedMessages(container));\n    }\n\n    this.read = afterSupplied(this._messages).keep.thru(inValidationResult);\n  }\n\n  by(...validators: InValidator<Value>[]): EventSupply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n}\n\nfunction nestedMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read.keep.dig_(\n      nestedValidations\n  ).keep.thru(\n      combineValidationResults,\n  );\n}\n\nfunction nestedValidations(controls: InContainer.Snapshot) {\n  return afterEach(...mapIt(controls, control => control.aspect(InValidation)));\n}\n\nfunction combineValidationResults<NextReturn>(...[messages]: [InValidation.Result][]) {\n\n  const msg: Iterable<InValidation.Message> = flatMapIt(messages, asis);\n\n  return nextArgs<InValidation.Message[], NextReturn>(...msg);\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @param validators  Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<Value>(...validators: InValidator<Value>[]): InValidator<Value> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<Value>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { EventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control ? control.read.keep.thru(value => value ? nextArgs() : { missing: 'missing' }) : requirePresent;\n}\n","import { asis, nextArgs, nextSkip } from 'call-thru';\nimport {\n  AfterEvent,\n  afterSupplied,\n  DomEventDispatcher,\n  EventEmitter,\n  eventSupply,\n  EventSupply,\n  OnEvent,\n} from 'fun-events';\nimport { InElement } from '../element.control';\n\nexport class InElementControl<Value, Elt extends HTMLElement> extends InElement<Value, Elt> {\n\n  readonly input: AfterEvent<[InElement.Input<Value>]>;\n  readonly on: OnEvent<[Value, Value]>;\n  readonly events: DomEventDispatcher;\n  private readonly _get: (this: InElementControl<Value, Elt>) => Value;\n  private readonly _set: (this: InElementControl<Value, Elt>, value: Value) => void;\n  private readonly _input: EventEmitter<[InElement.Input<Value>, Value]> = new EventEmitter();\n  private readonly _supply: EventSupply;\n  private _value: Value;\n  // noinspection TypeScriptFieldCanBeMadeReadonly\n  private _update: (value: Value, oldValue: Value) => void;\n\n  constructor(\n      readonly element: Elt,\n      {\n        get,\n        set,\n      }: {\n        get: (this: InElementControl<Value, Elt>) => Value;\n        set: (this: InElementControl<Value, Elt>, value: Value) => void;\n      }) {\n    super();\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n    this._update = update;\n    this.input = afterSupplied<[InElement.Input<Value>]>(\n        this._input.on.thru(asis),\n        () => [{ value: this.it }]);\n    this.on = this._input.on.thru(\n        ({ value: newValue }, oldValue) => newValue === oldValue ? nextSkip() : nextArgs(newValue, oldValue),\n    );\n\n    this.events = new DomEventDispatcher(element);\n\n    const self = this;\n    const supply = this._supply = eventSupply(reason => this._input.done(reason));\n\n    this.events.on('input')(onInput).needs(supply);\n    this.events.on('change')(onInput).needs(supply);\n\n    function onInput(event: Event) {\n      send({ value: self.it, event }, self._value);\n    }\n\n    function update(value: Value, oldValue: Value) {\n      send({ value }, oldValue);\n    }\n\n    function send(input: InElement.Input<Value>, oldValue: Value) {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<Value>, Value] | undefined;\n\n        // Record corrections\n        self._update = (newValue: Value, old: Value) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = update;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get it(): Value {\n    return this._get();\n  }\n\n  set it(value: Value) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  done(reason?: any): this {\n    this._supply.off(reason);\n    return this;\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { InElement } from '../element.control';\nimport { InElementControl } from './element.impl';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element  Target text input element.\n *\n * @return New textual input control instance.\n */\nexport function inText(element: InText.Element): InText {\n  return new InElementControl(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n      },\n  );\n}\n","/**\n * @module input-aspects\n */\nimport { EventEmitter, ValueTracker } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectNull, inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<InFocus | null> {\n\n    const element = control.aspect(InElement);\n\n    if (!element) {\n      return inAspectNull;\n    }\n\n    return inAspectValue(new InControlFocus(element));\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when [[InElement]] aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\nclass InControlFocus extends InFocus {\n\n  private readonly _on = new EventEmitter<[boolean, boolean]>();\n\n  constructor(private readonly _element: InElement<any>) {\n    super();\n\n    const events = _element.events;\n\n    events.on('focus')(() => this._on.send(true, false));\n    events.on('blur')(() => this._on.send(false, true));\n  }\n\n  get on() {\n    return this._on.on;\n  }\n\n  get it(): boolean {\n\n    const element = this._element.element;\n    const owner: DocumentOrShadowRoot | null =\n        element.getRootNode ? element.getRootNode() as any : element.ownerDocument;\n\n    return !!owner && owner.activeElement === element;\n  }\n\n  set it(value: boolean) {\n    if (this.it !== value) {\n\n      const element = this._element.element;\n\n      if (value) {\n        element.focus();\n      } else {\n        element.blur();\n      }\n    }\n  }\n\n  done(reason?: any): this {\n    this._on.done(reason);\n    return this;\n  }\n\n}\n","/**\n * @module input-aspects\n */\nimport { itsEach, mapIt } from 'a-iterable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InContainer } from '../container';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\nimport { InFocus } from './focus.aspect';\n\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<InStatus> {\n\n    const container = control.aspect(InContainer);\n\n    return inAspectValue(container ? new InContainerStatus(container) : new InControlStatus(control));\n  }\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InStatus.Flags]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched  Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited  Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\nconst defaultFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultFlags);\n\n  get read() {\n    return this._flags.read;\n  }\n\n  constructor(control: InControl<any>) {\n    super();\n    this._flags.by(elementFlags(this._flags, control));\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\nfunction elementFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input.keep.thru(({ event }) => !!event) : afterThe(false),\n  }).keep.thru(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateFlags(origin.it, hasFocus, edited),\n  );\n}\n\nfunction updateFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\nclass InContainerStatus extends InStatus {\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n\n    this.read = containerFlags(_container);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read.once(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markEdited(edited)),\n    );\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read.once(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markTouched(touched)),\n    );\n    return this;\n  }\n\n}\n\nfunction containerFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read.keep.dig_(\n      snapshot => afterEach(...controlStatuses(snapshot)),\n  ).keep.thru(\n      combineFlags,\n  );\n}\n\nfunction controlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\nfunction combineFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      )\n  );\n\n  return result;\n}\n","/**\n * @module input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectNull, inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * An input aspect representing HTML element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = HTMLElement;\n\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull;\n  }\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  }\n\n};\n","/**\n * @module input-aspects\n */\nimport { filterIt, itsEach, mapIt, overEntries } from 'a-iterable';\nimport { noop, valueProvider } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterThe,\n  EventKeeper,\n  eventSupply,\n  EventSupply,\n  isEventKeeper,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InStyledElement } from './styled-element.aspect';\n\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  }\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of CSS classes applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InCssClasses.Map]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read;\n  }\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source  A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): EventSupply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled element.\n   *\n   * @param reason  An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for input control.\n   *\n   * This is either an event keeper of CSS class names map, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InCssClasses.Map]>\n      | ((control: InControl<any>) => EventKeeper<[InCssClasses.Map]>);\n\n  /**\n   * A map CSS class names to apply to styled element.\n   *\n   * The keys of this map are class names tpo apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export interface Map {\n    readonly [name: string]: boolean | undefined;\n  }\n\n}\n\nconst UnsubscribeReason__symbol = /*#__PURE__*/ Symbol('reason');\n\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\nclass InControlCssClasses extends InCssClasses {\n\n  readonly read: AfterEvent<[InCssClasses.Map]>;\n  private readonly _sources: ValueTracker<[Map<AfterEvent<[InCssClasses.Map]>, EventSupply>]> =\n      trackValue([new Map()]);\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    this.read = this._sources.read.keep.dig_(\n        ([sources]) => sources.size ? afterEach(...sources.keys()) : afterThe()\n    ).keep.thru((...classes) => {\n\n      const result: { [name: string]: boolean | undefined } = {};\n\n      classes.forEach(([map]) => {\n        itsEach(\n            overEntries(map),\n            ([name, flag]) => {\n              if (flag != null) {\n                result[name] = flag;\n              }\n            }\n        );\n      });\n\n      return result;\n    });\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n\n      const { classList } = element;\n      const applied = new Set<string>();\n\n      this.read(map => {\n\n        const toRemove = new Set<string>(applied);\n        const toAdd = new Set<string>(\n            mapIt(\n                filterIt(\n                    overEntries(map),\n                    ([name, flag]) => !!flag && !toRemove.delete(name as string)\n                ),\n                ([name]) => name as string\n            )\n        );\n\n        toRemove.forEach(name => {\n          classList.remove(name);\n          applied.delete(name);\n        });\n        toAdd.forEach(name => {\n          classList.add(name);\n          applied.add(name);\n        });\n      });\n    }\n  }\n\n  add(source: InCssClasses.Source): EventSupply {\n\n    const keeper = inCssClassesSource(source)(this._control);\n    const classesSupply = eventSupply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = keeper[AfterEvent__symbol]({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).share();\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply;\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.done(reason);\n    return this;\n  }\n\n}\n\nfunction inCssClassesSource(source: InCssClasses.Source): (control: InControl<any>) => EventKeeper<[InCssClasses.Map]> {\n  if (isEventKeeper(source)) {\n    return valueProvider(source);\n  }\n  return source;\n}\n","/**\n * @module input-aspects\n */\nimport { afterAll } from 'fun-events';\nimport { InControl } from '../control';\nimport { InMode } from '../data';\nimport { InStatus } from '../focus';\nimport { InValidation } from '../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * A source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * @category Style\n * @param prefix  Optional prefix to add to generated class names. `inas-` by default.\n * @param suffix  Optional suffix to add to generated class names.\n */\nexport function inCssInfo(\n    {\n      prefix = 'inap-',\n      suffix = '',\n    }: {\n      prefix?: string,\n      suffix?: string,\n    } = {}\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).keep.thru(\n        ({ md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          return {\n            [cls('disabled')]: !InMode.hasData(mode),\n            [cls('readonly')]: mode === 'ro' || mode === '-ro',\n            [cls('invalid')]: !valid.ok,\n            [cls('missing')]: valid.has('missing'),\n            [cls('incomplete')]: valid.has('incomplete'),\n            [cls('has-focus')]: hasFocus,\n            [cls('touched')]: touched,\n            [cls('edited')]: edited,\n          } as InCssClasses.Map;\n        },\n    );\n  };\n\n  function cls(name: string): string {\n    return `${prefix}${name}${suffix}`;\n  }\n}\n"],"names":["NextCall__symbol","Symbol","NextCall_lastOutcome__symbol","NextCall","Function","[object Object]","target","value","is","nextCall","callee","firstArg","arg","callNext","lastOutcome","result","PassedThru__symbol","PassedThru","outcome","iterator","callThru","fns","args","get","idx","prev","len","length","apply","this","call","asis","noop","isPresent","valueProvider","valuesProvider","values","nextArgs","undefined","nextEach","items","item","forEachItem","lastItems","SKIP","_skip","_nextSkip","nextSkip","isArrayLike","itsRevertible","iterable","itsIterator","itsIterable","makeIt","iterate","reverse","reversible","reverseIt","source","reverseArray","reversed","array","i","itsEach","action","element","itsFirst","next","itsReduction","reducer","initialValue","reduced","thruIt","it","thru","filterIt","test","flatMapIt","convert","mapIt","API_METHODS","AIterable","NONE","every","name","from","make","itsEvery","elements","None","super","overArray","overKeys","Reflect","ownKeys","overEntries","keys","mapToEntries","_keys","key","AfterEvent__symbol","isEventKeeper","EventSupply","another","whenOff","reason","off","eventSupply","cutOff","callback","isOff","NoSupply","noSupply","noEventSupply","eventReceiver","receiver","generic","supply","_context","event","context","receive","OnEvent__symbol","isEventSender","EventNotifier","Set","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","push","processEvent","shift","receiveEventsByEach","_rcvs","size","on","add","delete","forEach","recurrentReceivers","recurrentReceiver","recurrentEvent","OnEvent","extract","shareSupplyTo","dig_","onEventBy","nestedSupply","prevSupply","extracted","onSupplied","needs","nestedEvent","consume","consumerSupply","senderSupply","thru_","transformed","register","onEvent","Object","setPrototypeOf","prototype","supplier","bind","onNever","shared","sharedSupply","initialEvents","removeReceiver","dispatcher","AfterEventKeep","keeper","_keeper","share","afterSupplied","AfterEvent","keep","afterEventBy","fallback","noEvent","lastEvent","numReceivers","afterEvent","dest","sender","afterSent","afterThe","afterNever","Error","OnDomEvent","capture","onDomEventBy","listener","opts","instead","preventDefault","just","stopPropagation","last","stopImmediatePropagation","passive","onDomEvent","domEventContext","onRecurrent","DomEventDispatcher","_target","type","domListener","addEventListener","removeEventListener","dispatchEvent","EventEmitter","afterAll","sources","notifier","once","afterEach","index","onAny","suppliers","remained","removeSupplier","statePath","path","Array","isArray","PathEntry","_drop","Map","emitter","newValue","oldValue","nested","_nested","slice","entry","_dropIfEmpty","dontCreateMissing","found","created","_remove","set","done","Trackers","_entry","_root","nest","SubStateTracker","_trackers","_path","_tracker","onUpdate","StateTracker","update","subTracker","track","ValueTracker","valueReceiver","recurrentValue","receiveNewValue","read","self","byNone","container","_by","acceptValuesFrom","TrackedValue","_it","_on","trackValue","initial","ValueSync","old","first","second","third","syncWithTracker","tracker","syncTrackers","extractTracker","tracker1","tracker2","supply1","supply2","ContextKey__symbol","ContextKey","ContextSeedKey","seedKey","seeder","seed","isEmpty","byDefault","ContextKeyError","message","contextValueSpec","spec","byProvider","withDeps","a","by","with","deps","map","dep","isConstant","viaAlias","via","ctx","asInstance","selfInstance","as","toAsInstance","TypeError","ContextValues","ContextRegistry","_initial","_seeding","provide","_seeds","seeding","factory","cache","newValues","_nonCachedValues","registry","Values","cached","constructed","defaultUsed","findSeed","valueOpts","or","defaultProvider","defaultValue","grow","growValue","other","combine","ContextUpSeeder","provider","_providers","providers","indexOf","concat","providersTracker","dig","prov","toUpSrcKeeper","flatUpSources","upSrcKeepers","src","isUpSrcKeeper","ContextSeedUpKey","ContextUpKey","FnContextKey","delegated","SimpleContextSeeder","splice","sourceValues","flatMap","SimpleSeedKey","SimpleContextKey","SingleContextKey","itsLast","MultiContextKey","defaultSources","filter","Naming","nsAlias","local","ns","DefaultNaming","alias","default__naming","html__naming","id__naming","css__naming","NamespaceDef","url","aliases","naming","applyAlias","_alias","isQualifiedName","isNameAndNamespace","compareNames","compareStrings","firstName","firstUrl","newNamespaceAliaser","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","hthvItem","$","n","t","v","x","p","pl","addParam","param","nextInItem","config","input","c","s","d","delimiterOf","datePattern","parseDateTime","out","substring","match","parseNone","itemParser","named","tagged","extra","parseQuotedString","unquoted","quotedStringParser","parseAngleBrackets","angleBracketsParser","parseExtra","tag","extraItem","nextInComment","spacesParser","start","paramParser","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParserOpts","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","hasOwnProperty","regexAnySingleEscape","regexSingleEscape","regexExcessiveSpaces","cssesc","options","defaults","merge","quotes","isIdentifier","firstChar","charAt","output","counter","character","codePoint","charCodeAt","toString","toUpperCase","escapeEverything","replace","$0","$1","$2","wrap","version","uppercasePattern","msPattern","toHyphenLower","toLowerCase","cssescId","id","IMPORTANT_CSS_SUFFIX","isReadonlyArray","isNotEmptyArray","StypValueStruct","priority","prioritize","stypValuesEqual","StypColorStruct","StypRGB","coords","r","intCoord","g","b","coord","rgb","hsl","max","Math","min","l","round","StypHSL","h","StypColor","q","hueAsFraction","hueToRgb","newT","mixStypColors","color1","color2","weight","w","rgba1","rgba2","aDiff","w1","w2","StypNumericStruct","dim","toFormula","StypMapper","mappings","mapped","mappedValue","mapping","mappingBy","mapper","StypDimension","val","unit","thisDim","pt","noPt","addendum","stypDimension","stypAddSub","subtrahend","multiplier","divisor","zero","StypCalcBase","left","op","right","usual","stypMul","stypDiv","StypAddSub","toDim","negate","StypMulDiv","isStypNumeric","Zero","_byPriority","important","ZeroByPriority","unitlessZeroDimensionKind","dimension","StypDimension_","unitZeroDimensionKind","zeroUnit","withPercent","noPercent","StypAngle","StypAnglePt","StypFrequency","StypFrequencyPt","StypLength","StypLengthPt","noStypProperties","noStypPropertiesSpec","stypPropertiesBySpec","rule","preventDuplicates","propertiesKeeper","senderOrProperties","propertiesMap","properties","stored","propertyEntries","sentry","propertiesEqual","passNonDuplicate","$$css","mergeStypProperties","base","baseProperties","addendumProperties","k","priorityOf","addValue","addValues","endsWith","isCombinator","normalizeStypSelectorPart","part","e","normalizeClasses","normalizeQualifiers","classes","sort","qualifiers","exposeQualifier","qualifier","noQualifiers","eqIdx","exposed","lastExposed","split","noKeyAndTail","stypRuleKeyAndTail","selector","combinator","rootSelector","classesMatch","query","qClass","find","mClass","namesEqual","stypSelector","normalizeKey","normalized","prevCombinator","ruleKeyTextOpts","qualify","stypRuleKeyText","formatStypSelector","defaultFormat","format","reduce","hasProperties","className","xmlNs","qualifyElement","formatItem","stypRenderProperties","producer","cssRule","addRule","style","notCustomProperty","trim","stypSplitPriority","setProperty","hName","hyphenateStyleName","render","String","renderFactory","create","isFactory","order","renderSpec","doRender","compareRenders","firstOrder","secondOrder","produceBasicStyle","rules","document","window","addStyleSheet","addStyleElement","schedule","scheduleInAnimationFrame","parent","head","view","defaultView","factories","addRenders","renders","addRender","has","stypRenderFactories","renderSupply","renderRule","trackSupply","tracked","added","removed","clear","trackRules","styleProducer","production","styleSheet","_selector","ruleIndex","insertRule","stypSelectorText","cssRules","reader","specs","renderAt","nextIndex","nextRender","nextProducer","renderForRule","_sheetRef","_rev","ruleSelector","rev","sheet","deleteRule","clearProperties","sheetRef","remove","operation","requestAnimationFrame","createElement","setAttribute","append","createTextNode","parentElement","removeChild","StypRule","StypRuleList","StypRuleHierarchy","Rules","list","ruleMatches","buildList","filterArray","ruleSet","grabRules","stypQuery","stypSelectorMatches","AllRules","all","_added","selfRuleList","_updates","iterateAllRules","extendRule","targetSelector","sendUpdate","tail","_spec","oldSpec","empty","extendSpec","keyText","_rule","newNested","root","_add","_get","request","propertiesSupply","allRules","NestedRules","_all","_byKey","StypRule_","_key","_read","builder","outer","_outer","outerSelector","stypOuterSelector","stypRoot","StypRuleRef","RefStypRule","createMappings","mappingsKeeper","ms","ps","watch","_mappings","_properties","StypRuleRefs","refs","referrers","fromAll","flattenProperties","noStypRules","stypRules","rulesByList","rulesFromSource","_rules","rulesByValue","evalRules","lazyStypRules","lazyRulesFromSource","reportExistingRules","lazyRules","sourceSupply","then","resolution","asyncRules","existing","InAspect__symbol","inAspectNull","instance","convertTo","inAspectValue","InControl","aspectKey","_aspect","aspectKeyOrSetup","aspectSetup","aspect","setOrBy","InConverted","_aspects","applied","_applyAspect","applyTo","backward","lastRev","converters","applyAspect","convertAspect","prevValue","prevRev","InContainer__aspect","InContainer","InContainerControls","InParents__aspect","InControlParents","InParents","_map","allParents","existingSupply","InElement__aspect","InElement","InMode__aspect","control","InControlMode","InMode","mode","own","OwnModeTracker","getAttribute","initialMode","DerivedModes","mergeModes","derive","parentsMode","derived","_derived","removeAttribute","applyMode","lastUpdate","parents","parentList","modes","ro","InData__symbol","hasData","dataByValue","InData","InGroup","InGroupControls","controlReplacedReason","InGroupSnapshot","entries","InGroupMap","_controls","replaced","_supply","modify","_shot","InGroupControlControls","_group","controlEntryToGroupEntry","snapshot","model","withValues","keyOrControls","newControl","group","newModel","applyControlsToModel","InGroupControl","_model","controls","cs","readGroupData","csData","controlsData","data","controlData","inGroup","_requireNothing","requireNothing","inValidator","validator","messages","validate","simpleValidator","dontRemove","InValidationMessages","validators","validatorMessages","resultSupply","validatorSupply","InValidation__aspect","InControlValidation","to","converted","_messages","InValidation","noValidationErrors","ok","InValidationErrors","nonEmpty","code","codePresent","_byCode","inValidationResult","nestedValidations","combineValidationResults","nestedMessages","numValidators","requireAll","requirePresent","missing","InElementControl","_set","_value","_update","_input","events","onInput","correction","inText","InFocus__aspect","InControlFocus","InFocus","_element","owner","getRootNode","ownerDocument","activeElement","focus","blur","InStatus__aspect","InContainerStatus","InControlStatus","InStatus","defaultFlags","hasFocus","touched","edited","_flags","origin","flags","updateFlags","elementFlags","_container","controlStatuses","combineFlags","markEdited","markTouched","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","_control","_sources","flag","classList","toRemove","toAdd","inCssClassesSource","classesSupply","inCssInfo","prefix","suffix","md","vl","st","valid","cls"],"mappings":"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"}