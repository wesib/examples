{"version":3,"file":"lib.72325879.s.js","sources":["../../node_modules/call-thru/src/next-call.ts","../../node_modules/call-thru/src/misc/value-providers.ts","../../node_modules/fun-events/src/event-supply.ts","../../node_modules/namespace-aliaser/src/naming.ts","../../node_modules/render-scheduler/src/custom-render-scheduler.ts","../../node_modules/delta-set/src/delta-set.ts","../../node_modules/input-aspects/src/converter.ts","../../node_modules/http-header-value/src/parser/add-param.ts","../../node_modules/http-header-value/src/parser/angle-brackets-parser.ts","../../node_modules/cssesc/cssesc.js","../../node_modules/hyphenate-style-name/index.js","../../node_modules/style-producer/src/internal/css.ts"],"sourcesContent":["/**\n * @module call-thru\n */\nimport { CallOutcome } from './call-outcome';\n\n/**\n * A key of a [[NextCall]] method responsible for calling the next function in chain.\n */\nexport const NextCall__symbol = /*#__PURE__*/ Symbol('next-call');\n\n/**\n * A key of a [[NextCall]] method responsible for returning the outcome of the las pass in chain.\n */\nexport const NextCall_lastOutcome__symbol = /*#__PURE__*/ Symbol('next-call:last-outcome');\n\n/**\n * A call of the next function in chain.\n *\n * This is basically a function with additional method, which is treated specially by call chaining functions.\n * When previous function in chain returns a [[NextCall]] instance, it will be used to call the next function in chain.\n * Otherwise the next function will be called with single argument containing a value returned.\n *\n * A [[NextCall]] is a function returning itself. So it can be chained like any other function.\n *\n * A [[nextCall]] function can be used to construct a next call.\n *\n * @typeparam OutKind  A kind of the call outcome.\n * @typeparam NextThis  A type of `this` context object reference of the next function.\n * @typeparam NextArgs  A type of argument tuple of the next function.\n * @typeparam NextReturn  A return type of the next function.\n * @typeparam Out  A type of the next function call outcome.\n * @typeparam Last  A type of the outcome of the next call returned from the last pass in chain.\n */\nexport abstract class NextCall<\n    OutKind extends CallOutcome.Kind,\n    NextArgs extends any[],\n    NextReturn,\n    Out = NextReturn,\n    Last = CallOutcome.OfKind<OutKind, NextArgs[0], Out>> extends Function {\n\n  /**\n   * Checks whether the `target` value is a next function call.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true`.\n   */\n  static is<V extends NextCall.Any>(target: V): target is V;\n\n  /**\n   * Checks whether the `target` value is a next function call.\n   *\n   * @param target  A value to check.\n   *\n   * @returns `true` if the `target` value is a function with a `[NextCall.mark]` property, or `false` otherwise.\n   */\n  static is(target: any): target is NextCall.Any;\n\n  static is(target: any): target is NextCall.Any {\n    return typeof target === 'function' && NextCall__symbol in target;\n  }\n\n  /**\n   * Converts a value returned from previous chained function call to the call of the next function in chain.\n   *\n   * @param nextCall  A next function call to return.\n   *\n   * @returns A `nextCall` itself.\n   */\n  static of<V extends NextCall.Any>(nextCall: V): V;\n\n  /**\n   * Converts a value returned from previous chained function call to the call of the next function in chain.\n   *\n   * @param value  A value to convert.\n   *\n   * @returns Either a `value` itself if it is a next function call, or a new next function call instance that passes\n   * a `value` as the only argument to the callee.\n   */\n  static of<V, Out>(value: V): NextCall<'default', [V], Out, Out, Out>;\n\n  static of<V, NextReturn>(value: V): NextCall<any, NextCall.Callee.Args<V>, NextReturn> {\n    if (NextCall.is(value)) {\n      return value;\n    }\n    return nextCall((callee: any) => callee(value));\n  }\n\n  /**\n   * Calls the next function in chain.\n   *\n   * This is invoked only when there _is_ a next function. When next call is returned by the last pass a\n   * `[NextCall_lastOutcome__symbol]()` is invoked instead.\n   *\n   * @param callee  A function to call.\n   *\n   * @returns A call outcome.\n   */\n  abstract [NextCall__symbol](callee: (this: void, ...args: NextArgs) => NextReturn): Out;\n\n  /**\n   * Builds an outcome of the last pass in chain.\n   *\n   * This is invoked for the last pass in chain only. If there is the next pass, a `[NextCall__symbol]()` is invoked\n   * instead.\n   */\n  abstract [NextCall_lastOutcome__symbol](): Last;\n\n}\n\nexport interface NextCall<\n    OutKind extends CallOutcome.Kind,\n    NextArgs extends any[],\n    NextReturn,\n    Out = NextReturn,\n    Last = CallOutcome.OfKind<OutKind, NextArgs[0], Out>> {\n\n  /**\n   * Returns itself to add it to functions chain.\n   */\n  (): NextCall<OutKind, NextArgs, NextReturn, Out, Last>; // tslint:disable-line:callable-types\n\n}\n\nexport namespace NextCall {\n\n  /**\n   * Any call of the next function.\n   */\n  export type Any = NextCall<any, any, any, any, any>;\n\n  export namespace Callee {\n\n    /**\n     * Arguments tuple type of a callee. Either extracted from [[NextCall]], or consisting of single argument of type\n     * `V`.\n     */\n    export type Args<V> = V extends NextCall<any, infer NextArgs, any, any, any> ? NextArgs : [V];\n\n    /**\n     * A return type of a callee. Either extracted from [[NextCall]], or `V` itself.\n     */\n    export type Return<V> = V extends NextCall<any, any, infer NextReturn, any, any> ? NextReturn : V;\n\n  }\n\n  /**\n   * A type of next call outcome. Either extracted from [[NextCall]], or `Return`.\n   */\n  export type Outcome<V, Return> = V extends NextCall<infer OutKind, any, any, infer Out, any>\n      ? CallOutcome.OfKind<OutKind, Return, Out>\n      : Return;\n\n  /**\n   * A type of last call outcome. Either extracted from the last call, or the value itself.\n   */\n  export type LastOutcome<V> = V extends NextCall<any, any, any, any, infer Last> ? Last : V;\n\n  /**\n   * A type of the result returned from chained function call, except for the last one.\n   *\n   * This may be either a [[NextCall]] instance, or single value.\n   *\n   * In any case the result provides arguments for the next pass in chain and thus should be compatible with next\n   * function signature.\n   *\n   * @typeparam NextArgs  A type of argument tuple of the next function in chain.\n   */\n  export type CallResult<NextArgs extends any[]> =\n      NextArgs extends [infer Result]\n          // Next function expects single argument.\n          // So the previous one may return either a single value, or a [[NextCall]] with compatible argument.\n          ? (Result | NextCall<any, NextArgs, any, any, any>)\n          // Next function expects multiple arguments.\n          // So the previous one should always return a [[NextCall]] instance with compatible arguments.\n          : NextCall<any, NextArgs, any, any, any>;\n\n  /**\n   * A result returned by last function in chain.\n   *\n   * This may be either a [[NextCall]] instance, or single value.\n   *\n   * @typeparam Last  A type of outcome of the last pass in chain.\n   */\n  export type LastResult<Last> =\n      Last | NextCall<any, any, any, any, Last>;\n\n}\n\nconst firstArg: (...args: any[]) => any = (arg: any) => arg;\n\n/**\n * Constructs a call to the next function.\n *\n * @param callNext  A next function caller function.\n * @param lastOutcome  A function building an outcome of the last pass in chain.\n *\n * @returns A next function call performed by the given `callNext` function.\n */\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out, Last>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out,\n    lastOutcome: (this: void) => Last):\n    NextCall<OutKind, NextArgs, NextReturn, Out, Last>;\n\n/**\n * Constructs a call to the next function with default last pass outcome implementation.\n *\n * The last pass outcome is detected by passing to `callNext` a function that just returns its first argument.\n *\n * @param callNext  A next function caller function.\n *\n * @returns A next function call performed by the given `callNext` function.\n */\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out):\n    NextCall<OutKind, NextArgs, NextReturn, Out>;\n\nexport function nextCall<OutKind extends CallOutcome.Kind, NextArgs extends any[], NextReturn, Out, Last>(\n    callNext: (this: void, callee: (this: void, ...args: NextArgs) => NextReturn) => Out,\n    lastOutcome: (this: void) => Last = () => callNext(firstArg) as any):\n    NextCall<OutKind, NextArgs, NextReturn, Out, Last> {\n\n  const result = (() => result) as NextCall<OutKind, NextArgs, NextReturn, Out, Last>;\n\n  result[NextCall__symbol] = callee => callNext(callee);\n  result[NextCall_lastOutcome__symbol] = lastOutcome;\n\n  return result;\n}\n","/**\n * @module call-thru\n */\n/**\n * Creates a provider of the only argument.\n *\n * @param value  A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return () => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return () => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return () => [...values] as T;\n}\n","/**\n * @module fun-events\n */\nimport { noop } from 'call-thru';\n\n/**\n * A supply of events from {@link EventSupplier event supplier} to {@link EventReceiver event receiver}.\n *\n * When no longer needed the supply may be {@link off cut off}.\n *\n * May be constructed using [[eventSupply]] function.\n *\n * @category Core\n */\nexport abstract class EventSupply {\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means the events will no longer be supplied.\n   */\n  abstract readonly isOff: boolean;\n\n  /**\n   * Cuts off the supply of events.\n   *\n   * After this method call the receiver will no longer receive events.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason  An optional reason why supply is cut off. It will be reported to [[whenOff]] callbacks.\n   * @returns A cut off event supply instance.\n   */\n  abstract off(reason?: any): EventSupply;\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if [[isOff]] is `true`.\n   *\n   * @param callback  A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means normal completion.\n   *\n   * @returns `this` instance.\n   */\n  abstract whenOff(callback: (this: void, reason?: any) => void): this;\n\n  /**\n   * Declares this event supply depends on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one is will be cut off with the same reason.\n   *\n   * @param another  An event supply this one depends on.\n   *\n   * @return `this` instance.\n   */\n  needs(another: EventSupply): this {\n    another.whenOff(reason => this.off(reason));\n    return this;\n  }\n\n}\n\n/**\n * Constructs new {@link EventSupply event supply}.\n *\n * @category Core\n * @param off  A function to call when supply will supply is {@link EventSupply.off cut off}. Accepts optional\n * cut off reason as its only parameter. No-op by default.\n */\nexport function eventSupply(off: (this: void, reason?: any) => void = noop): EventSupply {\n\n  let whenOff: (callback: (reason?: any) => void) => void;\n  let cutOff: (reason?: any) => void = reason => {\n    whenOff = callback => callback(reason);\n    cutOff = noop;\n    off(reason);\n  };\n\n  whenOff = callback => {\n\n    const prev = cutOff;\n\n    cutOff = reason => {\n      prev(reason);\n      callback(reason);\n    };\n  };\n\n  class Supply extends EventSupply {\n\n    get isOff() {\n      return cutOff === noop;\n    }\n\n    off(reason?: any): EventSupply {\n      cutOff(reason);\n      return this;\n    }\n\n    whenOff(callback: (reason?: any) => void): this {\n      whenOff(callback);\n      return this;\n    }\n\n  }\n\n  return new Supply();\n}\n\nclass NoSupply extends EventSupply {\n\n  get isOff() {\n    return true;\n  }\n\n  off() {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n}\n\nconst noSupply =\n    /*#__PURE__*/ new NoSupply();\n\n/**\n * Returns a no-event supply.\n *\n * @category Core\n *\n * @returns An event supply that is already cut off without any particular reason.\n */\nexport function noEventSupply(): EventSupply {\n  return noSupply;\n}\n","/**\n * @module namespace-aliaser\n */\nimport { QualifiedName } from './name';\nimport { NamespaceDef } from './namespace';\nimport { NamespaceAliaser } from './namespace-aliaser';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","/**\n * @module render-scheduler\n */\nimport { RenderScheduleConfig } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { ScheduledRender, ScheduledRenderExecution } from './scheduled-render';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to [[customRenderScheduler]] function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config  Render schedule configuration.\n   *\n   * @returns  Scheduled render queue.\n   */\n  newQueue(config: RenderScheduleConfig): ScheduledRenderQueue;\n}\n\n/**\n * A queue of scheduled renders.\n *\n * Utilized by render scheduler in order to collect scheduled renders and schedule their execution.\n *\n * The default implementation may constructed using [[ScheduledRenderQueue.by]] function.\n */\nexport interface ScheduledRenderQueue {\n\n  /**\n   * Adds a render to this queue.\n   *\n   * @param render  Scheduled render to add.\n   */\n  add(render: ScheduledRender): void;\n\n  /**\n   * Retrieves the first added render and removes it from the queue.\n   *\n   * @returns  Either pulled out scheduled render, or `undefined` when there is no more renders.\n   */\n  pull(): ScheduledRender | undefined;\n\n  /**\n   * Schedules queued renders execution.\n   *\n   * @param task  A function that performs scheduled renders execution task.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled renders from now on.\n   */\n  reset(): ScheduledRenderQueue;\n\n}\n\nexport const ScheduledRenderQueue = {\n\n  /**\n   * Builds the default implementation of scheduled renders queue.\n   *\n   * @param schedule  Schedules queued renders execution. This is an implementation of\n   * [[ScheduledRenderQueue.schedule]] method.\n   * @param replace  Called right after [[ScheduledRenderQueue.reset]] method in order to inform on queue that will\n   * collect scheduled renders from now.\n   *\n   * @returns New scheduled render queue.\n   */\n  by(\n      this: void,\n      {\n        schedule,\n        replace = () => {},\n      }: {\n        schedule(this: ScheduledRenderQueue, task: (this: void) => void): void;\n        replace?(this: void, replacement: ScheduledRenderQueue): void;\n      },\n  ): ScheduledRenderQueue {\n\n    const renders: ScheduledRender[] = [];\n\n    return {\n      schedule,\n      add(render) {\n        renders.push(render);\n      },\n      pull() {\n        return renders.shift();\n      },\n      reset() {\n\n        const next = ScheduledRenderQueue.by({ schedule, replace });\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n\n/**\n * @internal\n */\nconst ScheduledRenderQ__symbol = Symbol('scheduled-render-q');\n\n/**\n * @internal\n */\nclass ScheduledRenderQ {\n\n  readonly ref: [ScheduledRenderQ];\n  schedule: (this: ScheduledRenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n\n  static by(queue: ScheduledRenderQueue, ref?: [ScheduledRenderQ]): ScheduledRenderQ {\n    return (queue as any)[ScheduledRenderQ__symbol]\n        || ((queue as any)[ScheduledRenderQ__symbol] = new ScheduledRenderQ(queue, ref));\n  }\n\n  private constructor(private readonly q: ScheduledRenderQueue, ref?: [ScheduledRenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this];\n  }\n\n  add(render: ScheduledRender) {\n    this.q.add(render);\n  }\n\n  private doSchedule(config: RenderScheduleConfig) {\n    this.schedule = () => {};\n\n    const execution: ScheduledRenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone: (postponed) => {\n        this.add(postponed);\n      },\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n\n      next.suspend();\n      this.exec(execution);\n      next.resume();\n    });\n  }\n\n  private exec(execution: ScheduledRenderExecution) {\n    for (; ;) {\n\n      const render = this.q.pull();\n\n      if (!render) {\n        break;\n      }\n      try {\n        render(execution);\n      } catch (e) {\n        execution.config.error(e);\n      }\n    }\n  }\n\n  private reset(): ScheduledRenderQ {\n    return this.ref[0] = ScheduledRenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend() {\n    this.schedule = config => {\n      this.scheduled = config;\n      this.schedule = () => {};\n    };\n  }\n\n  private resume() {\n    if (this.scheduled) {\n      this.doSchedule(this.scheduled);\n    } else {\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options  Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return scheduleOptions => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef = ScheduledRenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [ScheduledRenderQ, ScheduledRender] | [] = [];\n\n    return render => {\n\n      const [lastQueue] = enqueued;\n      const [nextQueue] = queueRef;\n\n      if (lastQueue === nextQueue) {\n        enqueued[1] = render;\n      } else {\n\n        const nextEnqueued = enqueued = [nextQueue, render];\n\n        nextQueue.add((execution: ScheduledRenderExecution) => nextEnqueued[1](execution));\n      }\n\n      nextQueue.schedule(config);\n    };\n  };\n}\n","/**\n * @module delta-set\n */\n/**\n * A `Set` implementation that keeps a delta of changes made to it.\n *\n * @typeparam T  A type of elements of delta set.\n */\nexport class DeltaSet<T> extends Set<T> {\n\n  /** @internal */\n  private readonly _added: Set<T>;\n\n  /** @internal */\n  private readonly _removed: Set<T>;\n\n  /**\n   * Constructs new delta set.\n   *\n   * @param values  An iterable of elements be add to constructed delta set. Or `null` to add nothing.\n   */\n  constructor(values?: Iterable<T> | null) {\n    super();\n    this._added = new Set<T>(values);\n    this._removed = new Set<T>();\n    this._added.forEach(value => this.add(value));\n  }\n\n  /**\n   * Appends a new element with a specified value to the end of this delta set. Unless the set contains this element\n   * already.\n   *\n   * Records element addition and forgets its removal unless the set contains it already.\n   *\n   * @param value  The value of the element to add.\n   *\n   * @returns `this` delta set.\n   */\n  add(value: T): this {\n    if (!this.has(value)) {\n      this._added.add(value);\n      this._removed.delete(value);\n      super.add(value);\n    }\n    return this;\n  }\n\n  /**\n   * Removes the specified element from this delta set.\n   *\n   * Records element removal and forgets its addition if removal succeed.\n   *\n   * @param value  The value of the element to remove.\n   *\n   * @returns `true` if element removed successfully; or `false` if this set did not contain the element.\n   */\n  delete(value: T): boolean {\n    if (super.delete(value)) {\n      this._added.delete(value);\n      this._removed.add(value);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all elements from this delta set.\n   *\n   * Records all elements removal and forgets all elements additions.\n   */\n  clear(): void {\n    this._added.clear();\n    this.forEach(value => this._removed.add(value));\n    super.clear();\n  }\n\n  /**\n   * Applies changes to this delta set.\n   *\n   * First removes elements to `remove`. Then appends elements to `add`.\n   *\n   * Records all changes made.\n   *\n   * @param add  An iterable of elements to add.\n   * @param remove  An iterable of elements to remove.\n   *\n   * @returns `this` delta set.\n   */\n  delta(add: Iterable<T>, remove: Iterable<T> = []): this {\n    deltaSetDeltaReceiver(this)(add, remove);\n    return this;\n  }\n\n  /**\n   * Replays changes made to this set in target receiver.\n   *\n   * @param receiver  A receiver of changes delta. E.g. another `Set`.\n   *\n   * @returns `this` delta set.\n   */\n  redelta(receiver: DeltaSet.DeltaReceiver<T>): this {\n\n    const receive = typeof receiver === 'function' ? receiver : deltaSetDeltaReceiver(receiver);\n\n    receive([...this._added], [...this._removed]);\n\n    return this;\n  }\n\n  /**\n   * Forgets all changes made to this set.\n   *\n   * Does not alter the set contents.\n   *\n   * @returns `this` delta set.\n   */\n  undelta(): this {\n    this._added.clear();\n    this._removed.clear();\n    return this;\n  }\n\n}\n\nexport namespace DeltaSet {\n\n  /**\n   * A delta set changes receiver.\n   *\n   * This can be either an {@link DeltaReceiverObject object}, or a {@link DeltaReceiverFunction function}.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiver<T> =\n      | DeltaReceiverFunction<T>\n      | DeltaReceiverObject<T>;\n\n  /**\n   * A delta set changes receiver function.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiverFunction<T> =\n  /**\n   * @param added  An array of added elements.\n   * @param removed  An array of removed elements.\n   */\n      (this: void, added: T[], remove: T[]) => void;\n\n  /**\n   * A delta set changes receiver object.\n   *\n   * A `Set` class implements this interface.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export interface DeltaReceiverObject<T> {\n\n    /**\n     * Receives an element that has been added to delta set.\n     *\n     * @param value  The value of the added element.\n     */\n    add(value: T): void;\n\n    /**\n     * Receives an element that has been remove from delta set.\n     *\n     * @param value  The value of the removed element.\n     */\n    delete(value: T): void;\n\n  }\n\n}\n\n/**\n * @internal\n */\nfunction deltaSetDeltaReceiver<T>(\n    receiver: { add(value: T): void; delete(value: T): void; },\n): (this: void, add: Iterable<T>, remove: Iterable<T>) => void {\n  return (add, remove) => {\n    for (const removed of remove) {\n      receiver.delete(removed);\n    }\n    for (const added of add) {\n      receiver.add(added);\n    }\n  };\n}\n","/**\n * @module input-aspects\n */\nimport { filterIt, mapIt } from 'a-iterable';\nimport { asis, isPresent, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n */\nexport type InConverter<From, To> =\n    | InConverter.Factory<From, To>\n    | InConverter.Conversion<From, To>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => InConverter.Conversion<From, To>;\n\n  /**\n   * Input control conversion.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Conversion<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(this: void, value: From): To;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(this: void, value: To): From;\n\n  }\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * input aspect conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Aspect<From, To> =\n      | InConverter.Aspect.Conversion<To>\n      | InConverter.Aspect.Factory<From, To>;\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<To>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Conversion<Value> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, Value, Kind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines value converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter: InConverter<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To>;\n\n/**\n * Creates converter that combines aspect converters.\n *\n * @typeparam Value  Input value type.\n * @param converters  Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Aspect.Factory<From, To>;\n\nexport function intoConvertedBy<From, To>(\n    valueOrAspectConverter?: InConverter<From, To> | InConverter.Aspect<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n  const aspectConverters = mapIt<InConverter.Aspect<From, To>, InConverter.Aspect.Factory<From, To>>(\n      converters,\n      inConverter,\n  );\n\n  return (from, to) => {\n\n    const conversion = converter(from, to);\n    const aspectConversions: InConverter.Aspect.Conversion<To>[] = Array.from(\n        filterIt<InConverter.Aspect.Conversion<To> | undefined, InConverter.Aspect.Conversion<To>>(\n            mapIt(\n                aspectConverters,\n                acf => acf(from, to),\n            ),\n            isPresent,\n        ),\n    );\n    const applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined = aspect => {\n      if (conversion.applyAspect) {\n\n        const applied = conversion.applyAspect(aspect);\n\n        if (applied) {\n          return applied;\n        }\n      }\n      for (const asc of aspectConversions) {\n\n        const applied = asc.applyAspect(aspect);\n\n        if (applied) {\n          return applied;\n        }\n      }\n\n      return;\n    };\n\n    if (/*#__INLINE__*/ isAspectConversion(conversion)) {\n      return {\n        get: asis as (value: To) => From,\n        set: asis as (value: From) => To,\n        applyAspect,\n      };\n    }\n\n    return {\n      set: (value: From) => conversion.set(value) as To,\n      get: (value: To) => conversion.get(value) as From,\n      applyAspect,\n    };\n  };\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Conversion<any, any> = {\n  get: asis,\n  set: asis,\n};\n\n/**\n * @internal\n */\nfunction noopInConverter() {\n  return noopInConversion;\n}\n\n/**\n * @internal\n */\nfunction isAspectConversion<From, To>(\n    conversion: InConverter.Conversion<From, To> | InConverter.Aspect.Conversion<To>,\n): conversion is InConverter.Aspect.Conversion<To> {\n  return (conversion as any).get == null;\n}\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To>,\n): InConverter.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Aspect<From, To>,\n): InConverter.Aspect.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To>;\n\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","import { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam({ p, pl }: HthvItem, param: HthvParamItem) {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (config.delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If it’s not a printable ASCII character…\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It’s a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It’s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they’re redundant. Note that this is only possible if the escape\n\t// sequence isn’t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It’s not safe to remove the space, so don’t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n","/* eslint-disable no-var, prefer-template */\nvar uppercasePattern = /[A-Z]/g\nvar msPattern = /^ms-/\nvar cache = {}\n\nfunction toHyphenLower(match) {\n  return '-' + match.toLowerCase()\n}\n\nfunction hyphenateStyleName(name) {\n  if (cache.hasOwnProperty(name)) {\n    return cache[name]\n  }\n\n  var hName = name.replace(uppercasePattern, toHyphenLower)\n  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)\n}\n\nexport default hyphenateStyleName\n","import cssesc from 'cssesc';\n\n/**\n * @internal\n */\nexport function cssescId(id: string): string {\n  return cssesc(id, { isIdentifier: true });\n}\n\n/**\n * @internal\n */\nexport const IMPORTANT_CSS_SUFFIX = '!important';\n"],"names":["Function","result","Naming","RenderScheduleConfig","options","receiver","Symbol","x","n","hasOwnProperty","regexAnySingleEscape","regexSingleEscape","regexExcessiveSpaces","cssesc","string","defaults","key","call","merge","quotes","quote","isIdentifier","firstChar","charAt","output","counter","length","character","codePoint","charCodeAt","value","extra","toString","toUpperCase","escapeEverything","test","slice","replace","$0","$1","$2","wrap","version","uppercasePattern","msPattern","cache","toHyphenLower","match","toLowerCase","name","hName"],"mappings":"ugSA2NuEA,4JCnMjDC,+kSC6CtB,yrrBCvCqDC,4uDC2H5CC,kLAoBMC,y/ECvDQC,8kBCyD0DC,q8oBC1KjF,+CAQIC,EAAAA,4DCHFC,EAAAA,o/GCPF,IACIC,GADS,GACeA,eAcxBC,GAAuB,yBACvBC,GAAoB,0BAEpBC,GAAuB,oDAGvBC,GAAS,SAASA,EAAOC,EAAQV,GAEd,WADtBA,EApBW,SAAeA,EAASW,OAC9BX,SACGW,MAEJd,EAAS,OACR,IAAIe,KAAOD,EAGfd,EAAOe,GAAOP,GAAeQ,KAAKb,EAASY,GAAOZ,EAAQY,GAAOD,EAASC,UAEpEf,EAUGiB,CAAMd,EAASS,EAAOT,UACpBe,QAAwC,UAAlBf,EAAQe,SACzCf,EAAQe,OAAS,kBAEdC,EAA0B,UAAlBhB,EAAQe,OAAqB,IAAM,IAC3CE,EAAejB,EAAQiB,aAEvBC,EAAYR,EAAOS,OAAO,GAC1BC,EAAS,GACTC,EAAU,EACVC,EAASZ,EAAOY,OACbD,EAAUC,GAAQ,KACpBC,EAAYb,EAAOS,OAAOE,KAC1BG,EAAYD,EAAUE,aACtBC,OAAQ,KAERF,EAAY,IAAQA,EAAY,IAAM,IACrCA,GAAa,OAAUA,GAAa,OAAUH,EAAUC,EAAQ,KAE/DK,EAAQjB,EAAOe,WAAWJ,KACN,QAAX,MAARM,GAEJH,IAA0B,KAAZA,IAAsB,KAAe,KAARG,GAAiB,MAI5DN,IAGFK,EAAQ,KAAOF,EAAUI,SAAS,IAAIC,cAAgB,SAIpDH,EAFE1B,EAAQ8B,iBACPxB,GAAqByB,KAAKR,GACrB,KAAOA,EAEP,KAAOC,EAAUI,SAAS,IAAIC,cAAgB,IAE7C,iBAAiBE,KAAKR,GACxB,KAAOC,EAAUI,SAAS,IAAIC,cAAgB,IAC/B,MAAbN,IAAsBN,IAA8B,KAAbM,GAAoBP,GAASO,GAA0B,KAAbA,GAAqBP,GAASO,IAAcN,GAAgBV,GAAkBwB,KAAKR,GACtK,KAAOA,EAEPA,EAGVH,GAAUM,SAGPT,IACC,UAAUc,KAAKX,GAClBA,EAAS,MAAQA,EAAOY,MAAM,GACpB,KAAKD,KAAKb,KACpBE,EAAS,MAAQF,EAAY,IAAME,EAAOY,MAAM,KAOlDZ,EAASA,EAAOa,QAAQzB,IAAsB,SAAU0B,EAAIC,EAAIC,UAC3DD,GAAMA,EAAGb,OAAS,EAEdY,GAGAC,GAAM,IAAMC,MAGhBnB,GAAgBjB,EAAQqC,KACrBrB,EAAQI,EAASJ,EAElBI,GAIRX,GAAOT,QAAU,mBACI,gBACJ,SACN,eACF,GAGTS,GAAO6B,QAAU,QAEjB,UAAiB7B,GC5Gb8B,GAAmB,SACnBC,GAAY,OACZC,GAAQ,GAEZ,SAASC,GAAcC,SACd,IAAMA,EAAMC,+kICAa,4CAAA,gyOAAA,swMDGlC,SAA4BC,MACtBJ,GAAMpC,eAAewC,UAChBJ,GAAMI,OAGXC,EAAQD,EAAKZ,QAAQM,GAAkBG,WACnCD,GAAMI,GAAQL,GAAUT,KAAKe,GAAS,IAAMA,EAAQA"}