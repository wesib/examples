{"version":3,"file":"lib.43b73b82.m.js","sources":["../../node_modules/call-thru/src/misc/asis.ts","../../node_modules/call-thru/src/misc/noop.ts","../../node_modules/call-thru/src/misc/presence.ts","../../node_modules/call-thru/src/misc/value-providers.ts","../../node_modules/call-thru/src/next-call.ts","../../node_modules/call-thru/src/passes/arg.ts","../../node_modules/call-thru/src/passes/args.ts","../../node_modules/call-thru/src/passes/each.ts","../../node_modules/call-thru/src/passes/skip.ts","../../node_modules/a-iterable/src/api.ts","../../node_modules/a-iterable/src/revertible-iterable.ts","../../node_modules/a-iterable/src/util.ts","../../node_modules/a-iterable/src/reverse.ts","../../node_modules/a-iterable/src/termination.ts","../../node_modules/a-iterable/src/transform.ts","../../node_modules/a-iterable/src/thru/thru-it.ts","../../node_modules/a-iterable/src/a-iterable.ts","../../node_modules/a-iterable/src/construction.ts","../../node_modules/a-iterable/src/objects.ts","../../node_modules/context-values/src/context-key.ts","../../node_modules/context-values/src/context-key-error.ts","../../node_modules/context-values/src/context-value-spec.ts","../../node_modules/context-values/src/context-values.ts","../../node_modules/context-values/src/context-registry.ts","../../node_modules/context-values/src/simple-context-key.ts","../../node_modules/fun-events/src/base/event-keeper.ts","../../node_modules/fun-events/src/base/event-supply.ts","../../node_modules/fun-events/src/base/event-receiver.ts","../../node_modules/fun-events/src/base/event-notifier.impl.ts","../../node_modules/fun-events/src/base/event-notifier.ts","../../node_modules/fun-events/src/base/event-sender.ts","../../node_modules/fun-events/src/base/no-event-supply.ts","../../node_modules/fun-events/src/base/send-events-to.ts","../../node_modules/fun-events/src/impl/once.ts","../../node_modules/fun-events/src/impl/share.ts","../../node_modules/fun-events/src/impl/thru.ts","../../node_modules/fun-events/src/impl/till-off.ts","../../node_modules/fun-events/src/base/impl/never-receive.ts","../../node_modules/fun-events/src/on-event.ts","../../node_modules/fun-events/src/impl/then.ts","../../node_modules/fun-events/src/after-event.ts","../../node_modules/fun-events/src/keepers/after-sent.ts","../../node_modules/fun-events/src/keepers/after-supplied.ts","../../node_modules/fun-events/src/keepers/after-all.ts","../../node_modules/fun-events/src/keepers/after-each.ts","../../node_modules/fun-events/src/keepers/after-the.ts","../../node_modules/fun-events/src/passes/next-after-event.ts","../../node_modules/fun-events/src/senders/event-emitter.ts","../../node_modules/fun-events/src/senders/on-never.ts","../../node_modules/fun-events/src/senders/on-supplied.ts","../../node_modules/fun-events/src/senders/on-any.ts","../../node_modules/fun-events/src/senders/on-async.ts","../../node_modules/fun-events/src/senders/on-any-async.ts","../../node_modules/fun-events/src/state/state-path.ts","../../node_modules/fun-events/src/state/state-tracker.ts","../../node_modules/fun-events/src/value/value-tracker.ts","../../node_modules/fun-events/src/value/track-value.ts","../../node_modules/fun-events/src/value/value-sync.ts","../../node_modules/namespace-aliaser/src/naming.ts","../../node_modules/namespace-aliaser/src/namings.ts","../../node_modules/namespace-aliaser/src/namespace.ts","../../node_modules/namespace-aliaser/src/name.ts","../../node_modules/namespace-aliaser/src/namespace-aliaser.ts","../../node_modules/context-values/src/updatable/context-up-key.ts","../../node_modules/context-values/src/updatable/fn-context-key.ts","../../node_modules/render-scheduler/src/render-schedule.ts","../../node_modules/render-scheduler/src/custom-render-scheduler.ts","../../node_modules/render-scheduler/src/render-queue.ts","../../node_modules/render-scheduler/src/animation-render-scheduler.ts","../../node_modules/render-scheduler/src/render-scheduler.ts","../../node_modules/fun-events/src/dom/on-dom-event.ts","../../node_modules/fun-events/src/dom/dom-event-dispatcher.ts","../../node_modules/http-header-value/src/hthv-partial.impl.ts","../../node_modules/http-header-value/src/parser/add-param.ts","../../node_modules/http-header-value/src/parser/next-in-item.ts","../../node_modules/http-header-value/src/parser/parse-date-time.ts","../../node_modules/http-header-value/src/parser/parse-none.ts","../../node_modules/http-header-value/src/parser/item-parser.ts","../../node_modules/http-header-value/src/parser/quoted-string-parser.ts","../../node_modules/http-header-value/src/parser/angle-brackets-parser.ts","../../node_modules/http-header-value/src/parser/next-in-comment.ts","../../node_modules/http-header-value/src/parser/spaces-parser.ts","../../node_modules/http-header-value/src/parser/param-parser.ts","../../node_modules/http-header-value/src/parser/parser-config.ts","../../node_modules/http-header-value/src/hthv-parser.ts","../../node_modules/http-header-value/src/parser/item-delimit-parser.ts","../../node_modules/http-header-value/src/parser/comment-parser.ts","../../node_modules/http-header-value/src/hthv-parse.ts","../../node_modules/http-header-value/src/hthv-quote.ts","../../node_modules/cssesc/cssesc.js","../../node_modules/hyphenate-style-name/index.js","../../node_modules/style-producer/src/internal/css.ts","../../node_modules/style-producer/src/internal/types.ts","../../node_modules/style-producer/src/value/value.ts","../../node_modules/style-producer/src/value/color/color.ts","../../node_modules/style-producer/src/value/color/mix.ts","../../node_modules/style-producer/src/value/numeric/numeric.ts","../../node_modules/style-producer/src/value/mapper.ts","../../node_modules/style-producer/src/value/priority.ts","../../node_modules/style-producer/src/value/numeric/numeric.impl.ts","../../node_modules/style-producer/src/value/numeric/zero.impl.ts","../../node_modules/style-producer/src/value/numeric/dimension-kind.impl.ts","../../node_modules/style-producer/src/value/unit/length.ts","../../node_modules/style-producer/src/value/url.ts","../../node_modules/style-producer/src/rule/properties.impl.ts","../../node_modules/style-producer/src/selector/selector.impl.ts","../../node_modules/style-producer/src/selector/query.ts","../../node_modules/style-producer/src/selector/selector-constructor.ts","../../node_modules/style-producer/src/selector/selector-text.impl.ts","../../node_modules/style-producer/src/producer/renderer.impl.ts","../../node_modules/style-producer/src/producer/at-rules.renderer.ts","../../node_modules/style-producer/src/producer/globals.renderer.ts","../../node_modules/style-producer/src/producer/properties.renderer.ts","../../node_modules/style-producer/src/producer/options.impl.ts","../../node_modules/style-producer/src/producer/produce-basic-style.ts","../../node_modules/style-producer/src/selector/selector-text.ts","../../node_modules/style-producer/src/producer/text.renderer.ts","../../node_modules/style-producer/src/producer/xml-ns.renderer.ts","../../node_modules/style-producer/src/producer/produce-style.ts","../../node_modules/style-producer/src/rule/rule.ts","../../node_modules/style-producer/src/rule/rules.impl.ts","../../node_modules/style-producer/src/rule/rule.impl.ts","../../node_modules/style-producer/src/rule/root.ts","../../node_modules/style-producer/src/rule/rule-ref.ts","../../node_modules/style-producer/src/rule/rule-refs.ts","../../node_modules/style-producer/src/rule/rules.ts","../../node_modules/delta-set/src/delta-set.ts","../../node_modules/input-aspects/src/aspect.ts","../../node_modules/input-aspects/src/aspect.impl.ts","../../node_modules/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../node_modules/input-aspects/src/aspects/render-scheduler.aspect.ts","../../node_modules/input-aspects/src/converter.ts","../../node_modules/input-aspects/src/control.ts","../../node_modules/input-aspects/src/controls/value-of.control.ts","../../node_modules/input-aspects/src/controls/abstract.control.ts","../../node_modules/input-aspects/src/containers/container.control.ts","../../node_modules/input-aspects/src/containers/parents.aspect.ts","../../node_modules/input-aspects/src/element.control.ts","../../node_modules/input-aspects/src/data/mode.aspect.ts","../../node_modules/input-aspects/src/data/data.aspect.ts","../../node_modules/input-aspects/src/containers/group.control.ts","../../node_modules/input-aspects/src/validation/require-nothing.validator.ts","../../node_modules/input-aspects/src/validation/validator.ts","../../node_modules/input-aspects/src/validation/validator.impl.ts","../../node_modules/input-aspects/src/validation/validation.aspect.ts","../../node_modules/input-aspects/src/validation/require-all.validator.ts","../../node_modules/input-aspects/src/validation/require-present.validator.ts","../../node_modules/input-aspects/src/elements/abstract-element.control.ts","../../node_modules/input-aspects/src/elements/text.control.ts","../../node_modules/input-aspects/src/elements/focus/focus.aspect.ts","../../node_modules/input-aspects/src/elements/focus/status.aspect.ts","../../node_modules/input-aspects/src/elements/style/styled-element.aspect.ts","../../node_modules/input-aspects/src/elements/style/css-classes.aspect.ts","../../node_modules/input-aspects/src/elements/style/css-error.ts","../../node_modules/input-aspects/src/elements/style/css-info.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * A function that returns its argument as is.\n *\n * @param value  A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * A function that checks whether the given value is present.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\n/**\n * Creates a provider of the only argument.\n *\n * @param value  A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return (): T => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return (): T => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return (): T => Array.from(values) as T;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from './call-chain';\n\n/**\n * A key of a [[NextCall]] method responsible for calling the next pass in chain.\n */\nexport const NextCall__symbol = (/*#__PURE__*/ Symbol('next-call'));\n\n/**\n * A call of the next pass in chain.\n *\n * This is basically a function with additional method, which is treated specially by call chaining functions.\n * When previous pass in chain returns a [[NextCall]] instance, it will be used to call the next pass in chain.\n * Otherwise the next pass will be called with value returned as its {@link CallChain.pass single argument}.\n *\n * A [[NextCall]] is a function returning itself. So it can be chained like any other pass.\n *\n * A [[nextCall]] function can be used to construct a next call.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of arguments tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass. The same as `NextArgs` by default.\n */\nexport interface NextCall<Chain extends CallChain, NextArgs extends any[], NextArg = NextArgs> {\n\n  readonly $?: NextArg; // Silence the TypeScript compiler, as `NextArg` is never read.\n\n  /**\n   * Calls the given pass of the call chain.\n   *\n   * @param chain  Target call chain.\n   * @param pass  A pass in call chain to call.\n   */\n  [NextCall__symbol](\n      chain: Chain,\n      pass: (this: void, ...args: NextArgs) => void,\n  ): void;\n\n  /**\n   * Returns itself.\n   *\n   * Makes this call a valid no-arg pass of a call chain.\n   */\n  (): this; // eslint-disable-line @typescript-eslint/prefer-function-type\n\n}\n\n/**\n * Constructs a call of the next pass in chain.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of argument tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass. The same as `NextArgs` by default.\n * @param callNext  A next pass caller function.\n *\n * @returns Next pass call performed by the given function.\n */\nexport function nextCall<Chain extends CallChain, NextArgs extends any[], NextArg>(\n    callNext: (\n        this: void,\n        chain: Chain,\n        fn: (this: void, ...args: NextArgs) => void,\n    ) => void,\n): NextCall<Chain, NextArgs, NextArg> {\n\n  const result = (() => result) as NextCall<Chain, NextArgs, NextArg>;\n\n  result[NextCall__symbol] = (chain, fn) => callNext(chain, fn);\n\n  return result;\n}\n\n/**\n * Checks whether the `target` value is a {@link NextCall next call}.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of arguments tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass.\n * @param target  A value to check.\n *\n * @returns `true` if the `target` value is a function with [[NextCall__symbol]] property, or `false` otherwise.\n */\nexport function isNextCall<Chain extends CallChain, NextArgs extends any[], NextArg>(\n    target: any,\n): target is NextCall<Chain, NextArgs, NextArg> {\n  return typeof target === 'function' && NextCall__symbol in target;\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Provides a single argument for the next call chain pass.\n *\n * The returned [[NextCall]] implementation does the same as if the `arg` returned from the call chain pass.\n *\n * @typeparam NextArg  A type of argument for the next pass.\n * @param arg  Argument for the next pass.\n *\n * @return A call of the next pass with the given argument.\n */\nexport function nextArg<NextArg>(arg: NextArg): NextCall<CallChain, [NextArg], NextArg> {\n  return nextCall((chain, pass) => chain.pass(pass, arg));\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Provides arguments for the next call chain pass.\n *\n * @typeparam NextArgs  A type of arguments tuple for the next pass.\n * @param args  Arguments for the next pass.\n *\n * @return A call of the next pass with the given arguments.\n */\nexport function nextArgs<NextArgs extends any[]>(\n    ...args: NextArgs\n): NextCall<CallChain, NextArgs, NextArgs> {\n  return nextCall((chain, fn) => chain.call(fn, args));\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Builds a next chained call that passes each provided element to the next pass.\n *\n * Note that default [[CallChain]] supported by [[callThru]] would return only the last element.\n *\n * @typeparam T  A type of element to pass down the chain.\n * @param elements  An iterable of elements to pass down the chain.\n *\n * @returns A multi-call of the next pass with each element.\n */\nexport function nextEach<T>(elements: Iterable<T>): NextCall<CallChain, [T], T> {\n  return nextCall((chain, pass) => {\n    for (const element of elements) {\n      chain.pass(pass, element);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * A special [[NextCall]] indicating the rest of the steps are skipped.\n *\n * @typeparam Result  Call chain result type.\n */\nexport type NextSkip<Result = undefined> = NextCall<CallChain, never, Result>;\n\n/**\n * Builds a next call that skips the rest of the chain.\n *\n * This has the same effect as {@link nextReturn `nextReturn(undefined)`}.\n */\nexport const nextSkip: NextSkip = (/*#__PURE__*/ nextCall(chain => chain.skip()));\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\n/**\n * A type of elements of iterable.\n *\n * @typeparam T  A type of iterable.\n */\nexport type IterableElement<T extends Iterable<any>> = T extends Iterable<infer E> ? E : never;\n\n/**\n * Arbitrary class implementing `Iterable` interface.\n *\n * @typeparam T  A type of iterable.\n * @typeparam E  A type of elements to iterate.\n */\nexport interface IterableClass<T extends Iterable<E>, E = IterableElement<T>> extends Function {\n  prototype: T;\n  new (...args: any[]): T;\n}\n\n/**\n * Checks whether the given value is array-like.\n *\n * @param target  A value to check.\n *\n * @returns `true` if the `value` has a `length` property, or `false` otherwise.\n */\nexport function isArrayLike<T>(target: any): target is ArrayLike<T> {\n  return 'length' in target;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\n/**\n * An iterable which elements order can be reversed.\n *\n * Arrays implement this interface.\n */\nexport interface RevertibleIterable<T> extends Iterable<T> {\n\n  /**\n   * Returns an iterable containing this iterable's elements in reverse order.\n   *\n   * Corresponds to `Array.prototype.reverse()`. Note however, that the array counterpart reverses elements _in place_\n   * rather than creating a new array.\n   *\n   * @return Reversed iterable instance.\n   */\n  reverse(): Iterable<T>;\n\n}\n\n/**\n * Checks whether the given iterable is revertible.\n *\n * This is always `true` for arrays.\n *\n * @param iterable  Iterable to check.\n *\n * @returns `true` if `iterable` has a `reverse` property, or `false` otherwise.\n */\nexport function itsRevertible<T>(iterable: Iterable<T>): iterable is RevertibleIterable<T> {\n  return 'reverse' in iterable;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * This is a shortcut for `iterable[Symbol.iterator]` to make it friendlier to minification.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n\n/**\n * Builds an iterable iterator over the given `iterable`.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterable<T>(iterable: Iterable<T>): IterableIterator<T> {\n  return function *() { yield* iterable; }();\n}\n\n/**\n * Creates custom iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  When `undefined` or unspecified the created iterable won't be reversible.\n *\n * @returns New iterable.\n */\nexport function makeIt<T>(iterate: (this: Iterable<T>) => Iterator<T>, reverse?: undefined): Iterable<T>;\n\n/**\n * Creates custom revertible iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  A no-arg function constructing a reverse iterable.\n *\n * @returns New reversible iterable.\n */\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse: (this: RevertibleIterable<T>) => Iterable<T>,\n): RevertibleIterable<T>;\n\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse?: (this: RevertibleIterable<T>) => Iterable<T>,\n): Iterable<T> {\n\n  const iterable: Iterable<T> = {\n    [Symbol.iterator]: iterate,\n  };\n\n  if (!reverse) {\n    return iterable;\n  }\n\n  const reversible = iterable as RevertibleIterable<T>;\n\n  reversible.reverse = reverse;\n\n  return reversible;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Constructs a reversed iterable.\n *\n * If the `source` iterable is an array-like structure, then uses `reverseArray()` function to revert the constructed\n * iterable.\n * If the `source` iterable is revertible, then uses its `reverse()` method to revert the constructed one.\n * Otherwise stores elements to array and reverts them with `reverseArray()` function.\n *\n * @param source  A source iterable.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseIt<T>(source: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): Iterable<T> {\n  if (isArrayLike(source)) {\n    return reverseArray(source);\n  }\n  if (itsRevertible(source)) {\n\n    const reversed = source.reverse();\n\n    return makeIt(() => itsIterator(reversed));\n  }\n  return reverseArray(Array.from(source));\n}\n\n/**\n * Constructs an iterable of array-like structure elements in reverse order.\n *\n * @param array  Source array.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseArray<T>(array: ArrayLike<T>): Iterable<T> {\n  return makeIt(\n      function *() {\n\n        const len = array.length;\n\n        for (let i = len - 1; i >= 0; --i) {\n          yield array[i];\n        }\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator } from './util';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  for (const element of iterable) {\n    action(element);\n  }\n}\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable  Iterable to check for elements.\n *\n * @return `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<any>): boolean {\n  return !!itsIterator(iterable).next().done;\n}\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (!test(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Tests whether at least one element of the given `iterable` passes the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n * and return `true` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the callback function returned a truthy value for at least one element in the array, or `false`\n * otherwise. Returns `false` for empty iterable.\n */\nexport function itsSome<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (test(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns the first element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  return itsIterator(iterable).next().value;\n}\n\n/**\n * Returns the last element of the given `iterable`.\n *\n * If the given `iterable` is an array-like structure, then just returns its last element. If it is revertible,\n * then extracts the first element of reverted one. Otherwise iterates over elements to find the last one.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the last element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsLast<T>(iterable: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): T | undefined {\n  if (isArrayLike(iterable)) {\n    return iterable[iterable.length - 1];\n  }\n  if (itsRevertible(iterable)) {\n    return itsFirst(iterable.reverse());\n  }\n\n  let last: T | undefined;\n\n  for (const element of iterable) {\n    last = element;\n  }\n\n  return last;\n}\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeparam T  A type of `iterable` elements.\n * @typeparam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: R, element: T) => R,\n    initialValue: R,\n): R {\n\n  let reduced = initialValue;\n\n  for (const element of iterable) {\n    reduced = reducer(reduced, element);\n  }\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { asis } from 'call-thru';\nimport { makeIt } from './util';\n\n/**\n * Creates an iterable with all `source` iterable elements that pass the test implemented by the provided function.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): Iterable<T>;\n\n/**\n * Creates an iterable with all `source` iterable elements extending the given type.\n *\n * @typeparam T  A type of source elements\n * @typeparam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T, R extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is R,\n): Iterable<R>;\n\nexport function filterIt<T>(source: Iterable<T>, test: (this: void, element: T) => boolean): Iterable<T> {\n  return makeIt(function *() {\n    for (const element of source) {\n      if (test(element)) {\n        yield element;\n      }\n    }\n  });\n}\n\n/**\n * Flattens the source iterable of iterables into a new iterable.\n *\n * Calling this function is the same as calling `flatMapIt(source, asis)`.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable of iterables.\n *\n * @returns A new iterable with each element of `source` being the flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): Iterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into a new\n * iterable.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n *\n * @returns A new iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => Iterable<R>): Iterable<R>;\n\nexport function flatMapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R> = asis as (element: T) => Iterable<R>,\n): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield* convert(element);\n    }\n  });\n}\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element of the `source` one.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n */\nexport function mapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => R): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield convert(element);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { asis, isNextCall, NextCall__symbol, noop } from 'call-thru';\nimport { flatMapIt } from '../transform';\nimport { IterableCallChain } from './iterable-call-chain';\nimport Args = IterableCallChain.Args;\nimport Out = IterableCallChain.Out;\n\n/**\n * Passes each element of the given iterable trough the {@link IterableCallChain chain of transformation passes}.\n *\n * The passes are preformed by `call-thru`.\n *\n * @returns An iterable of transformed elements.\n */\nexport function thruIt<\n    T, Return1\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n): Iterable<Out<Return1>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n): Iterable<Out<Return2>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n): Iterable<Out<Return3>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<\n    T, Return1,\n    Args2 extends Args<Return1>, Return2,\n    Args3 extends Args<Return2>, Return3,\n    Args4 extends Args<Return3>, Return4,\n    Args5 extends Args<Return4>, Return5,\n    Args6 extends Args<Return5>, Return6,\n    Args7 extends Args<Return6>, Return7,\n    Args8 extends Args<Return7>, Return8,\n    Args9 extends Args<Return8>, Return9,\n    Args10 extends Args<Return9>, Return10,\n    Args11 extends Args<Return10>, Return11,\n    Args12 extends Args<Return11>, Return12,\n    Args13 extends Args<Return12>, Return13,\n    >(\n    it: Iterable<T>,\n    pass1: (this: void, arg: T) => Return1,\n    pass2: (this: void, ...args: Args2) => Return2,\n    pass3: (this: void, ...args: Args3) => Return3,\n    pass4: (this: void, ...args: Args4) => Return4,\n    pass5: (this: void, ...args: Args5) => Return5,\n    pass6: (this: void, ...args: Args6) => Return6,\n    pass7: (this: void, ...args: Args7) => Return7,\n    pass8: (this: void, ...args: Args8) => Return8,\n    pass9: (this: void, ...args: Args9) => Return9,\n    pass10: (this: void, ...args: Args10) => Return10,\n    pass11: (this: void, ...args: Args11) => Return11,\n    pass12: (this: void, ...args: Args12) => Return12,\n    pass13: (this: void, ...args: Args13) => Return13,\n): Iterable<Out<Return4>>;\n\nexport function thruIt<T>(\n    it: Iterable<T>,\n    ...passes: ((...args: any[]) => any)[]\n): Iterable<any> {\n\n  let result: Iterable<any>[] = [];\n  const chain = (index: number): IterableCallChain => {\n\n    const lastPass = index >= passes.length;\n\n    ++index;\n\n    const pass = index < passes.length ? passes[index] : noop;\n    const handleResult = (callResult: any, arg: any): void => {\n      if (isNextCall(callResult)) {\n        callResult[NextCall__symbol](chain(index), pass);\n      } else if (lastPass) {\n        result.push([arg]);\n      } else {\n        chain(index).pass(pass, callResult);\n      }\n    };\n\n    return ({\n      call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n        handleResult(fn(...args), args);\n      },\n      pass<A>(fn: (arg: A) => any, arg: A): void {\n        handleResult(fn(arg), arg);\n      },\n      skip() {/* skip item */},\n      iterate<I>(fn: (this: void, arg: I) => void, iterable: Iterable<I>): void {\n        result.push({\n          *[Symbol.iterator]() {\n            for (const item of iterable) {\n\n              const oldResult = result;\n              const newResult: Iterable<any>[] = [];\n\n              try {\n                result = newResult;\n                handleResult(fn(item), item);\n              } finally {\n                result = oldResult;\n              }\n\n              for (const res of newResult) {\n                yield* res;\n              }\n            }\n          },\n        });\n      },\n    });\n  };\n\n  chain(0).iterate(passes[0], it);\n\n  return flatMapIt(result, asis);\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { IterableClass, IterableElement } from './api';\nimport { ArrayLikeIterable } from './array-like-iterable';\nimport { reverseArray, reverseIt } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { itsEach, itsEvery, itsReduction, itsSome } from './termination';\nimport { IterableCallChain, thruIt } from './thru';\nimport { filterIt, flatMapIt, mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\nimport Args = IterableCallChain.Args;\nimport Out = IterableCallChain.Out;\n\n/**\n * @internal\n */\nconst ArrayLikeIterableMethods: (keyof ArrayLikeIterable<any>)[] = [\n  'every',\n  'filter',\n  'flatMap',\n  'forEach',\n  'map',\n  'reduce',\n  'reverse',\n  'some',\n];\n\n/**\n * Abstract `Iterable` implementation with array-like iteration operations.\n *\n * @typeparam T  A type of elements.\n */\nexport abstract class AIterable<T> implements ArrayLikeIterable<T> {\n\n  /**\n   * Returns an iterable without elements.\n   *\n   * @returns An empty iterable instance.\n   */\n  static none<T>(): AIterable<T> {\n    return noneAIterable; // eslint-disable-line @typescript-eslint/no-use-before-define\n  }\n\n  /**\n   * Checks whether the given iterable is an array-like one.\n   *\n   * @param source  An iterable to check.\n   *\n   * @returns `true` is the `source` has all `ArrayLikeIterable` methods (like `Array` or `AIterable` instance),\n   * or `false` otherwise.\n   */\n  static is<T>(source: Iterable<T>): source is ArrayLikeIterable<T> {\n    return ArrayLikeIterableMethods.every(name => name in source);\n  }\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source array-like iterable.\n   *\n   * @return A `source` itself.\n   */\n  static of<T>(source: ArrayLikeIterable<T>): typeof source;\n\n  /**\n   * Creates an [[AIterable]] instance that iterates over the same elements as the given one if necessary.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Either `source` itself if it implements `ArrayLikeIterable` already (see `is()` method),\n   * or new [[AIterable]] instance iterating over the `source`.\n   */\n  static of<T>(source: Iterable<T>): AIterable<T>;\n\n  static of<T>(source: Iterable<T> | RevertibleIterable<T> | T[]): ArrayLikeIterable<T> {\n    if (AIterable.is(source)) {\n      return source;\n    }\n    return AIterable.from(source);\n  }\n\n  /**\n   * Creates an `AIterable` instance that iterates over the same elements as the given one.\n   *\n   * Uses [[reverseIt]] function to reverse the constructed iterable.\n   *\n   * @param source  A source iterable.\n   *\n   * @return Always new `AIterable` instance.\n   */\n  static from<T>(source: Iterable<T> | RevertibleIterable<T> | readonly T[]): AIterable<T> {\n    return makeAIterable(() => source, () => reverseIt(source));\n  }\n\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.every()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n   * and return `false` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n   * Returns `true` for empty iterable.\n   */\n  every(test: (this: void, element: T) => boolean): boolean {\n    return itsEvery(this, test);\n  }\n\n  /**\n   * Creates an iterable with all elements that pass the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n   * It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter(test: (this: void, element: T) => boolean): AIterable<T>;\n\n  /**\n   * Creates an iterable with all elements extending the given type.\n   *\n   * Corresponds to `Array.prototype.filter()`.\n   *\n   * @typeparam R  Target type.\n   * @param test  A predicate function to test that element extends the type R. Returns `true` to keep the element, or\n   * `false` otherwise. It accepts the tested element as the only parameter.\n   *\n   * @return A new [[AIterable]] with the elements that pass the test. If no elements passed the test, an empty iterable\n   * will be returned.\n   */\n  filter<R extends T>(test: (this: void, element: T) => element is R): AIterable<R>;\n\n  filter(test: (this: void, element: T) => boolean): AIterable<T> {\n    return makeAIterable(\n        () => filterIt(this, test),\n        () => filterIt(this.reverse(), test),\n    );\n  }\n\n  /**\n   * First maps each element using a mapping function, then flattens the result into a new iterable.\n   *\n   * Corresponds to `Array.prototype.flatMap()`.\n   *\n   * Note that the overridden `flatMap` method of `ArrayLikeIterable` expects an array to be returned from `convert`\n   * callback, while in this method it may return arbitrary iterable.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n   *\n   * @returns A new [[AIterable]] with each element being the flattened result of the `convert` function call.\n   */\n  flatMap<R>(convert: (this: void, element: T) => Iterable<R>): AIterable<R> {\n    return makeAIterable(\n        () => flatMapIt(this, convert),\n        () => flatMapIt(this.reverse(), element => reverseIt(convert(element))),\n    );\n  }\n\n  /**\n   * Performs the given `action` for each element.\n   *\n   * Corresponds to `Array.prototype.forEach()`.\n   *\n   * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n   * parameter.\n   */\n  forEach(action: (this: void, element: T) => void): void {\n    itsEach(this, action);\n  }\n\n  /**\n   * Creates a new iterable with the results of calling a provided function on every element.\n   *\n   * Corresponds to `Array.prototype.map()`.\n   *\n   * @typeparam R  A type of converted elements.\n   * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n   * parameter.\n   *\n   * @return A new [[AIterable]] with each element being the result of the `convert` function call.\n   */\n  map<R>(convert: (this: void, element: T) => R): AIterable<R> {\n    return makeAIterable(\n        () => mapIt(this, convert),\n        () => mapIt(this.reverse(), convert),\n    );\n  }\n\n  /**\n   * Applies a function against an accumulator and each element to reduce elements to a single value.\n   *\n   * Corresponds to `Array.prototype.reduce()`.\n   *\n   * @typeparam R  A type of reduced value.\n   * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n   * @param initialValue  Initial value passed to the first `reducer` call.\n   *\n   * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in this\n   * iterable.\n   */\n  reduce<R>(reducer: (this: void, prev: R, element: T) => R, initialValue: R): R {\n    return itsReduction(this, reducer, initialValue);\n  }\n\n  /**\n   * Constructs an iterable containing this iterable's elements in reverse order.\n   *\n   * By default this method converts iterable to array and then reverts its elements with [[reverseArray]] function.\n   *\n   * @return Reversed [[AIterable]] instance.\n   */\n  reverse(): AIterable<T> {\n    return makeAIterable(() => reverseArray(Array.from(this)), () => this);\n  }\n\n  /**\n   * Tests whether some element passed the test implemented by the provided function.\n   *\n   * Corresponds to `Array.prototype.some()`.\n   *\n   * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n   * and return `true` from the method call. It accepts the tested element as the only parameter.\n   *\n   * @returns `true` if the `test` function returned a truthy value for some element, or `false` otherwise.\n   * Returns `false` for empty iterable.\n   */\n  some(test: (this: void, element: T) => boolean): boolean {\n    return itsSome(this, test);\n  }\n\n  /**\n   * Passes each element of this iterable trough a chain of transformation passes.\n   *\n   * The passes are preformed by `call-thru` library.\n   *\n   * @returns Next iterable of transformed elements.\n   */\n  thru<\n      Return1,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n  ): AIterable<Out<Return1>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AIterable<Out<Return2>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AIterable<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, arg: T) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AIterable<Out<Return3>>;\n\n  thru<R>(...fns: ((...args: any[]) => any)[]): AIterable<R> {\n\n    const thru = thruIt as any;\n\n    return makeAIterable(() => thru(this, ...fns));\n  }\n\n}\n\n/**\n * @internal\n */\nclass NoneAIterable extends AIterable<any> {\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  *[Symbol.iterator](): Iterator<any> {}\n\n  reverse(): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst noneAIterable = (/*#__PURE__*/ new NoneAIterable());\n\n/**\n * @internal\n */\nfunction makeAIterable<T>(\n    iterate: (this: void) => Iterable<T>,\n    reverse?: (this: void) => Iterable<T>,\n): AIterable<T> {\n\n  class Iterable extends AIterable<T> {\n\n    [Symbol.iterator](): Iterator<T> {\n      return itsIterator(iterate());\n    }\n\n    reverse(): Iterable {\n      if (!reverse) {\n        return super.reverse();\n      }\n      return AIterable.from(makeIt(() => itsIterator(reverse()), () => this));\n    }\n\n  }\n\n  return new Iterable();\n}\n\n/**\n * Extends an iterable class with `AIterable` API.\n *\n * @typeparam C  A type of iterable class to extend.\n * @typeparam E  A type of elements to iterate.\n * @param iterableClass  A class to extend.\n *\n * @returns A new class extending original `iterableClass` and implementing the missing [[AIterable]] methods.\n */\nexport function toAIterable<C extends IterableClass<any, E>, E = IterableElement<InstanceType<C>>>(\n    iterableClass: C,\n): C & IterableClass<AIterable<E>, E> {\n\n  class ExtendedIterable extends iterableClass {\n  }\n\n  const extended = ExtendedIterable;\n  const proto = extended.prototype;\n\n  ArrayLikeIterableMethods.forEach(name => {\n    if (!(name in proto)) {\n      Object.defineProperty(proto, name, {\n        configurable: true,\n        value: AIterable.prototype[name],\n      });\n    }\n  });\n\n  return extended as C & IterableClass<AIterable<E>, E>;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { reverseArray } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { makeIt } from './util';\n\n/**\n * Builds an iterable over elements of array-like structure.\n *\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns A revertible iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt<T>(\n      function *() {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < array.length; ++i) {\n          yield array[i];\n        }\n      },\n      () => reverseArray(array),\n  );\n}\n\n/**\n * @internal\n */\nconst noneIterable: RevertibleIterable<any> = {\n\n  *[Symbol.iterator](): Iterator<any> {/* do not iterate */},\n\n  reverse() { return this; },\n\n};\n\n/**\n * Returns an iterable without elements.\n *\n * @typeparam T  A type of constructed iterable elements.\n *\n * @returns An empty iterable instance revertible to itself.\n */\nexport function overNone<T>(): RevertibleIterable<T> {\n  return noneIterable;\n}\n","/**\n * @packageDocumentation\n * @module a-iterable\n */\nimport { overArray } from './construction';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Builds an iterable over the keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys from.\n */\nexport function overKeys<T extends object>(target: T): RevertibleIterable<keyof T> {\n  return overArray(Reflect.ownKeys(target) as (keyof T)[]);\n}\n\n/**\n * Object property entry. This is a tuple consisting of property key and value.\n */\nexport type ObjectEntry<T, K extends keyof T = keyof T> = [K, T[K]];\n\n/**\n * Builds an iterable over the key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys and values from.\n */\nexport function overEntries<T extends object>(target: T): RevertibleIterable<ObjectEntry<T>> {\n\n  const keys = overKeys(target);\n\n  function mapToEntries(_keys: Iterable<keyof T>): Iterable<ObjectEntry<T>> {\n    return mapIt(_keys, key => [key, target[key]] as ObjectEntry<T>);\n  }\n\n  return makeIt(() => itsIterator(mapToEntries(keys)), () => mapToEntries(keys.reverse()));\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [[ContextKey]] instance.\n */\nexport const ContextKey__symbol = /*#__PURE__*/ Symbol('context-key');\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextKey<Value, Src = Value, Seed = unknown> implements ContextRef<Value, Src> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<Src, Seed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @typeparam Ctx  Context type.\n   * @param opts  Context value growth options.\n   *\n   * @returns Single context value, or `undefined` if there is no default value.\n   */\n  abstract grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Value, Src, Seed>): Value | null | undefined;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value growth options.\n *\n * An instance of these options is passed to [[ContextKey.grow]] method to provide the necessary value growth context.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport interface ContextValueOpts<Ctx extends ContextValues, Value, Src, Seed> {\n\n  /**\n   * Target context.\n   */\n  readonly context: Ctx;\n\n  /**\n   * Context value seeder.\n   */\n  readonly seeder: ContextSeeder<Ctx, Src, Seed>;\n\n  /**\n   * Context value seed.\n   */\n  readonly seed: Seed;\n\n  /**\n   * A fallback value to use if there is no value associated with the given key.\n   *\n   * Can be `null` or `undefined`.\n   */\n  readonly or?: Value | null;\n\n  /**\n   * Handles missing context value.\n   *\n   * It can be called to prefer a fallback value over the default one specified in the value key.\n   *\n   * @param defaultProvider  Default value provider. It is called unless a fallback value is specified.\n   * If it returns a non-null/non-undefined value, then the returned value will be associated with the context key.\n   */\n  byDefault(defaultProvider: () => Value | null | undefined): Value | null | undefined;\n\n}\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Key  Context key type.\n */\nexport type ContextKeyDefault<Value, Key extends ContextKey<any, any, any>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: Key) => Value | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextSeedKey<Src, Seed> extends ContextKey<Seed, Src, Seed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<any, Src>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeparam Ctx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src, Seed>;\n\n  grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Seed, Src, Seed>): Seed | null | undefined {\n\n    const { seeder, seed } = opts;\n\n    return seeder.isEmpty(seed) ? opts.byDefault(() => seed) : seed;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { valueProvider } from 'call-thru';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Src  Source value type.\n */\nexport type ContextValueProvider<Ctx extends ContextValues, Src> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: Ctx) => Src | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSpec<\n    Ctx extends ContextValues,\n    Value,\n    Deps extends any[] = unknown[],\n    Src = Value,\n    Seed = unknown> =\n    | ContextValueSpec.IsConstant<Src, Seed>\n    | ContextValueSpec.ViaAlias<Src, Seed>\n    | ContextValueSpec.ByProvider<Ctx, Src, Seed>\n    | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.AsInstance<Ctx, Src, Seed>\n    | ContextValueSpec.SelfInstance<Ctx, Src, Seed>\n    | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface IsConstant<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Constant context value.\n     */\n    is: Src;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeparam Sec  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ViaAlias<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<Src, Seed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProvider<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<Ctx, Src>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProviderWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: Deps) => Src | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: Ctx) => Src;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (context: Ctx) => Src);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: Deps) => Src;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (...args: Deps) => Src);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   */\n  export type DepsRequests<Deps extends any[]> = {\n    [K in keyof Deps]: ContextRequest<Deps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<Ctx extends ContextValues, Value, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, Value, Deps, Src, Seed>,\n): ContextValueSpec.ByProvider<Ctx, Src, Seed> {\n  if (byProvider(spec)) {\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: Ctx) {\n        return by(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n  if (isConstant<Src, Seed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: Ctx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<Ctx, Deps, Src, Seed>(spec)) {\n    if (selfInstance<Ctx, Deps, Src, Seed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: Ctx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: Ctx) {\n        return new DepType(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${spec}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>,\n): ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.IsConstant<Src, Seed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.ViaAlias<Src, Seed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrNull<Value>): Value | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrUndefined<Value>): Value | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts?: ContextRequest.OrFallback<Value>): Value;\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\ntype SeedFactory<Ctx extends ContextValues, Seed> = (this: void, context: Ctx) => Seed;\n\n/**\n * @internal\n */\ntype Seeding<Ctx extends ContextValues, Src, Seed> = [ContextSeeder<Ctx, Src, Seed>, SeedFactory<Ctx, Seed>];\n\n/**\n * A registry of context value providers.\n *\n * @typeparam Ctx  Context type.\n */\nexport class ContextRegistry<Ctx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _initial: ContextSeeds<Ctx>;\n\n  /** @internal */\n  private readonly _seeds = new Map<ContextSeedKey<any, any>, Seeding<Ctx, any, any>>();\n\n  /** @internal */\n  private _nonCachedValues?: ContextValues;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<Ctx> | ContextValues) {\n    if (initial == null) {\n      this._initial = noop;\n    } else if (typeof initial === 'function') {\n      this._initial = initial;\n    } else {\n      this._initial = seedKey => initial.get(seedKey);\n    }\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<Deps extends any[], Src, Seed>(spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeding<Src, Seed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * @internal\n   */\n  private _seeding<Src, Seed>(seedKey: ContextSeedKey<Src, Seed>): Seeding<Ctx, Src, Seed> {\n\n    const found: Seeding<Ctx, Src, Seed> | undefined = this._seeds.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<Ctx, Src, Seed> = seedKey.seeder();\n    const factory: SeedFactory<Ctx, Seed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seeding: Seeding<Ctx, Src, Seed> = [seeder, factory];\n\n    this._seeds.set(seedKey, seeding);\n\n    return seeding;\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<Src, Seed>(context: Ctx, key: ContextSeedKey<Src, Seed>): Seed {\n\n    const [, factory] = this._seeding(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: Ctx, cache?: boolean): <Src, Seed>(this: void, key: ContextSeedKey<Src, Seed>) => Seed | undefined {\n    return this.newValues(cache).get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(cache = true): ContextValues & ThisType<Ctx> {\n    if (!cache && this._nonCachedValues) {\n      return this._nonCachedValues;\n    }\n\n    const values = new Map<ContextKey<any>, any>();\n    const registry = this;\n\n    class Values extends ContextValues {\n\n      get<Value, Src>(\n          this: Ctx,\n          { [ContextKey__symbol]: key }: ContextRef<Value, Src>,\n          opts?: ContextRequest.Opts<Value>,\n      ): Value | null | undefined {\n\n        const context = this;\n        const cached: Value | undefined = values.get(key);\n\n        if (cached != null) {\n          return cached;\n        }\n\n        const [constructed, defaultUsed] = growValue(context, key, opts);\n\n        if (cache && !defaultUsed) {\n          values.set(key, constructed);\n        }\n\n        return constructed;\n      }\n\n    }\n\n    if (!cache) {\n      return this._nonCachedValues = new Values();\n    }\n\n    return new Values();\n\n    function growValue<Value, Src, Seed>(\n        context: Ctx,\n        key: ContextKey<Value, Src, Seed>,\n        opts: ContextRequest.Opts<Value> | undefined,\n    ): [Value | null | undefined, boolean] {\n\n      const [seeder, seed] = findSeed<Src, Seed>(context, key);\n      let defaultUsed = false;\n\n      const valueOpts: {\n        -readonly [K in keyof ContextValueOpts<Ctx, Value, Src, Seed>]: ContextValueOpts<Ctx, Value, Src, Seed>[K];\n      } = {\n        context,\n        seeder,\n        seed,\n        byDefault: (opts && 'or' in opts)\n            ? () => {\n              defaultUsed = true;\n              return opts.or;\n            }\n            : defaultProvider => {\n\n              const defaultValue = defaultProvider();\n\n              if (defaultValue == null) {\n                throw new ContextKeyError(key);\n              }\n\n              return defaultValue;\n            },\n      };\n\n      if (opts && 'or' in opts) {\n        valueOpts.or = opts.or;\n      }\n\n      return [\n        key.grow(valueOpts),\n        defaultUsed,\n      ];\n    }\n\n    function findSeed<Src, Seed>(\n        context: Ctx,\n        key: ContextKey<any, Src, Seed>,\n    ): [ContextSeeder<Ctx, Src, Seed>, Seed] {\n\n      const { seedKey } = key;\n      const [seeder, factory] = registry._seeding(seedKey);\n\n      if (seedKey !== key as any) {\n        // This is not a seed key\n        // Retrieve the seed by seed key\n        return [seeder, context.get(seedKey)];\n      }\n\n      return [seeder, factory(context)];\n    }\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<Ctx>): ContextRegistry<Ctx> {\n    return new ContextRegistry(<Src, Seed>(key: ContextSeedKey<Src, Seed>, context: Ctx) => {\n\n      const [seeder, factory] = this._seeding(key);\n\n      return seeder.combine(factory(context), other.seed(context, key), context);\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values\n */\nimport { AIterable, itsEmpty, itsLast, overArray, overNone } from 'a-iterable';\nimport { asis, isPresent, noop, valuesProvider } from 'call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\nclass SimpleContextSeeder<Ctx extends ContextValues, Src> implements ContextSeeder<Ctx, Src, AIterable<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.push(provider);\n    return () => {\n\n      const found = this._providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AIterable<Src> = AIterable.from(overNone())): AIterable<Src> {\n    return AIterable.from([\n      initial,\n      sourceValues(context, this._providers),\n    ]).flatMap(asis);\n  }\n\n  isEmpty(seed: AIterable<Src>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: AIterable<Src>, second: AIterable<Src>): AIterable<Src> {\n    return AIterable.from([first, second]).flatMap(asis);\n  }\n\n}\n\nclass SimpleSeedKey<Src> extends ContextSeedKey<Src, AIterable<Src>> {\n\n  seeder<Ctx extends ContextValues>(): SimpleContextSeeder<Ctx, Src> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects value sources into iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class SimpleContextKey<Value, Src = Value> extends ContextKey<Value, Src, AIterable<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, AIterable<Src>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, AIterable<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\n/**\n * Single context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextRef<Value> = ContextRef<Value, Value>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextKey<Value>\n    extends SimpleContextKey<Value>\n    implements SingleContextRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextKey<Value>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value, AIterable<Value>>;\n        byDefault?: ContextKeyDefault<Value, ContextKey<Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, Value, Value, AIterable<Value>>,\n  ): Value | null | undefined {\n\n    const value = itsLast(opts.seed);\n\n    if (value != null) {\n      return value;\n    }\n\n    return opts.byDefault(() => this.byDefault(opts.context, this));\n  }\n\n}\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport type MultiContextRef<Src> = ContextRef<readonly Src[], Src>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport class MultiContextKey<Src>\n    extends SimpleContextKey<readonly Src[], Src>\n    implements MultiContextRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<Src, AIterable<Src>>;\n        byDefault?: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, readonly Src[], Src, AIterable<Src>>,\n  ): readonly Src[] | null | undefined {\n\n    const result = Array.from(opts.seed);\n\n    if (result.length) {\n      return result;\n    }\n\n    return opts.byDefault(() => {\n\n      const defaultSources = this.byDefault(opts.context, this);\n\n      if (defaultSources) {\n        return Array.from(defaultSources);\n      }\n\n      return;\n    });\n  }\n\n}\n\n/**\n * Context value provider and cached context value source.\n *\n * @internal\n */\ntype SourceEntry<Ctx extends ContextValues, Src> = [ContextValueProvider<Ctx, Src>, (Src | null | undefined)?];\n\n/**\n * @internal\n */\nfunction sourceValues<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providers: ContextValueProvider<Ctx, Src>[],\n): AIterable<Src> {\n  return AIterable.from(overArray(providers.map<SourceEntry<Ctx, Src>>(provider => [provider])))\n      .map(entry => {\n        if (entry.length > 1) {\n          return entry[1];\n        }\n\n        const source = entry[0](context);\n\n        entry.push(source);\n\n        return source;\n      })\n      .filter<Src>(isPresent);\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { AfterEvent } from '../after-event';\n\n/**\n * A key of [[EventKeeper]] method returning its [[AfterEvent]] instance..\n *\n * @category Core\n */\nexport const AfterEvent__symbol = (/*#__PURE__*/ Symbol('after-event'));\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<E extends any[]> {\n\n  /**\n   * Returns an [[AfterEvent]] instance of this event keeper.\n   *\n   * @returns [[AfterEvent]] instance registering event receivers sent by this keeper.\n   */\n  [AfterEvent__symbol](): AfterEvent<E>;\n\n}\n\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeparam T  Target event keeper.\n   */\n  export type Event<T extends EventKeeper<any>> = T extends EventKeeper<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventKeeper]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains an [[AfterEvent__symbol]] property, or `false` otherwise.\n */\nexport function isEventKeeper<E extends any[]>(value: object): value is EventKeeper<E> {\n  return AfterEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\n\n/**\n * A key of [[EventSupplyPeer]] property containing [[EventSupply]] instance.\n *\n * @category Core\n */\nexport const EventSupply__symbol = (/*#__PURE__*/ Symbol('events-supply'));\n\n/**\n * A supply of events from {@link EventSupplier event supplier} to {@link EventReceiver event receiver}.\n *\n * When no longer needed the supply may be {@link off cut off}.\n *\n * May be constructed using [[eventSupply]] function.\n *\n * @category Core\n */\nexport class EventSupply implements EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _off: (reason?: any) => void;\n\n  /**\n   * @internal\n   */\n  private _whenOff: (callback: (reason?: any) => void) => void;\n\n  constructor(off: (this: void, reason?: any) => void = noop) {\n    this._off = reason => {\n      this._whenOff = callback => callback(reason);\n      this._off = noop;\n      off(reason);\n    };\n    this._whenOff = callback => {\n\n      const prev = this._off;\n\n      this._off = reason => {\n        prev(reason);\n        callback(reason);\n      };\n    };\n  }\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means the events will no longer be supplied.\n   */\n  get isOff(): boolean {\n    return this._off === noop;\n  }\n\n  /**\n   * `this` event supply.\n   */\n  get [EventSupply__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Cuts off the supply of events.\n   *\n   * After this method call the receiver will no longer receive events.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason  An optional reason why supply is cut off. It will be reported to [[whenOff]] callbacks.\n   * @returns A cut off event supply instance.\n   */\n  off(reason?: any): EventSupply {\n    this._off(reason);\n    return this;\n  }\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if [[isOff]] is `true`.\n   *\n   * @param callback  A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means normal completion.\n   *\n   * @returns `this` instance.\n   */\n  whenOff(callback: (this: void, reason?: any) => void): this {\n    this._whenOff(callback);\n    return this;\n  }\n\n  /**\n   * Makes another event supply depend on this one.\n   *\n   * Once this supply is {@link off cut off}, `another` one is cut off with the same reason.\n   *\n   * Calling this method has the same effect as calling {@link needs eventSupplyOf(another).need(this)}.\n   *\n   * @param another  A peer of event supply to make depend on this one.\n   *\n   * @returns `this` instance.\n   */\n  cuts(another: EventSupplyPeer): this {\n    eventSupplyOf(another).needs(this);\n    return this;\n  }\n\n  /**\n   * Declares this event supply depends on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one is will be cut off with the same reason.\n   *\n   * @param another  A peer of event supply this one depends on.\n   *\n   * @returns `this` instance.\n   */\n  needs(another: EventSupplyPeer): this {\n    eventSupplyOf(another).whenOff(reason => this._off(reason));\n    return this;\n  }\n\n}\n\n/**\n * A peer of event supply.\n *\n * Contains an [[EventSupply]] that can be extracted by [[eventSupplyOf]] function.\n *\n * To be implemented by objects that controls event supply. An [[EventSupply]] is a peer of itself.\n *\n * @category Core\n */\nexport interface EventSupplyPeer {\n\n  /**\n   * An event supply of this peer.\n   */\n  readonly [EventSupply__symbol]: EventSupply;\n\n}\n\n/**\n * Extracts an event supply from its peer.\n *\n * @category Core\n * @param peer  A peer of event supply.\n *\n * @returns Extracted event supply contained in [[EventSupply__symbol]] property.\n */\nexport function eventSupplyOf(peer: EventSupplyPeer): EventSupply {\n  return peer[EventSupply__symbol];\n}\n\n/**\n * Constructs new {@link EventSupply event supply}.\n *\n * @category Core\n * @param off  A function to call when supply will supply is {@link EventSupply.off cut off}. Accepts optional\n * cut off reason as its only parameter. No-op by default.\n */\nexport function eventSupply(off?: (this: void, reason?: any) => void): EventSupply {\n  return new EventSupply(off);\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { eventSupply, EventSupply } from './event-supply';\n\n/**\n * Event receiver is called on each event sent by [[EventSender]] when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of [[EventReceiver.Object.receive]] method.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<E extends any[]> = EventReceiver.Function<E> | EventReceiver.Object<E>;\n\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<E extends any[]> =\n  /**\n   * @param event  An event represented by function call arguments.\n   */\n      (this: void, ...event: E) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<E extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link EventSupply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: EventSupply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context  An event processing context.\n     * @param event  An event represented as the rest of arguments.\n     */\n    receive(context: Context<E>, ...event: E): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by [[eventReceiver]] function.\n   *\n   * In contrast to [[Object]] this one always has a supply.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<E extends any[]> extends Object<E> {\n\n    readonly supply: EventSupply;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to [[Object]] receivers.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<E extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver  Recurrent events receiver function.\n     */\n    onRecurrent(receiver: Function<E>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n * @param receiver  An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<E extends any[]>(receiver: EventReceiver<E>): EventReceiver.Generic<E> {\n\n  let generic: {\n    readonly supply: EventSupply;\n    receive: (context: EventReceiver.Context<E>, ...event: E) => void;\n  };\n\n  if (typeof receiver === 'function') {\n    generic = {\n      supply: eventSupply(),\n      receive(_context, ...event) {\n        receiver(...event);\n      },\n    };\n  } else {\n    generic = {\n      supply: receiver.supply || eventSupply(),\n      receive(context, ...event) {\n        if (!this.supply.isOff) {\n          // Supply cut off callback may be called before the receiver disabled.\n          // Such callback may send an event that should not be received.\n          receiver.receive(context, ...event);\n        }\n      },\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  generic.supply.whenOff(() => generic.receive = noop);\n\n  return generic;\n}\n","import { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @internal\n * @param receivers  An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nexport function receiveByEach<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n): (this: void, ...event: E) => void {\n\n  let send: (this: void, event: E) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: E): void {\n\n    let actualReceivers = receivers;\n    const received: E[] = [];\n\n    send = (recurrent: E) => received.push(recurrent);\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n  }\n}\n\nfunction processEvent<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n    event: E,\n): EventReceiver.Generic<E>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<E>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<E> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { eventSupply, EventSupply, EventSupply__symbol, eventSupplyOf, EventSupplyPeer } from './event-supply';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an [[EventSender]] interface though. Use an [[EventEmitter]] if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link EventSupply.off cut off}.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<E extends any[]> implements EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _rcs?: Set<EventReceiver.Generic<E>>;\n\n  readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event  An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: E) => void;\n\n  constructor() {\n\n    const rcs = this._rcs = new Set<EventReceiver.Generic<E>>();\n\n    this.send = receiveByEach(rcs);\n    this[EventSupply__symbol] = eventSupply(() => {\n      rcs.clear();\n      delete this._rcs;\n    });\n  }\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcs ? this._rcs.size : 0;\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<E>): EventSupply {\n\n    const generic = eventReceiver(receiver);\n    const supply = generic.supply.needs(this);\n    const { _rcs } = this;\n\n    if (_rcs && !supply.isOff) {\n      _rcs.add(generic);\n      supply.whenOff(() => _rcs.delete(generic));\n    }\n\n    return supply;\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive any events. While new receivers would be cut off immediately upon\n   * registration.\n   *\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { OnEvent } from '../on-event';\n\n/**\n * A key of [[EventSender]] method returning its [[OnEvent]] instance.\n *\n * @category Core\n */\nexport const OnEvent__symbol = (/*#__PURE__*/ Symbol('on-event'));\n\n/**\n * A sender of events.\n *\n * Contains an [[OnEvent]] instance registering event receivers.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<E extends any[]> {\n\n  /**\n   * Returns an [[OnEvent]] instance of this event sender.\n   *\n   * @returns [[OnEvent]] instance registering event receivers sent by this sender.\n   */\n  [OnEvent__symbol](): OnEvent<E>;\n\n}\n\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeparam T  Target event sender.\n   */\n  export type Event<T extends EventSender<any>> = T extends EventSender<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventSender]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains [[OnEvent__symbol]] property, or `false` otherwise.\n */\nexport function isEventSender<E extends any[]>(value: object): value is EventSender<E> {\n  return OnEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventSupply, eventSupplyOf, EventSupplyPeer } from './event-supply';\n\n/**\n * @internal\n */\nclass NoSupply extends EventSupply {\n\n  get isOff(): true {\n    return true;\n  }\n\n  off(): this {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n  cuts(another: EventSupplyPeer): this {\n    eventSupplyOf(another).off();\n    return this;\n  }\n\n  needs(): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst noSupply = (/*#__PURE__*/ new NoSupply());\n\n/**\n * Returns a no-event supply.\n *\n * @category Core\n *\n * @returns An event supply that is already cut off without any particular reason.\n */\nexport function noEventSupply(): EventSupply {\n  return noSupply;\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event sender targeted specific receiver.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n *\n * @param receiver  Target event receiver.\n *\n * @returns A function accepting events and sending them to target `receiver`.\n */\nexport function sendEventsTo<E extends any[]>(receiver: EventReceiver<E>): (this: void, ...event: E) => void {\n\n  const generic = eventReceiver(receiver);\n  let send: (...event: E) => void = receiveByEach([generic]);\n\n  generic.supply.whenOff(() => send = noop);\n\n  return (...event) => send(...event);\n}\n","import { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function once<E extends any[]>(\n    onSource: OnEvent<E>,\n): (receiver: EventReceiver.Generic<E>) => void {\n  return receiver => onSource.to({\n    supply: receiver.supply,\n    receive: (context, ...event) => {\n      receiver.receive(context, ...event);\n      receiver.supply.off();\n    },\n  });\n}\n","import { EventNotifier, EventReceiver, eventSupply, EventSupply, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function share<E extends any[]>(\n    onSource: OnEvent<E>,\n): (receiver: EventReceiver.Generic<E>) => void {\n\n  const shared = new EventNotifier<E>();\n  let sharedSupply: EventSupply;\n  let initialEvents: E[] | undefined;\n\n  return receiver => {\n    if (!shared.size) {\n      initialEvents = [];\n      sharedSupply = eventSupply(() => initialEvents = undefined);\n\n      onSource.to({\n        supply: sharedSupply,\n        receive(_ctx, ...event) {\n          if (initialEvents) {\n            if (shared.size) {\n              // More events received\n              // Stop sending initial ones\n              initialEvents = undefined;\n            } else {\n              // Record events received during first receiver registration\n              // to send them to all receivers until more event received\n              initialEvents.push(event);\n            }\n          }\n          shared.send(...event);\n        },\n      });\n    }\n\n    receiver.supply.needs(sharedSupply);\n    shared.on(receiver).whenOff((reason?: any) => {\n      if (!shared.size) {\n        sharedSupply.off(reason);\n      }\n    });\n\n    if (initialEvents) {\n      // Send initial events to just registered receiver\n\n      const dispatch = sendEventsTo(receiver);\n\n      initialEvents.forEach(event => dispatch(...event));\n    }\n  };\n}\n","import { isNextCall, NextCall__symbol, noop } from 'call-thru';\nimport { EventReceiver, EventSender, eventSupply, EventSupply, noEventSupply, OnEvent__symbol } from '../base';\nimport { OnEvent } from '../on-event';\nimport { OnEventCallChain } from '../passes';\n\n/**\n * @internal\n */\nexport function thru<E extends any[]>(\n    onSource: OnEvent<E>,\n    passes: ((...args: any[]) => any)[],\n): (receiver: EventReceiver.Generic<E>) => void {\n\n  interface ChainEntry {\n    readonly chain: OnEventCallChain;\n    supply: EventSupply;\n  }\n\n  return (receiver: EventReceiver.Generic<any>) => {\n\n    const chains: ChainEntry[] = [];\n\n    onSource.to({\n      supply: receiver.supply,\n      receive(context, ...event) {\n\n        const chain = (index: number, chainSupply: EventSupply): [OnEventCallChain, EventSupply] => {\n\n          const lastPass = index >= passes.length;\n\n          ++index;\n\n          const existing = chains[index];\n\n          if (existing) {\n\n            const prevSupply = existing.supply;\n\n            existing.supply = chainSupply;\n\n            return [existing.chain, prevSupply];\n          }\n\n          const pass = index < passes.length ? passes[index] : noop;\n\n          const entry: ChainEntry = {\n            chain: {\n              call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n                handleResult(fn(...args), args);\n              },\n              pass<A>(fn: (arg: A) => any, arg: A): void {\n                handleResult(fn(arg), [arg]);\n              },\n              skip(): void {\n                entry.supply.off();\n              },\n              onEvent<E extends any[]>(\n                  pass: (this: void, ...event: E) => void,\n                  sender: EventSender<E>,\n              ): void {\n\n                const supply = eventSupply().needs(entry.supply);\n\n                sender[OnEvent__symbol]().to({\n                  supply,\n                  receive(_context, ...event): void {\n                    handleResult(pass(...event), event, supply);\n                  },\n                });\n              },\n            },\n            supply: chainSupply,\n          };\n\n          chains[index] = entry;\n\n          return [entry.chain, noEventSupply()];\n\n          function handleResult(\n              callResult: any,\n              args: any[],\n              parentSupply = entry.supply,\n          ): void {\n\n            const [nextChain, prevSupply] = chain(index, eventSupply().needs(parentSupply));\n\n            try {\n              if (isNextCall(callResult)) {\n                callResult[NextCall__symbol](nextChain, pass);\n              } else if (lastPass) {\n                receiver.receive(context, ...args);\n              } else {\n                nextChain.pass(pass, callResult);\n              }\n            } finally {\n              prevSupply.off();\n            }\n          }\n        };\n\n        const [firstChain, prevSupply] = chain(0, eventSupply().needs(receiver.supply));\n\n        try {\n          firstChain.call(passes[0], event);\n        } finally {\n          prevSupply.off();\n        }\n      },\n    });\n  };\n}\n","import { EventReceiver, eventSupply, EventSupply, EventSupplyPeer } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function tillOff<E extends any[]>(\n    onSource: OnEvent<E>,\n    required: EventSupplyPeer,\n    dependentSupply?: EventSupply,\n): (receiver: EventReceiver.Generic<E>) => void {\n  return receiver => {\n    if (dependentSupply) {\n      onSource.to({\n        supply: eventSupply().needs(required).cuts(dependentSupply),\n        receive: (receiver.receive as Function).bind(receiver),\n      });\n    } else {\n      receiver.supply.needs(required);\n      onSource.to(receiver);\n    }\n  };\n}\n","import { EventReceiver } from '../index';\n\n/**\n * @internal\n */\nexport function neverReceiveBecause(reason?: any): (receiver: EventReceiver.Generic<any>) => void {\n  return ({ supply }) => supply.off(reason);\n}\n\n/**\n * @internal\n */\nexport function neverReceive({ supply }: EventReceiver.Generic<any>): void {\n  supply.off();\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport {\n  eventReceiver,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  EventSupplyPeer,\n  noEventSupply,\n  OnEvent__symbol,\n} from './base';\nimport { once, share, then, thru, tillOff } from './impl';\nimport { OnEventCallChain } from './passes';\nimport Args = OnEventCallChain.Args;\nimport Out = OnEventCallChain.Out;\n\n/**\n * An [[EventSender]] implementation able to register event receivers.\n *\n * The registered event receiver starts receiving upcoming events until the returned event supply is\n * {@link EventSupply.off cut off}.\n *\n * Contains additional event processing methods.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class OnEvent<E extends any[]> implements EventSender<E> {\n\n  /**\n   * Generic event receiver registration function. It will be called on each receiver registration,\n   * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n   */\n  protected readonly _on: (receiver: EventReceiver.Generic<E>) => void;\n\n  /**\n   * Constructs [[OnEvent]] instance.\n   *\n   * @param on  Generic event receiver registration function. It will be called on each receiver registration,\n   * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n   */\n  constructor(on: (receiver: EventReceiver.Generic<E>) => void) {\n    this._on = on;\n  }\n\n  /**\n   * Event receiver registration function of this sender.\n   *\n   * Delegates to [[OnEvent.to]] method.\n   */\n  get F(): OnEvent.Fn<E> {\n    return this.to.bind(this);\n  }\n\n  [OnEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Returns a reference to itself.\n   *\n   * @returns `this` instance.\n   */\n  to(): this;\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  to(receiver: EventReceiver<E>): EventSupply;\n\n  /**\n   * Either starts sending events to the given `receiver`, or returns a reference to itself.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns Either a supply of events from this sender to the given `receiver`, or `this` instance when `receiver`\n   * is omitted.\n   */\n  to(receiver?: EventReceiver<E>): this | EventSupply;\n\n  to(receiver?: EventReceiver<E>): this | EventSupply {\n    if (!receiver) {\n      return this;\n    }\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      this._on(generic);\n    }\n\n    return supply;\n  }\n\n  /**\n   * Attaches callbacks to the next event and/or supply cut off reason.\n   *\n   * This method makes event sender act as promise-like for the first parameter of the next event. Thus it is possible\n   * e.g. to use it in `await` expression.\n   *\n   * @param onEvent  The callback to execute when next event received.\n   * @param onCutOff  The callback to execute when supply is cut off before the next event received.\n   *\n   * @returns A Promise for the next event.\n   */\n  then<TResult1 = E extends [infer F, ...any[]] ? F : undefined, TResult2 = never>(\n      onEvent?: ((...event: E) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n      onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return then(this, onEvent, onCutOff);\n  }\n\n  /**\n   * Builds an [[OnEvent]] sender of events originated from this one that stops sending them to registered receiver\n   * after the first one.\n   *\n   * @returns Event sender.\n   */\n  once(): OnEvent<E>;\n\n  /**\n   * Registers a receiver of events originated from this sender that stops receiving them after the first one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of event.\n   */\n  once(receiver: EventReceiver<E>): EventSupply;\n\n  once(receiver?: EventReceiver<E>): OnEvent<E> | EventSupply {\n    return (this.once = onEventBy(once(this)).F)(receiver);\n  }\n\n  /**\n   * Builds an [[OnEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New event sender.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): OnEvent<E> {\n    return onEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Consumes events.\n   *\n   * @param consume  A function consuming events. This function may return a {@link EventSupplyPeer peer of event\n   * supply} when registers a nested event receiver. This supply will be cut off on new event, unless returned again.\n   *\n   * @returns An event supply that will stop consuming events once {@link EventSupply.off cut off}.\n   */\n  consume(consume: (...event: E) => EventSupplyPeer | void | undefined): EventSupply {\n\n    let consumerSupply = noEventSupply();\n\n    // Do not use `.cuts()` here as `consumerSupply` is mutable\n    const supply = eventSupply(reason => consumerSupply.off(reason));\n\n    this.to({\n      supply,\n      receive(_ctx, ...event: E) {\n\n        const prevSupply = consumerSupply;\n\n        try {\n          consumerSupply = eventSupplyOf(consume(...event) || noEventSupply());\n        } finally {\n          if (consumerSupply !== prevSupply) {\n            prevSupply.off();\n          }\n        }\n      },\n    });\n\n    return supply;\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender that shares events supply among all registered receivers.\n   *\n   * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * supplies do.\n   *\n   * @returns An [[OnEvent]] sender sharing a common supply of events originated from this sender.\n   */\n  share(): OnEvent<E> {\n    return onEventBy(share(this));\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `call-thru` library. The event receivers registered by resulting event sender\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes. The returned sender shares the supply\n   * of transformed events among receivers.\n   */\n  thru<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): OnEvent<Out<Return1>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): OnEvent<Out<Return2>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): OnEvent<Out<Return3>>;\n\n  thru(...passes: any[]): OnEvent<any[]> {\n    return (this as any).thru_(...passes).share();\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[OnEvent.thru]] one, except it does not share the supply of transformed events\n   * among receivers. This may be useful e.g. when the result will be further transformed anyway. It is wise to\n   * {@link share share} the supply of events from final result in this case.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes.\n   */\n  thru_<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): OnEvent<Out<Return1>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): OnEvent<Out<Return2>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): OnEvent<Out<Return3>>;\n\n  thru_(...passes: any[]): OnEvent<any[]> {\n    return onEventBy(thru(this, passes));\n  }\n\n}\n\nexport namespace OnEvent {\n\n  /**\n   * A signature of function registering receivers of events sent by event sender.\n   *\n   * When called without parameters it returns an [[OnEvent]] sender. When called with event receiver as parameter\n   * it returns a supply of events from that sender.\n   *\n   * Available as [[OnEvent.F]] property value.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Fn<E extends any[]> {\n\n    /**\n     * Returns the event sender.\n     *\n     * @returns [[OnEvent]] sender the events originated from.\n     */\n    (\n        this: void,\n    ): OnEvent<E>;\n\n    /**\n     * Registers a receiver of events sent by the sender.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns A supply of events from the sender to the given `receiver`.\n     */\n    (\n        this: void,\n        receiver: EventReceiver<E>,\n    ): EventSupply;\n\n    /**\n     * Either registers a receiver of events sent by the sender, or returns the sender itself.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns Either a supply of events from the sender to the given `receiver`, or [[OnEvent]] sender the events\n     * originated from when `receiver` is omitted.\n     */\n    (\n        this: void,\n        receiver?: EventReceiver<E>,\n    ): EventSupply | OnEvent<E>;\n\n  }\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[OnEvent]] sender.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An [[OnEvent]] sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n): OnEvent<E> {\n  return new OnEvent(register);\n}\n","import { EventReceiver, eventSupply } from '../base';\nimport { OnEvent } from '../on-event';\nimport { once } from './once';\n\nexport function then<E extends any[], TResult1 = E[0], TResult2 = never>(\n    onSource: OnEvent<E>,\n    onEvent?: ((...value: E) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n): Promise<TResult1 | TResult2> {\n  return new Promise((resolve, reject) => {\n    once(onSource)({\n      supply: onCutOff\n          ? eventSupply(reason => {\n            try {\n              resolve(onCutOff(reason));\n            } catch (e) {\n              reject(e);\n            }\n          })\n          : eventSupply(reject),\n      receive: onEvent\n          ? (_ctx, ...event) => {\n            try {\n              resolve(onEvent(...event));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          : ((_ctx: EventReceiver.Context<E>, event: E[0]) => resolve(event)) as any,\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  eventReceiver,\n  EventReceiver,\n  EventSupply,\n  eventSupply,\n  EventSupplyPeer,\n} from './base';\nimport { once, share, thru, tillOff } from './impl';\nimport { OnEvent } from './on-event';\nimport { OnEventCallChain } from './passes';\nimport Args = OnEventCallChain.Args;\nimport Out = OnEventCallChain.Out;\n\nfunction noEvent(): never {\n  throw new Error('No events to send');\n}\n\n/**\n * An [[EventKeeper]] implementation able to register the receivers of kept and upcoming events.\n *\n * The registered event receiver receives the kept event immediately upon registration, and all upcoming events\n * after that until the returned event supply is cut off.\n *\n * To convert a plain event receiver registration function to [[AfterEvent]] an [[afterEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class AfterEvent<E extends any[]> extends OnEvent<E> implements EventKeeper<E> {\n\n  /**\n   * @internal\n   */\n  private _last?: E;\n\n  /**\n   * @internal\n   */\n  private _rcn = 0;\n\n  /**\n   * @internal\n   */\n  private readonly _or: (this: void) => E;\n\n  /**\n   * Constructs [[AfterEvent]] instance.\n   *\n   * The event constructed by `or` will be sent to the registered first receiver, unless `register` function sends one.\n   *\n   * @param on  Generic event receiver registration function. It will be called on each receiver registration,\n   * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n   * @param or  A function creating fallback event. When omitted, the initial event is expected to be sent by\n   * `register` function. A receiver registration would lead to an error otherwise.\n   */\n  constructor(\n      on: (this: void, receiver: EventReceiver.Generic<E>) => void,\n      or: (this: void) => E = noEvent,\n  ) {\n    super(on);\n    this._or = or;\n  }\n\n  /**\n   * Event receiver registration function of this event keeper.\n   *\n   * Delegates to [[AfterEvent.to]] method.\n   */\n  get F(): AfterEvent.Fn<E> {\n    return this.to.bind(this);\n  }\n\n  [AfterEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Returns a reference to itself.\n   *\n   * @returns `this` instance.\n   */\n  to(): this;\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  to(receiver: EventReceiver<E>): EventSupply;\n\n  /**\n   * Either starts sending events to the given `receiver`, or returns a reference to itself.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns Either a supply of events from this keeper to the given `receiver`, or `this` instance when `receiver`\n   * is omitted.\n   */\n  to(receiver?: EventReceiver<E>): this | EventSupply;\n\n  to(receiver?: EventReceiver<E>): this | EventSupply {\n    if (!receiver) {\n      return this;\n    }\n\n    let dest: (context: EventReceiver.Context<E>, ...event: E) => void = noop;\n    const generic = eventReceiver(receiver);\n\n    if (generic.supply.isOff) {\n      return generic.supply;\n    }\n\n    const supply = eventSupply().needs(generic.supply);\n    let reported = false;\n\n    this._on({\n      supply,\n      receive: (context, ...event: E) => {\n        reported = true;\n        this._last = event;\n        dest(context, ...event);\n      },\n    });\n    ++this._rcn;\n\n    if (!supply.isOff || reported) {\n      generic.receive(\n          {\n            onRecurrent(recurrent) {\n              dest = (_context, ...event) => recurrent(...event);\n            },\n          },\n          ...(this._last || (this._last = this._or())),\n      );\n      dest = (context, ...event) => generic.receive(context, ...event);\n    }\n\n    supply.whenOff(reason => {\n      if (!--this._rcn) {\n        this._last = undefined;\n      }\n      generic.supply.off(reason);\n    });\n\n    return supply;\n  }\n\n  /**\n   * Builds an [[AfterEvent]] keeper of events originated from this one that stops sending them to registered receiver\n   * after the first one.\n   *\n   * @returns Event keeper.\n   */\n  once(): AfterEvent<E>;\n\n  /**\n   * Registers a receiver of events originated from this keeper that stops receiving them after the first one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of event.\n   */\n  once(receiver: EventReceiver<E>): EventSupply;\n\n  once(receiver?: EventReceiver<E>): AfterEvent<E> | EventSupply {\n    return (this.once = afterEventBy(once(this)).F)(receiver);\n  }\n\n  /**\n   * Builds an [[AfterEvent]] keeper that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New event keeper.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): AfterEvent<E> {\n    return afterEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper that shares events supply among all registered receivers.\n   *\n   * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * event supplies do.\n   *\n   * @returns An [[AfterEvent]] keeper sharing a common supply of events originating from this keeper.\n   */\n  share(): AfterEvent<E> {\n    return afterEventBy(share(this));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations.\n   *\n   * This does the same as [[thru]] method, but return [[AfterEvent]] keeper instead of [[OnEvent]] sender. This can\n   * not be done automatically, as not every transformation results to [[EventKeeper]]. E.g. when some events\n   * are filtered out.\n   *\n   * The passes are preformed by `call-thru` library. The event receivers registered by resulting event keeper\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes. The returned keeper shares the supply\n   * of transformed events among receivers.\n   */\n  keepThru<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): AfterEvent<Out<Return1>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AfterEvent<Out<Return2>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru(...passes: any[]): AfterEvent<any[]> {\n    return (this as any).keepThru_(...passes).share();\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[AfterEvent.keepThru]] one, except it does not share the supply of transformed\n   * events among receivers. This may be useful e.g. when the result will be further transformed anyway.\n   * It is wise to {@link AfterEvent.share share} the supply of events from final result in this case.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes.\n   */\n  keepThru_<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): AfterEvent<Out<Return1>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AfterEvent<Out<Return2>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_(...passes: any[]): AfterEvent<any[]> {\n    return afterEventBy(thru(this, passes as any));\n  }\n\n}\n\nexport namespace AfterEvent {\n\n  /**\n   * A signature of function registering receivers of events sent by event keeper.\n   *\n   * When called without parameters it returns an [[AfterEvent]] keeper. When called with event receiver as parameter\n   * it returns a supply of events from that keeper.\n   *\n   * Available as [[AfterEvent.F]] property value.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Fn<E extends any[]> {\n\n    /**\n     * Returns the event keeper.\n     *\n     * @returns [[AfterEvent]] keeper the events originated from.\n     */\n    (\n        this: void,\n    ): AfterEvent<E>;\n\n    /**\n     * Registers a receiver of events sent by the keeper.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns A supply of events from the keeper to the given `receiver`.\n     */\n    (\n        this: void,\n        receiver: EventReceiver<E>,\n    ): EventSupply;\n\n    /**\n     * Either registers a receiver of events sent by the keeper, or returns the keeper itself.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns Either a supply of events from the keeper to the given `receiver`, or [[AfterEvent]] keeper the events\n     * originated from when `receiver` is omitted.\n     */\n    (\n        this: void,\n        receiver?: EventReceiver<E>,\n    ): EventSupply | AfterEvent<E>;\n  }\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[AfterEvent]] keeper with a fallback.\n *\n * The event constructed by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return new AfterEvent(register, fallback);\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { EventSender, OnEvent__symbol } from '../base';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return afterEventBy(receiver => sender[OnEvent__symbol]().to(receiver), fallback);\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { AfterEvent } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventSupplier, isEventKeeper } from '../base';\nimport { afterSent } from './after-sent';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param keeper  A keeper of events.\n *\n * @returns An [[AfterEvent]] keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<E extends any[]>(keeper: EventKeeper<E>): AfterEvent<E>;\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `supplier`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `supplier` sends one.\n *\n * This is a synonym of [[afterSent]], unless `supplier` is an [[EventKeeper]].\n *\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param supplier  An event supplier.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `supplier`. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `supplier`, or `initial` one.\n */\nexport function afterSupplied<E extends any[]>(\n    supplier: EventSupplier<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E>;\n\nexport function afterSupplied<E extends any[]>(\n    supplier: EventSupplier<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return isEventKeeper(supplier) ? supplier[AfterEvent__symbol]() : afterSent(supplier, fallback);\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { afterSupplied } from './after-supplied';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeparam S  A type of `sources` map.\n * @param sources  A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each source keeper. Each event in this map has the\n * same key as its source keeper in `sources`.\n */\nexport function afterAll<S extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: S,\n): AfterEvent<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>,\n  ): void {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach((key: keyof S) => {\n      supply.needs(sources[key][AfterEvent__symbol]().to((...event) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(result);\n    }\n  }\n\n  function latestEvent(): [{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }] {\n\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach(\n        key => afterSupplied(sources[key]).once(\n            (...event) => result[key as keyof S] = event,\n        ),\n    );\n\n    return [result];\n  }\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { afterSupplied } from './after-supplied';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeparam E  A type of events sent by each source.\n * @param sources  An array of source event keepers.\n *\n * @returns An event keeper sending events received from each source keeper. Each event item is an event tuple\n * originated from source keeper under its index in `sources` array.\n */\nexport function afterEach<E extends any[]>(...sources: EventKeeper<E>[]): AfterEvent<E[]> {\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(receiver: EventReceiver.Generic<E[]>): void {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result: E[] = [];\n\n    sources.forEach((source, index) => {\n      supply.needs(source[AfterEvent__symbol]().to((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(...result);\n    }\n  }\n\n  function latestEvent(): E[] {\n\n    const result: E[] = [];\n\n    sources.forEach(\n        source => afterSupplied(source).once(\n            (...event) => result.push(event),\n        ),\n    );\n\n    return result;\n  }\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { AfterEvent, afterEventBy } from '../after-event';\n\n/**\n * Builds an [[AfterEvent]] keeper of the given `event`.\n *\n * @category Core\n * @param event  An event that will be sent to all receivers upon registration.\n *\n * @returns An [[AfterEvent]] keeper that always sends the given `event`.\n */\nexport function afterThe<E extends any[]>(...event: E): AfterEvent<E> {\n  return afterEventBy(noop, valueProvider(event));\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { NextCall, nextCall } from 'call-thru';\nimport { EventKeeper } from '../base';\nimport { afterSupplied } from '../keepers';\nimport { OnEventCallChain } from './on-event-call-chain';\n\n/**\n * Builds a next chained call of {@link OnEventCallChain} that calls the next pass with every event supplied by\n * the given keeper.\n *\n * The event supply from the given keeper will be cut off each time the call is applied.\n *\n * This differs from [[nextOnEvent]] when passing supplier implementing both [[EventSender]] and [[EventKeeper]]\n * interfaces such as [[ValueTracker]]. [[nextOnEvent]] would prefer the former, while this one would prefer the latter.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of argument types of the next pass.\n * @param keeper  A keeper of events to pass down the chain.\n *\n * @returns Next call passing events from the given `keeper`.\n */\nexport function nextAfterEvent<E extends any[]>(\n    keeper: EventKeeper<E>,\n): NextCall<OnEventCallChain, E> {\n  return nextCall((chain, pass) => chain.onEvent(pass, afterSupplied(keeper)));\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventNotifier, EventReceiver, EventSender, EventSupply, OnEvent__symbol } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Event emitter is a handy implementation of [[OnEvent]] sender.\n *\n * Extends [[EventNotifier]] by making its [[EventNotifier.on]] method implement an [[OnEvent]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<E extends any[]> extends EventNotifier<E> implements EventSender<E> {\n\n  /**\n   * Returns an [[OnEvent]] sender.\n   */\n  on(): OnEvent<E>;\n  on(receiver: EventReceiver<E>): EventSupply;\n  on(receiver?: EventReceiver<E>): OnEvent<E> | EventSupply {\n    return (this.on = onEventBy<E>(receiver => super.on(receiver)).F)(receiver);\n  }\n\n  [OnEvent__symbol](): OnEvent<E> {\n    return this.on();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { neverReceive } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * An [[OnEvent]] sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> = (/*#__PURE__*/ onEventBy(neverReceive));\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { AfterEvent__symbol, EventSupplier, isEventSender, OnEvent__symbol } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param supplier  An event supplier.\n *\n * @returns An [[OnEvent]] sender of events originated from the given `supplier`.\n */\nexport function onSupplied<E extends any[]>(supplier: EventSupplier<E>): OnEvent<E> {\n  return isEventSender(supplier) ? supplier[OnEvent__symbol]() : supplier[AfterEvent__symbol]();\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventReceiver, EventSupplier, eventSupply } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onNever } from './on-never';\nimport { onSupplied } from './on-supplied';\n\n/**\n * Builds an [[OnEvent]] sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param suppliers  Original event suppliers.\n *\n * @returns An [[OnEvent]] sender of all supplied events.\n */\nexport function onAny<E extends any[]>(...suppliers: EventSupplier<E>[]): OnEvent<E> {\n  if (!suppliers.length) {\n    return onNever;\n  }\n\n  return onEventBy<E>(receiver => {\n\n    const { supply } = receiver;\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any): void => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n    const receive = (context: EventReceiver.Context<E>, ...event: E): void => {\n      receiver.receive(context, ...event);\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier).to({\n          supply: eventSupply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  }).share();\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { nextArg } from 'call-thru';\nimport { EventSender, eventSupply, sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onAnyAsync } from './on-any-async';\nimport { onSupplied } from './on-supplied';\n\n/**\n * Builds an [[OnEvent]] sender of asynchronously resolved events originated from the given sender of unresolved events.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved in the same\n * order as they have been received. Possibly in batches, e.g. when events resolved out of order.\n *\n * The resulting events supply is cut if some of incoming event promises rejected. In this case the rejection reason\n * is used as a reason to cut off. If incoming events supply is cut off, then the resulting event supply will be cut off\n * too, but only after all incoming events resolved and sent.\n *\n * @category Core\n * @typeparam E  Resolved event type.\n * @param from  Unresolved events sender containing either events or their promises.\n *\n * @returns New `OnEvent` sender of resolved events.\n */\nexport function onAsync<E>(from: EventSender<[PromiseLike<E> | E]>): OnEvent<[E, ...E[]]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    const sourceSupply = eventSupply();\n    let numInProcess = 0;\n    const source = onSupplied(from)\n        .tillOff(supply, sourceSupply)\n        .thru_(event => {\n          ++numInProcess;\n          return nextArg(event);\n        });\n    let received: E[] = [];\n    let numSent = 1;\n    let numReceived = 0;\n\n    sourceSupply.whenOff(reason => {\n      if (!numInProcess) {\n        supply.off(reason);\n      }\n    });\n\n    onAnyAsync(source).to({\n      supply,\n      receive(_ctx, event, index) {\n\n        const i = index - numSent;\n\n        received[i] = event;\n        ++numReceived;\n        if (numReceived > i) {\n\n          let toSend: E[];\n\n          if (numReceived === received.length) {\n            // Can send all received events\n            toSend = received;\n            received = [];\n          } else {\n            // Can send events up to `i`\n            toSend = received.splice(0, i + 1);\n          }\n          numSent += toSend.length;\n          numReceived -= toSend.length;\n          numInProcess -= toSend.length;\n\n          dispatch(...(toSend as [E, ...E[]]));\n          if (!numInProcess && sourceSupply.isOff) {\n            receiver.supply.needs(sourceSupply);\n          }\n        }\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventSender, OnEvent__symbol, sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of any of asynchronously resolved events originated from the given sender of\n * unresolved events.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved. The original\n * order of events is not preserved. Instead each resolved event is sent along with its index in original order.\n *\n * The resulting events supply is cut off immediately once unresolved events supply is cut off, or some of incoming\n * event promises rejected. In the latter case the rejection reason is used as a reason to cut off.\n *\n * @category Core\n * @typeparam E  Resolved event type.\n * @param from  Unresolved events sender containing either events or their promises.\n *\n * @returns New `OnEvent` sender of resolved events and their indices in original order starting from `1`.\n */\nexport function onAnyAsync<E>(from: EventSender<[PromiseLike<E> | E]>): OnEvent<[E, number]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    let lastIndex = 0;\n\n    from[OnEvent__symbol]().to({\n      supply,\n      receive(_ctx, promise) {\n\n        const index = ++lastIndex;\n\n        Promise.resolve()\n            .then(() => promise)\n            .then(\n                event => dispatch(event, index),\n                reason => supply.off(reason),\n            );\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\n/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @param key  A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<K extends PropertyKey>(key: K): [K];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path  Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return Array.isArray(path) ? path : [path];\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { noop } from 'call-thru';\nimport { EventSender, eventSupply, EventSupply, OnEvent__symbol } from '../base';\nimport { onEventBy } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n      path = statePath(path);\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): EventSupply {\n\n    const supply = this.emitter.on(receiver);\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      this._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: any): void {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.done(reason);\n  }\n\n  private _remove(key: PropertyKey): void {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty(): void {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): EventSupply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<V>(path: StatePath.Normalized, newValue: V, oldValue: V): void {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: any): void {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void = (<V>(path: StatePath, newValue: V, oldValue: V) => {\n    this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n  });\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n  }\n\n  get _tracker(): this {\n    return this;\n  }\n\n  onUpdate(): OnStateUpdate;\n  onUpdate(receiver: StateUpdateReceiver): EventSupply;\n  onUpdate(receiver?: StateUpdateReceiver): OnStateUpdate | EventSupply {\n    return (this.onUpdate = onEventBy<[StatePath, any, any]>(\n        receiver => this._trackers.on(this._path, receiver),\n    ).F as OnStateUpdate.Fn)(receiver);\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate();\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: any): void {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under [[StatePath]].\n *\n * When node modified a [[StateTracker.update]] should be called. Then all state update receivers registered by\n * [[StateTracker.onUpdate]] will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * Builds a {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns State updates sender.\n   */\n  onUpdate(): OnStateUpdate;\n\n  /**\n   * Registers a receiver of state updates.\n   *\n   * @param receiver State updates receiver to register.\n   *\n   * @returns A supply of state updates.\n   */\n  onUpdate(receiver: StateUpdateReceiver): EventSupply;\n\n  onUpdate(receiver?: StateUpdateReceiver): OnStateUpdate | EventSupply {\n    return (this.onUpdate = this._tracker.onUpdate().F)(receiver);\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate();\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with [[onUpdate]] will receive this update.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  get update(): <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path  A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason  An optional reason to stop tracking.\n   */\n  done(reason?: any): void {\n    this._tracker.done(reason);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  EventSupplyPeer,\n  isEventKeeper,\n  noEventSupply,\n  OnEvent__symbol,\n} from '../base';\nimport { OnEvent } from '../on-event';\nimport { onSupplied } from '../senders';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an [[EventSender]] interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an [[EventKeeper]] interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeparam T  Tracked value type.\n */\nexport abstract class ValueTracker<T = any> implements EventSender<[T, T]>, EventKeeper<[T]>, EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _by = noEventSupply();\n\n  /**\n   * Returns [[OnEvent]] sender of value changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Value changes sender.\n   */\n  abstract on(): OnEvent<[T, T]>;\n\n  /**\n   * Registers a receiver of value changes.\n   *\n   * The new value is sent as first argument, and the old value as a second one.\n   *\n   * @param receiver  A receiver to register.\n   *\n   * @returns A supply of value changes.\n   */\n  abstract on(receiver: EventReceiver<[T, T]>): EventSupply;\n\n  /**\n   * Builds an [[AfterEvent]] keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Current value keeper.\n   */\n  read(): AfterEvent<[T]>;\n\n  /**\n   * Registers a receiver of current values.\n   *\n   * @param receiver  A receiver to register.\n   *\n   * @returns A supply of current value.\n   */\n  read(receiver: EventReceiver<[T]>): EventSupply;\n\n  read(receiver?: EventReceiver<[T]>): AfterEvent<[T]> | EventSupply {\n    return (this.read = afterEventBy<[T]>(\n        receiver => this.on(receiveNewValue(receiver)),\n        () => [this.it],\n    ).F)(receiver);\n  }\n\n  [OnEvent__symbol](): OnEvent<[T, T]> {\n    return this.on();\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read();\n  }\n\n  /**\n   * An event supply of this value tracker.\n   */\n  abstract readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier  The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeparam S  Source value type.\n   * @param supplier  The event supplier to extract value suppliers from.\n   * @param extract  A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<S extends any[]>(\n      supplier: EventSupplier<S>,\n      extract: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<S extends any[]>(\n      supplier: EventSupplier<S> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const acceptValuesFrom = (sender: EventSupplier<[T]>): EventSupply => {\n\n      const onValue = isEventKeeper(sender) ? sender[AfterEvent__symbol]() : sender[OnEvent__symbol]();\n\n      return onValue.to(value => this.it = value);\n    };\n\n    this.byNone();\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<S>;\n\n      this._by = onSupplied(container).consume((...event: S) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      });\n    }\n\n    this._by.whenOff(() => this._by = noEventSupply());\n\n    return this;\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason  Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive events.\n\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction receiveNewValue<T, N extends T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[N, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport { EventKeeper, EventReceiver, EventSupply, EventSupply__symbol, eventSupplyOf } from '../base';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * @internal\n */\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._on);\n  }\n\n  on(): OnEvent<[T, T]>;\n  on(receiver: EventReceiver<[T, T]>): EventSupply;\n  on(receiver?: EventReceiver<[T, T]>): OnEvent<[T, T]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier  The source value keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventKeeper<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value keepers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeparam S  Source value type.\n * @param supplier  The event keeper to extract value keepers from.\n * @param extract  A function extracting value keeper from event received from `supplier`.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S>,\n    extract: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S> | EventKeeper<[T]>,\n    extract?: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T> {\n  return (trackValue() as any).by(supplier, extract);\n}\n","/**\n * @packageDocumentation\n * @module fun-events\n */\nimport {\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n} from '../base';\nimport { afterSupplied } from '../keepers';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter, onSupplied } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * Synchronizes tracked values with each other.\n *\n * Any change to any of the added tracked values would update all the others.\n *\n * @category Value Tracking\n */\nexport class ValueSync<T> extends ValueTracker<T> {\n\n  /**\n   * @internal\n   */\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  /**\n   * @internal\n   */\n  private _it: T;\n\n  constructor(initial: T) {\n    super();\n    this._it = initial;\n  }\n\n  on(): OnEvent<[T, T]>;\n  on(receiver: EventReceiver<[T, T]>): EventSupply;\n  on(receiver?: EventReceiver<[T, T]>): OnEvent<[T, T]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._on);\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const old = this.it;\n\n    if (old !== value) {\n      this._it = value;\n      this._on.send(value, old);\n    }\n  }\n\n  /**\n   * Synchronizes the tracked value with the others.\n   *\n   * Applies the value from this sync to the given tracker first.\n   *\n   * @param tracker  A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync(tracker: ValueTracker<T>): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the others in the given direction.\n   *\n   * @param direction  If set to `\"in\"` the value from the given tracker takes precedence over the one in [[ValueSync]].\n   * Otherwise the value from the sync is applied to the given tracker first.\n   * @param tracker  A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync(direction: 'in' | 'out', tracker: ValueTracker<T>): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * Applies the value from this sync to extracted trackers.\n   *\n   * @param supplier  The event supplier to extract value trackers from.\n   * @param extract  A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync<U extends any[]>(\n      supplier: EventSupplier<U>,\n      extract: (this: void, ...event: U) => ValueTracker<T> | undefined,\n  ): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`\n   * in the given direction.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * @param direction  If set to `\"in\"` the value from extracted tracker takes precedence over the one in\n   * [[ValueSync]]. Otherwise the value from the sync is applied to extracted trackers first.\n   * @param supplier  The event supplier to extract value trackers from.\n   * @param extract  A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync<U extends any[]>(\n      direction: 'in' | 'out',\n      supplier: EventSupplier<U>,\n      extract: (this: void, ...event: U) => ValueTracker<T> | undefined,\n  ): EventSupply;\n\n  sync<U extends any[]>(\n      first: 'in' | 'out' | ValueTracker<T> | EventSupplier<U>,\n      second?: ValueTracker<T>\n          | EventSender<U>\n          | EventKeeper<U>\n          | ((this: void, ...event: U) => ValueTracker<T> | undefined),\n      third?: (this: void, ...event: U) => ValueTracker<T> | undefined,\n  ): EventSupply {\n\n    let syncWithTracker = (tracker: ValueTracker<T>): EventSupply => syncTrackers(this, tracker);\n    let source: ValueTracker<T> | EventSupplier<U>;\n    let extract: ((this: void, ...event: U) => ValueTracker<T> | undefined) | undefined;\n\n    if (typeof first === 'string') {\n      if (first === 'in') {\n        syncWithTracker = tracker => syncTrackers(tracker, this);\n      }\n      source = second as ValueTracker<T> | EventSender<U> | EventKeeper<U>;\n      extract = third;\n    } else {\n      source = first;\n      extract = second as (this: void, ...event: U) => ValueTracker<T> | undefined;\n    }\n\n    const extractTracker = extract;\n\n    if (!extractTracker) {\n      return syncWithTracker(source as ValueTracker<T>);\n    }\n\n    const supplier = source as EventSupplier<U>;\n\n    return (isEventKeeper(supplier) ? afterSupplied(supplier) : onSupplied(supplier)).consume((...event) => {\n\n      const tracker = extractTracker(...event);\n\n      return tracker && syncWithTracker(tracker);\n    });\n\n    function syncTrackers(tracker1: ValueTracker<T>, tracker2: ValueTracker<T>): EventSupply {\n\n      const supply1 = tracker1.read(value => {\n        tracker2.it = value;\n      });\n      const supply2 = tracker2.on(value => {\n        tracker1.it = value;\n      });\n\n      return eventSupply(reason => {\n        supply2.off(reason);\n        supply1.off(reason);\n      }).needs(supply1).needs(supply2);\n    }\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { QualifiedName } from './name';\nimport { NamespaceDef } from './namespace';\nimport { NamespaceAliaser } from './namespace-aliaser';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\n\nclass DefaultNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}-${name}`;\n  }\n\n}\n\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const default__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const html__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\nclass XmlNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}:${name}`;\n  }\n\n}\n\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const xml__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const id__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\nclass CssNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${name}@${alias}`;\n  }\n\n}\n\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nexport const css__naming: Naming = (/*#__PURE__*/ new CssNaming());\n","/**\n * @module namespace-aliaser\n */\nimport { Naming } from './naming';\nimport { default__naming } from './namings';\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nexport class NamespaceDef {\n\n  /**\n   * Unique namespace URL.\n   */\n  readonly url: string;\n\n  /**\n   * Preferred namespace aliases.\n   */\n  readonly aliases: readonly string[];\n\n  /**\n   * The most preferred namespace alias.\n   *\n   * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n   */\n  get alias(): string {\n    return this.aliases[0] || 'ns';\n  }\n\n  /**\n   * Constructs new namespace definition.\n   *\n   * @param url  Unique namespace URL.\n   * @param aliases  Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n   * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n   * is reserved for [default namespace][[DEFAULT__NS]].\n   */\n  constructor(url: string, ...aliases: string[]) {\n    this.url = url;\n    this.aliases = aliases;\n  }\n\n  /**\n   * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n   *\n   * Calls [[Naming.applyAlias]] by default.\n   *\n   * @param alias  Namespace alias to apply to the name.\n   * @param name  A name to convert.\n   * @param naming  Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n   *\n   * @returns A simple name with this namespace alias applied.\n   */\n  name(alias: string, name: string, naming: Naming = default__naming): string {\n    return naming.applyAlias(name, alias, this);\n  }\n\n}\n","/**\n * @module namespace-aliaser\n */\nimport { DEFAULT__NS } from './default.ns';\nimport { NamespaceDef } from './namespace';\n\n/**\n * A name qualified with namespace.\n *\n * This can be either:\n * - a simple name string, which means a name in default namespace, or\n * - a name+namespace tuple.\n */\nexport type QualifiedName = string | NameAndNamespace;\n\n/**\n * A local name and namespace tuple.\n *\n * Consists of a local name string and namespace definition this name belongs to.\n */\nexport type NameAndNamespace = readonly [string, NamespaceDef];\n\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of [[NamespaceDef]]. Or `false` otherwise.\n */\nexport function isNameAndNamespace(value: any): value is NameAndNamespace {\n  return Array.isArray(value)\n      && value.length === 2\n      && typeof value[0] === 'string'\n      && value[1] instanceof NamespaceDef;\n}\n\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is a non-empty string or an array consisting of exactly two elements,\n * where the first element is a non-empty string, and the second element is an instance of [[NamespaceDef]].\n * Or `false` otherwise.\n */\nexport function isQualifiedName(value: any): value is QualifiedName {\n  return typeof value === 'string' || isNameAndNamespace(value);\n}\n\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name  Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function namespaceOf(name: QualifiedName): NamespaceDef {\n  return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name  Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function nameAndNamespace(name: QualifiedName): NameAndNamespace {\n  return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nexport function namesEqual(first: QualifiedName, second: QualifiedName): boolean {\n  if (typeof first === 'string') {\n    return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    return !firstUrl && firstName === second;\n  }\n\n  return firstName === second[0] && firstUrl === second[1].url;\n}\n\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nexport function compareNames(first: QualifiedName, second: QualifiedName): -1 | 0 | 1 {\n  if (typeof first === 'string') {\n    if (typeof second === 'string') {\n      return compareStrings(first, second);\n    }\n    if (!second[1].url) {\n      return compareStrings(first, second[0]);\n    }\n    return -1;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    if (!firstUrl) {\n      return compareStrings(firstName, second);\n    }\n    return 1;\n  }\n\n  return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n\nfunction compareStrings(first: string, second: string): -1 | 0 | 1 {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\n","/**\n * @module namespace-aliaser\n */\nimport { NamespaceDef } from './namespace';\n\n/**\n * Namespace aliaser function interface.\n *\n * Maps namespaces to their unique aliases.\n */\nexport type NamespaceAliaser =\n/**\n * @param ns  A definition of namespace to find alias for.\n *\n * @returns Namespace alias.\n */\n    (ns: NamespaceDef) => string;\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nexport function newNamespaceAliaser(): NamespaceAliaser {\n\n  const aliasesByNs = new Map<string, string>();\n  const nsNumPerAlias = new Map<string, number>();\n\n  return function nsAlias(ns: NamespaceDef): string {\n\n    const found = aliasesByNs.get(ns.url);\n\n    if (found) {\n      return found;\n    }\n\n    const mostPreferred = ns.alias;\n    let nsNumRegistered = 0;\n\n    for (const preferred of [mostPreferred, ...ns.aliases]) {\n\n      const ids = nsNumPerAlias.get(preferred);\n\n      if (!ids) {\n        aliasesByNs.set(ns.url, preferred);\n        nsNumPerAlias.set(preferred, 1);\n        return preferred;\n      }\n      if (!nsNumRegistered) {\n        // Use the first one\n        nsNumRegistered = ids;\n      }\n    }\n\n    const generated = mostPreferred + (++nsNumRegistered);\n\n    aliasesByNs.set(ns.url, generated);\n    nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n\n    return generated;\n  };\n}\n","/**\n * @packageDocumentation\n * @module context-values/updatable\n */\nimport { flatMapIt, mapIt, overArray } from 'a-iterable';\nimport { CallChain, nextArg, nextArgs, NextCall, noop } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { ContextKey, ContextKey__symbol, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextRef } from '../context-ref';\nimport { ContextSeeder } from '../context-seeder';\nimport { ContextValueProvider } from '../context-value-spec';\nimport { ContextValues } from '../context-values';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AfterEvent<Src[]> = afterThe<Src[]>()): AfterEvent<Src[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<Src[]>, second: AfterEvent<Src[]>): AfterEvent<Src[]> {\n    return afterEach(\n        first,\n        second,\n    ).keepThru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providersTracker: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]>,\n): AfterEvent<Src[]> {\n  return providersTracker.read().keepThru(\n      providers => !providers.length\n          ? nextArgs()\n          : nextAfterEvent(\n              afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overArray(providers),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n          ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<Src>(src: null | undefined | Src | EventKeeper<Src[]>): AfterEvent<Src[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<Src>(src: Src | EventKeeper<Src[]>): src is EventKeeper<Src[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as (object | Function));\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<Src>(...sources: Src[][]): NextCall<CallChain, Src[]> {\n  return nextArgs<Src[]>(...flatMapIt<Src>(sources));\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<Src> extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport interface ContextUpRef<Value, Src> extends ContextRef<Value, Src | EventKeeper<Src[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<Value, Src>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<Value, Src>\n    extends ContextKey<ContextUpKey.Up<Value>, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  get seedKey(): ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<Value, Src>,\n      readonly grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ) {\n    super(_key.name + ':up');\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class ContextUpKey<Value, Src>\n    extends ContextKey<Value, Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpRef<Value, Src> {\n\n  readonly seedKey: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[growUp]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<Value, Src>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ): ContextUpKey.UpKey<Value, Src> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeparam Value  Original context value type.\n   */\n  export type Up<Value> = Value extends AfterEvent<any>\n      ? Value\n      : (Value extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[Value]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   */\n  export type UpKey<Value, Src> = ContextKey<ContextUpKey.Up<Value>, Src>;\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextUpRef<Value> = ContextUpRef<AfterEvent<[Value]>, Value>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextUpKey<Value>\n    extends ContextUpKey<AfterEvent<[Value]>, Value>\n    implements SingleContextUpRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value | EventKeeper<Value[]>, AfterEvent<Value[]>>;\n        byDefault?: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<[Value]>, EventKeeper<Value[]> | Value, AfterEvent<Value[]>>,\n  ): AfterEvent<[Value]> {\n    return opts.seed.keepThru((...sources: Value[]) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return nextArg(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue && afterThe(defaultValue);\n      });\n\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<[Value]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n  }\n\n}\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Src  Source value type.\n */\nexport type MultiContextUpRef<Src> = ContextUpRef<AfterEvent<Src[]>, Src>;\n\n/**\n * Multiple updatable context values key.\n *\n * The associated value is an `AfterEvent` keeper of the source values. It is always present, even though\n * the array can be empty.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Src  Source value type.\n */\nexport class MultiContextUpKey<Src>\n    extends ContextUpKey<AfterEvent<Src[]>, Src>\n    implements MultiContextUpRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs multiple updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>;\n        byDefault?: ContextKeyDefault<readonly Src[], ContextUpKey<AfterEvent<Src[]>, Src>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<Src[]>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n  ): AfterEvent<Src[]> {\n    return opts.seed.keepThru((...sources) => {\n      if (sources.length) {\n        // Sources present. Use them.\n        return nextArgs(...sources);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue ? afterThe(...defaultValue) : afterThe();\n      });\n\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<Src[]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module context-values/updatable\n */\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { ContextKeyDefault, ContextSeedKey, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport type FnContextRef<Args extends any[], Ret = void> =\n    ContextUpRef<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport class FnContextKey<Args extends any[], Ret = void>\n    extends ContextUpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>\n    implements FnContextRef<Args, Ret> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<Args, Ret>) =>\n      (this: void, ...args: Args) => Ret;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<\n            ((this: void, ...args: Args) => Ret) | EventKeeper<((this: void, ...args: Args) => Ret)[]>,\n            AfterEvent<((this: void, ...args: Args) => Ret)[]>>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: Args) => Ret, FnContextKey<Args, Ret>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n                return fns[fns.length - 1];\n              }\n\n              const defaultProvider = (): AfterEvent<[(this: void, ...args: Args) => Ret]> => afterThe(this.byDefault(\n                  opts.context,\n                  this,\n              ));\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          (this: void, ...args: Args) => Ret,\n          EventKeeper<((this: void, ...args: Args) => Ret)[]> | ((this: void, ...args: Args) => Ret),\n          AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n  ): (this: void, ...args: Args) => Ret {\n\n    let delegated!: (this: void, ...args: Args) => Ret;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(fn => delegated = fn);\n\n    return (...args) => delegated(...args);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { RenderShot } from './render-shot';\n\n/**\n * Render schedule signature.\n *\n * This function accepts a {@link RenderShot render shot} to schedule. All scheduled render shots are meant to update\n * the same rendering target. If multiple render shots scheduled before execution starts, only the last one will be\n * executed to limit rendering rate.\n *\n * The render shot execution may fail. This should not prevent other scheduled or postponed render shots from being\n * executed. The render shot execution failure reason is expected to be reported with [[RenderScheduleConfig.error]]\n * method.\n *\n * Render schedules are constructed by {@link RenderScheduler render schedulers}, or by [[newRenderSchedule]] function\n * that uses the {@link setRenderScheduler default scheduler} for that.\n */\nexport type RenderSchedule =\n/**\n * @param shot  A render shot to schedule.\n */\n    (this: void, shot: RenderShot) => void;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link RenderScheduler render scheduler} when constructing new {@link RenderSchedule schedule}.\n *\n * A {@link RenderScheduleConfig render configuration} can be constructed based on the options with\n * [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleOptions {\n\n  /**\n   * A window for constructed schedule.\n   *\n   * Detected by [[nodeWindow]] by default, if [[node]] is specified. Falls back to current `window`.\n   *\n   * The schedulers that don't need a window never access this option value.\n   */\n  window?: Window;\n\n  /**\n   * A DOM node for constructed schedule.\n   *\n   * Used to detect missing [[window]] option.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * Reports errors with `console.error()` by default.\n   *\n   * @param messages  Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * Render schedule configuration.\n *\n * This is based on {@link RenderScheduleOptions render options}, but has all properties present.\n *\n * The configuration ought to be constructed out of render options by [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleConfig {\n\n  /**\n   * A window the schedule is constructed for.\n   *\n   * The schedulers that don't need a window should never access this option value.\n   */\n  window: Window;\n\n  /**\n   * A DOM node the schedule is constructed for.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * @param messages  Error messages to report.\n   */\n  error(...messages: any[]): void;\n\n}\n\nexport const RenderScheduleConfig = {\n\n  /**\n   * Constructs a configuration of render scheduler by its options.\n   *\n   * @param options  Render scheduler options the configuration should be base on.\n   */\n  by(this: void, options: RenderScheduleOptions = {}): RenderScheduleConfig {\n\n    let win: Window | undefined;\n\n    return {\n      get node() {\n        return options.node;\n      },\n      get window() {\n        return win || (win = options.window || (options.node && nodeWindow(options.node)) || window);\n      },\n      error(...messages) {\n        if (options && options.error) {\n          options.error(...messages);\n        } else {\n          console.error(...messages);\n        }\n      },\n    };\n  },\n\n};\n\n/**\n * Detects a window the given DOM node is attached to.\n *\n * @param node  Target DOM node.\n *\n * @returns A window of the owner document, or `null` if absent.\n */\nexport function nodeWindow(node: Node): Window | null {\n\n  const document = node.ownerDocument || node as Document;\n\n  return document.defaultView;\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { RenderQueue } from './render-queue';\nimport { RenderScheduleConfig } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to [[customRenderScheduler]] function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config  Render schedule configuration.\n   *\n   * @returns  A queue of scheduled render shots.\n   */\n  newQueue(config: RenderScheduleConfig): RenderQueue;\n\n}\n\n/**\n * @internal\n */\nconst RenderQ__symbol = Symbol('render-q');\n\n/**\n * @internal\n */\nclass RenderQ {\n\n  readonly ref: [RenderQ, RenderQ];\n  schedule: (this: RenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n\n  static by(queue: RenderQueue, ref?: [RenderQ, RenderQ]): RenderQ {\n    return (queue as any)[RenderQ__symbol]\n        || ((queue as any)[RenderQ__symbol] = new RenderQ(queue, ref));\n  }\n\n  private constructor(private readonly q: RenderQueue, ref?: [RenderQ, RenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this, this];\n  }\n\n  add(shot: RenderShot): void {\n    this.q.add(shot);\n  }\n\n  private doSchedule(config: RenderScheduleConfig): void {\n    this.schedule = () => {/* do not schedule */};\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.push(shot);\n      },\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n\n      next.suspend();\n      this.exec(execution);\n      // Activate next queue\n      this.ref[1] = this.ref[0];\n      // Execute postponed shots\n      postponed.forEach(execution.postpone = shot => this.q.add(shot));\n      this.exec(execution);\n      next.resume();\n    });\n  }\n\n  private exec(execution: RenderExecution): void {\n    for (; ;) {\n\n      const shot = this.q.pull();\n\n      if (!shot) {\n        break;\n      }\n      shot(execution);\n    }\n  }\n\n  private reset(): RenderQ {\n    // Update next queue. Current queue remains active\n    return this.ref[0] = RenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend(): void {\n    this.schedule = config => {\n      this.scheduled = config;\n      this.schedule = () => {/* do not schedule */};\n    };\n  }\n\n  private resume(): void {\n    if (this.scheduled) {\n      this.doSchedule(this.scheduled);\n    } else {\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options  Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return scheduleOptions => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef: readonly [RenderQ, RenderQ] = RenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [RenderQ, RenderShot, true?] | [] = [];\n\n    return shot => {\n\n      const [lastQueue,, executed] = enqueued;\n      const [nextQueue, activeQueue] = queueRef;\n      let queue = lastQueue || activeQueue;\n\n      if (lastQueue === activeQueue && !executed || lastQueue === nextQueue) {\n        enqueued[1] = shot;\n      } else {\n\n        // Add to active queue initially, unless a shot executed in it already.\n        // Add to the next queue otherwise.\n        const nextEnqueued: [RenderQ, RenderShot, true?] = enqueued = [\n          queue = executed ? nextQueue : activeQueue,\n          shot,\n        ];\n\n        queue.add((execution: RenderExecution) => {\n          nextEnqueued[2] = true; // Switch to next queue\n          try {\n            nextEnqueued[1]({\n              get config() {\n                return config;\n              },\n              postpone(postponed) {\n                execution.postpone(postponed);\n              },\n            });\n          } catch (e) {\n            config.error(e);\n          }\n        });\n      }\n\n      queue.schedule(config);\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { RenderShot } from './render-shot';\n\n/**\n * A queue of scheduled render shots.\n *\n * Utilized by render scheduler in order to collect render shots and schedule their execution.\n *\n * The default implementation may be constructed using [[RenderQueue.by]] function.\n */\nexport interface RenderQueue {\n\n  /**\n   * Adds a render shot to this queue.\n   *\n   * @param shot  Scheduled render shot to add.\n   */\n  add(shot: RenderShot): void;\n\n  /**\n   * Retrieves the first added render shot and removes it from the queue.\n   *\n   * @returns  Either pulled out render shot, or `undefined` when there is no more render shots.\n   */\n  pull(): RenderShot | undefined;\n\n  /**\n   * Schedules queued render shots execution.\n   *\n   * @param task  A function that performs render shots execution task.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled render shots from now on.\n   */\n  reset(): RenderQueue;\n\n}\n\nexport const RenderQueue = {\n\n  /**\n   * Builds the default implementation of render queue.\n   *\n   * @param schedule  Schedules queued render shots execution. This is an implementation of [[RenderQueue.schedule]]\n   * method.\n   * @param replace  Called right after [[RenderQueue.reset]] method in order to inform on the queue that will collect\n   * scheduled render shots from now.\n   *\n   * @returns New render queue.\n   */\n  by(\n      this: void,\n      {\n        schedule,\n        replace = () => {/* do not replace */},\n      }: {\n        schedule(this: RenderQueue, task: (this: void) => void): void;\n        replace?(this: void, replacement: RenderQueue): void;\n      },\n  ): RenderQueue {\n\n    const shots: RenderShot[] = [];\n\n    return {\n      schedule,\n      add(shot) {\n        shots.push(shot);\n      },\n      pull() {\n        return shots.shift();\n      },\n      reset() {\n\n        const next = RenderQueue.by({ schedule, replace });\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { customRenderScheduler } from './custom-render-scheduler';\nimport { RenderQueue } from './render-queue';\nimport { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nconst animationRenderQueues = (/*#__PURE__*/ new WeakMap<Window, RenderQueue>());\n\n/**\n * A render scheduler that executes scheduled render shots within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The render shots scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link RenderExecution.postpone postponed} render shots are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nexport const animationRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue({ window }) {\n\n    const existing = animationRenderQueues.get(window);\n\n    if (existing) {\n      return existing;\n    }\n\n    const newQueue = RenderQueue.by({\n      schedule: task => window.requestAnimationFrame(task),\n      replace: replacement => animationRenderQueues.set(window, replacement),\n    });\n\n    animationRenderQueues.set(window, newQueue);\n\n    return newQueue;\n  },\n}));\n","/**\n * @packageDocumentation\n * @module render-scheduler\n */\nimport { animationRenderScheduler } from './animation-render-scheduler';\nimport { RenderSchedule, RenderScheduleOptions } from './render-schedule';\n\n/**\n * Render scheduler signature.\n *\n * This function constructs a {@link RenderSchedule render schedule} according to the given options.\n *\n * The default render scheduler is always available as [[newRenderSchedule]] function.\n *\n * There are several scheduler implementations exist:\n * - [[animationRenderScheduler]] (used by default),\n * - [[asyncRenderScheduler]],\n * - [[immediateRenderScheduler]],\n * - [[ManualRenderScheduler]],\n * - [[noopRenderScheduler]].\n *\n * Custom scheduler implementations could be created using [[customRenderScheduler]] function.\n */\nexport type RenderScheduler =\n/**\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: RenderScheduleOptions) => RenderSchedule;\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler  New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nexport function setRenderScheduler(\n    scheduler?: RenderScheduler | null,\n): RenderScheduler {\n  return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nexport function newRenderSchedule(options?: RenderScheduleOptions): RenderSchedule {\n  return defaultRenderScheduler(options);\n}\n","/**\n * @packageDocumentation\n * @module fun-events/dom\n */\nimport { eventReceiver, EventReceiver, EventSupply, EventSupplyPeer } from '../base';\nimport { once, tillOff } from '../impl';\nimport { OnEvent } from '../on-event';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport type DomEventListener<E extends Event> = EventReceiver<[E]>;\n\n/**\n * An [[EventSender]] implementation able to register DOM event listeners.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport class OnDomEvent<E extends Event> extends OnEvent<[E]> {\n\n  /**\n   * DOM event listener registration function of this event sender.\n   *\n   * Delegates to [[OnDomEvent.to]] method.\n   */\n  get F(): OnDomEvent.Fn<E> {\n    return this.to.bind(this);\n  }\n\n  /**\n   * Returns a reference to itself.\n   *\n   * @returns `this` instance.\n   */\n  to(): this;\n\n  /**\n   * Starts sending DOM events to the given `listener`.\n   *\n   * @param listener  Target listener of DOM events.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events from this sender to the given `listener`.\n   */\n  to(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  /**\n   * Either starts sending DOM events to the given `listener`, or returns a reference to itself.\n   *\n   * @param listener  Target listener of DOM events.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns Either a supply of DOM events from this sender to the given `listener`, or `this` instance when `listener`\n   * is omitted.\n   */\n  to(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): this | EventSupply;\n\n  to(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): this | EventSupply {\n    if (!listener) {\n      return this;\n    }\n\n    const receiver = eventReceiver(listener);\n    const { supply } = receiver;\n\n    if (!supply.isOff) {\n      (this._on as (\n          this: void,\n          listener: EventReceiver.Generic<[E]>,\n          opts?: AddEventListenerOptions | boolean,\n      ) => void)(receiver, opts);\n    }\n\n    return supply;\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this one that stops sending them to registered receiver\n   * after the first one.\n   *\n   * @returns DOM event sender.\n   */\n  once(): OnDomEvent<E>;\n\n  /**\n   * Registers a listener of DOM events originated from this sender that stops receiving them after the first one.\n   *\n   * @param listener  A DOM event listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM event.\n   */\n  once(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  once(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.once = onDomEventBy(once(this)).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New DOM event sender.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): OnDomEvent<E> {\n    return onDomEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that enables event capturing by default.\n   *\n   * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n   * `EventTarget.addEventListener()`.\n   *\n   * @returns DOM events sender.\n   */\n  capture(): OnDomEvent<E>;\n\n  /**\n   * Registers a capturing listener of DOM events.\n   *\n   * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n   * `EventTarget.addEventListener()`.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  capture(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  capture(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.capture = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this.to(listener, true);\n      }\n      if (typeof opts === 'object' && opts.capture == null) {\n        return this.to(listener, { ...opts, capture: true });\n      }\n      return this.to(listener, opts);\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that registers listeners to invoke instead\n   * of the default action.\n   *\n   * It invokes an `Event.preventDefault()` method prior to calling the registered listener.\n   *\n   * @returns DOM events sender.\n   */\n  instead(): OnDomEvent<E>;\n\n  /**\n   * Registers a listener of DOM events to invoke instead of default action.\n   *\n   * This listener invokes an `Event.preventDefault()` method prior to event handling.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  instead(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  instead(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.instead = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this.to(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.preventDefault();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originate from this sender that registers listeners preventing further\n   * propagation of current event in the capturing and bubbling phases.\n   *\n   * It invokes an `Event.stopPropagation()` method prior to calling the registered listener.\n   *\n   * @returns DOM events sender.\n   */\n  just(): OnDomEvent<E>;\n\n  /**\n   * Registers a listener of DOM events preventing further propagation of current event in the capturing and bubbling\n   * phases.\n   *\n   * This listener invokes an `Event.stopPropagation()` method prior to event handling.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  just(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  just(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.just = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this.to(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopPropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that registers the last event listener.\n   *\n   * It invokes an `Event.stopImmediatePropagation()` method prior to calling the registered listener.\n   *\n   * @returns DOM event sender.\n   */\n  last(): OnDomEvent<E>;\n\n  /**\n   * Registers the last DOM event listener.\n   *\n   * This listener invokes an `Event.stopImmediatePropagation()` method prior to event handling.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  last(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  last(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.last = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this.to(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopImmediatePropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that accepts listeners never calling\n   * `Event.preventDefault()`.\n   *\n   * This corresponds to specifying `{ passive: true }` as a second argument to `EventTarget.addEventListener()`.\n   *\n   * @returns DOM event listener.\n   */\n  passive(): OnDomEvent<E>;\n\n  /**\n   * Registers a DOM event listener that never calls `Event.preventDefault()`.\n   *\n   * This corresponds to specifying `{ passive: true }` as a second argument to `EventTarget.addEventListener()`.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  passive(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  passive(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.passive = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this.to(listener, { passive: true });\n      }\n      if (typeof opts === 'boolean') {\n        return this.to(listener, { capture: opts, passive: true });\n      }\n      if (opts.passive == null) {\n        return this.to(listener, { ...opts, passive: true });\n      }\n      return this.to(listener, opts);\n    }).F)(listener, opts);\n  }\n\n}\n\nexport namespace OnDomEvent {\n\n  /**\n   * A signature of function registering listeners of DOM events sent by event sender.\n   *\n   * When called without parameters it returns an [[OnDomEvent]] sender. When called with DOM event listener\n   * as parameter it returns a supply of DOM events from that sender.\n   *\n   * Available as [[OnDomEvent.F]] property value.\n   *\n   * @typeparam E  Supported DOM event type.\n   */\n  export interface Fn<E extends Event> {\n\n    /**\n     * Returns the DOM events sender.\n     *\n     * @returns [[OnDomEvent]] sender the events originated from.\n     */\n    (\n        this: void,\n    ): OnDomEvent<E>;\n\n    /**\n     * Registers a listener of DOM events sent by the sender.\n     *\n     * @param listener  A listener of DOM events to register.\n     * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n     *\n     * @returns A supply of DOM events from the sender to the given `listener`.\n     */\n    (\n        this: void,\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ): EventSupply;\n\n    /**\n     * Either registers a listener of DOM events sent by the sender, or returns the sender itself.\n     *\n     * @param listener  A listener of DOM events to register.\n     * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n     *\n     * @returns Either a supply of DOM events from the sender to the given `listener`, or [[OnDomEvent]] sender\n     * the events originated from when `listener` is omitted.\n     */\n    (\n        this: void,\n        listener?: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ): EventSupply | OnDomEvent<E>;\n\n  }\n\n}\n\n/**\n * Converts a plain DOM event listener registration function to [[OnDomEvent]] sender.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n * @param register  A generic DOM event listener registration function.\n *\n * @returns An [[OnDomEvent]] sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<E extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[E]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<E> {\n  return new OnDomEvent(register);\n}\n","/**\n * @packageDocumentation\n * @module fun-events/dom\n */\nimport { noop } from 'call-thru';\nimport { EventReceiver, eventSupply, EventSupply, EventSupply__symbol, eventSupplyOf, EventSupplyPeer } from '../base';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\nconst domEventContext: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners of particular event types and dispatch events.\n *\n * @category DOM\n */\nexport class DomEventDispatcher implements EventSupplyPeer {\n\n  readonly [EventSupply__symbol]: EventSupply = eventSupply();\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target  Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link EventSupply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link EventSupply.off cut off}.\n   *\n   * @typeparam E  Supported DOM event type.\n   * @param type  DOM event type name.\n   *\n   * @returns [[OnDomEvent]] sender of DOM events of the given `type`.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return onDomEventBy<E>((listener, opts) => {\n\n      const { supply } = listener;\n\n      supply.needs(eventSupplyOf(this));\n\n      if (!supply.isOff) {\n\n        // Create unique DOM listener instance\n        const domListener: EventListener = event => listener.receive(domEventContext, event as E);\n\n        this._target.addEventListener(type, domListener, opts);\n        listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n      }\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise. Also returns `false` after [[done]] method called.\n   */\n  dispatch(event: Event): boolean {\n    return !eventSupplyOf(this).isOff && this._target.dispatchEvent(event);\n  }\n\n  /**\n   * Removes all registered event listeners and rejects new listeners registration and event dispatching.\n   *\n   * @param reason  A reason to unregister event listeners.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n","import { HthvItem } from './hthv-item';\n\n/**\n * @internal\n */\nexport interface HthvPartial<I extends HthvItem<any, any, any> = HthvItem> {\n  $: I['$'];\n  n?: I['n'];\n  t?: I['t'];\n  v: I['v'];\n  x?: I['x'];\n  p?: I['p'];\n  pl?: I['pl'];\n}\n\n/**\n * @internal\n */\nexport function hthvItem<I extends HthvItem<any, any, any>>(\n    {\n      $,\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<I>,\n): I {\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as I;\n}\n","import { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam({ p, pl }: HthvItem, param: HthvParamItem) {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","import { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = config.delimiterOf(c);\n\n    return c;\n  };\n}\n","// tslint:disable-next-line:max-line-length\nimport { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (input.s.match(datePattern)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","/**\n * @internal\n */\nexport const parseNone = () => false;\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseDateTime } from './parse-date-time';\nimport { parseNone } from './parse-none';\nimport { quotedStringParser } from './quoted-string-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport interface ItemParserOpts {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseQuotedString = quotedStringParser(config);\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem),\n    )) ; // tslint:disable-line:curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (config.delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (config.delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = config.delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = config.delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser(config: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(config.delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport { HthvDelimitConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  delimiterOf(char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n    }: {\n      delimit?: HthvDelimitConfig;\n    } = {}): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = /*#__PURE__*/ buildParserConfig();\n\n/**\n * @internal\n */\nexport const commentParserConfig = /*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n});\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiterChar } from './hthv-delimiter';\nimport { HthvItem } from './hthv-item';\nimport { hthvItem } from './hthv-partial.impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeparam N  Whether parsed items have {@link HthvItem.n names}.\n * @typeparam T  Whether parsed items have {@link HthvItem.t tags}.\n * @typeparam P  Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    N extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    T extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    P extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value  HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<N, T, P>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse comments.\n   *\n   * `false` by default.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config  New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // tslint:disable-line\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (config.delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport { spacesParser } from './spaces-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const commentParserOpts: ItemParserOpts = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserOpts);\n  const parseParam = paramParser(config, commentParserOpts);\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while (\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        ) ; /* tslint:disable-line:curly */\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @module http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser =\n    /*#__PURE__*/ newHthvParser();\n","/**\n * @module http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string  A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = defaultParserConfig.delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If its not a printable ASCII character\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// Its a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// Its an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since theyre redundant. Note that this is only possible if the escape\n\t// sequence isnt preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// Its not safe to remove the space, so dont.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n","/* eslint-disable no-var, prefer-template */\nvar uppercasePattern = /[A-Z]/g\nvar msPattern = /^ms-/\nvar cache = {}\n\nfunction toHyphenLower(match) {\n  return '-' + match.toLowerCase()\n}\n\nfunction hyphenateStyleName(name) {\n  if (cache.hasOwnProperty(name)) {\n    return cache[name]\n  }\n\n  var hName = name.replace(uppercasePattern, toHyphenLower)\n  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)\n}\n\nexport default hyphenateStyleName\n","import cssesc from 'cssesc';\n\n/**\n * @internal\n */\nexport function cssescId(id: string): string {\n  return cssesc(id, { isIdentifier: true });\n}\n\n/**\n * @internal\n */\nexport const IMPORTANT_CSS_SUFFIX = '!important';\n","/**\n * @internal\n */\nexport function isReadonlyArray<T>(value: any): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): array is readonly [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: T[]): array is [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): boolean {\n  return !!array.length;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { StypColor } from './color';\nimport { StypNumeric } from './numeric';\nimport { StypPriority } from './priority';\nimport { StypURL } from './url';\n\n/**\n * CSS property value.\n *\n * This is either a scalar value, or {@link StypValueStruct structured} one.\n *\n * @category CSS Value\n */\nexport type StypValue =\n    | string\n    | number\n    | boolean\n    | undefined\n    | StypNumeric<any>\n    | StypURL\n    | StypColor;\n\n/**\n * Structured property CSS value. E.g. [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length),\n * [percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage),\n * [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value), etc.\n *\n * @category CSS Value\n * @typeparam Self  A type of itself.\n */\nexport abstract class StypValueStruct<Self extends StypValueStruct<Self>> {\n\n  /**\n   * CSS property value priority.\n   *\n   * The value [[StypPriority.Important]] and above means the property is `!important`. Everything else means normal\n   * priority.\n   *\n   * The property value with higher priority number takes precedence over the one with lower one.\n   */\n  readonly priority: number;\n\n  /**\n   * Constructs structured CSS property value.\n   *\n   * @param opts  Construction options.\n   */\n  protected constructor(opts?: StypValue.Opts) {\n    this.priority = opts && opts.priority || StypPriority.Default;\n  }\n\n  /**\n   * Checks whether this value equals to CSS property value.\n   *\n   * @param other  CSS property value to compare with.\n   */\n  abstract is(other: StypValue): boolean;\n\n  /**\n   * Creates structured CSS value with the given `priority`.\n   *\n   * @param priority  New priority.\n   *\n   * @returns Either a new value equal to this one but having the given `priority`, or this one if `priority` did\n   * not change.\n   */\n  abstract prioritize(priority: number): Self;\n\n  /**\n   * Creates `!important` variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to [[StypPriority.Important]],\n   * or this one if already the case.\n   */\n  important(): Self {\n    return this.prioritize(StypPriority.Important);\n  }\n\n  /**\n   * Creates usual (not `!important`) variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to [[StypPriority.Usual]],\n   * or this one if already the case.\n   */\n  usual(): Self {\n    return this.prioritize(StypPriority.Usual);\n  }\n\n  /**\n   * Maps the given CSS property value to the value of this one's type. Defaults to this value if mapping is not\n   * possible.\n   *\n   * This method allows to use an structured value instance as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value.\n   */\n  abstract by(source: StypValue): StypValue;\n\n  /**\n   * Returns textual representation of this value.\n   *\n   * Textual representation never contains an `!important` suffix.\n   *\n   * @returns A textual representation of this value to use as CSS property value.\n   */\n  abstract toString(): string;\n\n}\n\nexport namespace StypValue {\n\n  /**\n   * Construction options of structured property CSS value.\n   */\n  export interface Opts {\n\n    /**\n     * Constructed value priority.\n     *\n     * The value [[StypPriority.Important]] and above means the property is `!important`. Everything else means normal\n     * priority.\n     */\n    readonly priority?: number;\n\n  }\n\n}\n\n/**\n * Checks whether two CSS property values are equal.\n *\n * Compares scalar values verbatim. Compares structured values using their [[StypValueStruct.is]] method. The latter\n * method is applied when at least one of the values is structured.\n *\n * @category CSS Value\n * @param first  The first CSS property value to compare.\n * @param second  The second CSS property value to compare.\n *\n * @returns `true` if `first` equals to `second`, or `false otherwise.\n */\nexport function stypValuesEqual(first: StypValue, second: StypValue): boolean {\n  if (first === second) {\n    return true;\n  }\n  if (typeof first === 'object') {\n    return first.is(second);\n  }\n  if (typeof second === 'object') {\n    return second.is(first);\n  }\n  return false;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\n\n/**\n * Structured [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) CSS property value.\n *\n * Colors are represented by either `rgb()`, or `hsl()` functional notations.\n *\n * @category CSS Value\n */\nexport type StypColor = StypRGB | StypHSL;\n\n/**\n * Structured color CSS property value base.\n *\n * @category CSS Value\n */\nexport abstract class StypColorStruct<Self extends StypColorStruct<Self, Coords>, Coords>\n    extends StypValueStruct<Self> {\n\n  /**\n   * Color value type corresponding to color coordinates. Either `rgb` or `hsl`\n   */\n  abstract readonly type: 'rgb' | 'hsl';\n\n  /**\n   * This color in RGB coordinates.\n   */\n  abstract readonly rgb: StypRGB;\n\n  /**\n   * This color in HSL coordinates.\n   */\n  abstract readonly hsl: StypHSL;\n\n  /**\n   * Constructs another color value with updated coordinates.\n   *\n   * @param coords  Either partial color coordinates to apply or a function returning them and accepting this color\n   * instance as its only argument. Missing values are taken from this color.\n   *\n   * @returns Updated color value.\n   */\n  abstract set(coords: Partial<Coords> | ((this: void, color: this) => Partial<Coords>)): Self;\n\n}\n\n/**\n * CSS property value representing [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors)\n * in `rgb()` or `rgba()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypRGB extends StypColorStruct<StypRGB, StypRGB.Coords> implements StypRGB.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  /**\n   * `rgb` value type.\n   */\n  get type(): 'rgb' {\n    return 'rgb';\n  }\n\n  /**\n   * Red color value between `0` and `255`.\n   */\n  readonly r: number;\n\n  /**\n   * Green color value between `0` and `255`.\n   */\n  readonly g: number;\n\n  /**\n   * Blue color value between `0` and `255`.\n   */\n  readonly b: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs RGB color value.\n   *\n   * @param coords  Color coordinates.\n   * @param opts  Construction options.\n   */\n  constructor(coords: StypRGB.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.r = intCoord(coords.r, 255);\n    this.g = intCoord(coords.g, 255);\n    this.b = intCoord(coords.b, 255);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get rgb(): this {\n    return this;\n  }\n\n  /**\n   * This color in HSL coordinates.\n   */\n  get hsl(): StypHSL {\n\n    const { a } = this;\n    const r = this.r * 100 / 255;\n    const g = this.g * 100 / 255;\n    const b = this.b * 100 / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = Math.round((max + min) / 2);\n\n    if (max === min) {\n      return new StypHSL({ h: 0, s: 0, l, a }, this);\n    }\n\n    const d = max - min;\n    const s = Math.round(l > 50 ? d * 100 / (200 - max - min) : d * 100 / (max + min));\n    let h: number;\n\n    switch (max) {\n      case r:\n        h = ((g - b) / d) + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = ((b - r) / d) + 2;\n        break;\n      default:\n        h = ((r - g) / d) + 4;\n        break;\n    }\n    h *= 60;\n    h = Math.round(h);\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.r === this.r\n        && other.g === this.g\n        && other.b === this.b\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypRGB {\n    return this.priority === priority ? this : new StypRGB(this, { priority });\n  }\n\n  set(coords: Partial<StypRGB.Coords> | ((this: void, color: this) => Partial<StypRGB.Coords>)): StypRGB {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { r = this.r, g = this.g, b = this.b, a = this.a } = coords;\n\n    return new StypRGB({ r, g, b, a }, this);\n  }\n\n  toString(): string {\n\n    const rgb = `${this.r}, ${this.g}, ${this.b}`;\n\n    return this.a === 1 ? `rgb(${rgb})` : `rgba(${rgb}, ${this.a})`;\n\n  }\n\n}\n\nexport namespace StypRGB {\n\n  /**\n   * [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Red color value between `0` and `255`.\n     */\n    r: number;\n\n    /**\n     * Green color value between `0` and `255`.\n     */\n    g: number;\n\n    /**\n     * Blue color value between `0` and `255`.\n     */\n    b: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * CSS property value representing [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors)\n * in `hsl()` or `hsla()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypHSL extends StypColorStruct<StypHSL, StypHSL.Coords> implements StypHSL.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'hsl' {\n    return 'hsl';\n  }\n\n  /**\n   * Hue angle value in degrees between `0` and `360`.\n   */\n  readonly h: number;\n\n  /**\n   * Saturation percentage.\n   */\n  readonly s: number;\n\n  /**\n   * Lightness percentage.\n   */\n  readonly l: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs HSL color value.\n   *\n   * @param coords  Color coordinates.\n   * @param opts  Construction options.\n   */\n  constructor(coords: StypHSL.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.h = angleCoord(coords.h);\n    this.s = coord(coords.s, 100);\n    this.l = coord(coords.l, 100);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   */\n  get rgb(): StypRGB {\n\n    const { a } = this;\n    const s = this.s / 100;\n    const l = this.l / 100;\n\n    if (!s) {\n\n      const c = l * 255;\n\n      return new StypRGB({ r: c, g: c, b: c, a }, this);\n    }\n\n    const q = l < 0.5 ? l * (1 + s) : (l + s) - (l * s);\n    const p = (2 * l) - q;\n    const hueAsFraction = this.h / 360;\n\n    return new StypRGB(\n        {\n          r: hueToRgb(p, q, hueAsFraction + (1.0 / 3.0)),\n          g: hueToRgb(p, q, hueAsFraction),\n          b: hueToRgb(p, q, hueAsFraction - (1.0 / 3.0)),\n          a,\n        },\n        this,\n    );\n  }\n\n  /**\n   * This color in HSL coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get hsl(): this {\n    return this;\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.h === this.h\n        && other.s === this.s\n        && other.l === this.l\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypHSL {\n    return this.priority === priority ? this : new StypHSL(this, { priority });\n  }\n\n  set(coords: Partial<StypHSL.Coords> | ((this: void, color: this) => Partial<StypHSL.Coords>)): StypHSL {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { h = this.h, s = this.s, l = this.l, a = this.a } = coords;\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  toString(): string {\n\n    const hsl = `${this.h}, ${this.s}%, ${this.l}%`;\n\n    return this.a === 1 ? `hsl(${hsl})` : `hsla(${hsl}, ${this.a})`;\n  }\n\n}\n\nexport namespace StypHSL {\n\n  /**\n   * [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Hue angle value in degrees.\n     */\n    h: number;\n\n    /**\n     * Saturation percentage.\n     */\n    s: number;\n\n    /**\n     * Lightness percentage.\n     */\n    l: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypColor = {\n\n  /**\n   * Maps the given CSS property value to color. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a [[StypColor]] object as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  by(source: StypValue): StypColor | undefined {\n    if (typeof source === 'object' && (source.type === 'rgb' || source.type === 'hsl')) {\n      return source;\n    }\n    return;\n  },\n\n};\n\nfunction angleCoord(value: number): number {\n  value = value % 360;\n  return value < 0 ? 360 + value : value;\n}\n\nfunction intCoord(value: number, max: number): number {\n  return coord(Math.round(value), max);\n}\n\nfunction coord(value: number, max: number): number {\n  return Math.max(Math.min(value, max), 0);\n}\n\nfunction hueToRgb(p: number, q: number, t: number): number {\n\n  let newT = t;\n\n  if (newT < 0) {\n    newT += 1;\n  } else if (newT > 1) {\n    newT -= 1;\n  }\n\n  let result;\n\n  if (newT < 1.0 / 6.0) {\n    result = p + ((q - p) * (6 * newT));\n  } else if (newT < 1.0 / 2.0) {\n    result = q;\n  } else if (newT < 2.0 / 3.0) {\n    result = p + (((q - p) * ((2.0 / 3.0) - newT)) * 6);\n  } else {\n    result = p;\n  }\n\n  return result * 255;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { StypColor, StypRGB } from './color';\n\n/**\n * Mixes two colors.\n *\n * Both the `weight` and the relative opacity of each color determines how much of each color is in the result.\n *\n * @category CSS Value\n * @param color1  First color to mix\n * @param color2  Second color to mix.\n * @param weight  A number between `0` and `1`. A larger weight indicates that more of `color1` should be used, and a\n * smaller weight indicates that more of `color2` should be used.\n *\n * @returns Mixed color.\n */\nexport function mixStypColors(color1: StypColor, color2: StypColor, weight: number): StypColor {\n\n  const w = weight * 2 - 1;\n  const rgba1 = color1.rgb;\n  const rgba2 = color2.rgb;\n  const aDiff = rgba1.a - rgba2.a;\n  const w1 = (((w * aDiff === -1) ? w : (w + aDiff) / (1 + w * aDiff)) + 1) / 2.0;\n  const w2 = 1 - w1;\n  return new StypRGB(\n      {\n        r: rgba1.r * w1 + rgba2.r * w2,\n        g: rgba1.g * w1 + rgba2.g * w2,\n        b: rgba1.b * w1 + rgba2.b * w2,\n        a: rgba1.a * weight + rgba2.a * (1 - weight),\n      },\n      color1,\n  );\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\nimport { StypZero } from './zero';\n\n/**\n * Structured numeric CSS property value.\n *\n * This represents either dimension, zero value, or a `calc()` CSS function call.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n * @typeparam Zero  A type of zero value. [[StypZero]] by default.\n */\nexport type StypNumeric<Unit extends string, Zero extends StypZero<Unit> | StypDimension<Unit> = StypZero<Unit>> =\n    | StypDimension<Unit>\n    | StypCalc<Unit>\n    | Zero;\n\n/**\n * Base implementation of structured numeric CSS property value.\n *\n * @category CSS Value\n * @typeparam Self  A type of itself.\n * @typeparam Unit  Allowed unit type.\n */\nexport abstract class StypNumericStruct<Self extends StypNumericStruct<Self, Unit>, Unit extends string>\n    extends StypValueStruct<Self> {\n\n  /**\n   * A type of structured numeric CSS property value.\n   */\n  abstract type: 'dimension' | 'calc' | 0;\n\n  readonly dim: StypDimension.Kind<Unit>;\n\n  constructor(opts: StypDimension.Opts<Unit>) {\n    super(opts);\n    this.dim = opts.dim;\n  }\n\n  /**\n   * Tries to converts this numeric value to another dimension.\n   *\n   * Does not actually construct a value in another dimension, as long as dimension unit supported by both dimensions.\n   *\n   * @typeparam U  A unit type allowed in target dimension.\n   * @param dim  Target dimension.\n   *\n   * @returns Either a value in dimension compatible with `dim`, or `undefined` if this value's unit is not supported\n   * by `dim`.\n   */\n  abstract toDim<U extends string>(dim: StypDimension.Kind<U>): StypNumeric<U> | undefined;\n\n  abstract add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  abstract add(addendum: number, unit: Unit): StypNumeric<Unit>;\n\n  abstract sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  abstract sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  abstract mul(multiplier: number): StypNumeric<Unit>;\n\n  abstract div(divisor: number): StypNumeric<Unit>;\n\n  abstract negate(): StypNumeric<Unit>;\n\n  by(source: StypValue): StypNumeric<Unit> {\n    return this.dim.by(source) || this as StypNumeric<Unit>;\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns CSS value text without `!important` or `calc()`.\n   */\n  abstract toFormula(): string;\n\n  toString(): string {\n    return this.toFormula();\n  }\n\n}\n\n/**\n * Structured [dimension](https://developer.mozilla.org/en-US/docs/Web/CSS/dimension) value with unit.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed units type.\n */\nexport interface StypDimension<Unit extends string>\n    extends StypValueStruct<StypDimension<Unit>>, StypNumericStruct<StypDimension<Unit>, Unit> {\n\n  readonly type: 'dimension';\n\n  readonly dim: StypDimension.Kind<Unit>;\n\n  /**\n   * Dimension value.\n   */\n  readonly val: number;\n\n  /**\n   * Dimension unit.\n   */\n  readonly unit: Unit;\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit?: Unit): StypNumeric<Unit>;\n\n  by(source: StypValue): StypNumeric<Unit>;\n\n}\n\nexport namespace StypDimension {\n\n  /**\n   * A kind of dimensions. E.g. angle, length, percentage, etc.\n   *\n   * It is perfectly fine to use dimensions interchangeably as long as dimension units are compatible.\n   *\n   * @typeparam Unit  Allowed units type.\n   */\n  export interface Kind<Unit extends string> {\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports and, in addition, supporting percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if supports percents.\n     */\n    readonly pt?: Kind<Unit | '%'>;\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports, except percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if does not support percents.\n     */\n    readonly noPt: Kind<Exclude<Unit, '%'>>;\n\n    /**\n     * Zero value of this kind.\n     *\n     * Typically, this is unit-less [[StypZero]]. But some dimensions require units.\n     */\n    readonly zero: StypDimension<Unit> | StypZero<Unit>;\n\n    /**\n     * Constructs dimension value.\n     *\n     * @param val  Numeric dimension value.\n     * @param unit  Dimension unit.\n     *\n     * @returns Constructed dimension value. Either [[StypDimension]] instance, or [[StypZero]] if `val` is `0` and\n     * this dimension kind supports unitless zero.\n     */\n    of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit>;\n\n    /**\n     * Maps the given CSS property value to the one compatible with this dimension kind. Defaults to `undefined`\n     * if mapping is not possible.\n     *\n     * This method allows to use a dimension kind as {@link StypMapper.Mapping CSS property mapping}.\n     *\n     * Any scalar or non-numeric value is mapped to `undefined`. A numeric value is converted to this dimension by\n     * [[StypNumericStruct.toDim]] method.\n     *\n     * @param source  A raw property value that should be converted.\n     *\n     * @returns Mapped property value or `undefined`.\n     */\n    by(source: StypValue): StypNumeric<Unit, StypDimension<Unit> | StypZero<Unit>> | undefined;\n\n  }\n\n  export namespace Kind {\n\n    /**\n     * A kind of dimension with unit-less zero. E.g. angle or length.\n     *\n     * @typeparam Unit  Allowed units type.\n     */\n    export interface UnitlessZero<Unit extends string> extends Kind<Unit> {\n\n      readonly pt?: UnitlessZero<Unit | '%'>;\n\n      readonly noPt: UnitlessZero<Exclude<Unit, '%'>>;\n\n      /**\n       * Zero value of this kind without unit.\n       */\n      readonly zero: StypZero<Unit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val  Numeric dimension value.\n       * @param unit  Dimension unit.\n       *\n       * @returns Constructed dimension value. Either [[StypDimension]] instance, or [[StypZero]] if `val` is `0`.\n       */\n      of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit>;\n\n      by(source: StypValue): StypNumeric<Unit> | undefined;\n\n    }\n\n    /**\n     * A kind of dimension which zero value has unit. E.g. frequency or resolution.\n     *\n     * @typeparam Unit  Allowed units type.\n     */\n    export interface UnitZero<Unit extends string> extends Kind<Unit> {\n\n      readonly pt?: UnitZero<Unit | '%'>;\n\n      readonly noPt: UnitZero<Exclude<Unit, '%'>>;\n\n      /**\n       * Zero value of this kind that has unit.\n       */\n      readonly zero: StypDimension<Unit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val  Numeric dimension value.\n       * @param unit  Dimension unit.\n       *\n       * @returns Constructed dimension value as a [[StypDimension]] instance.\n       */\n      of(val: number, unit: Unit): StypDimension<Unit>;\n\n      by(source: StypValue): StypNumeric<Unit, StypDimension<Unit>> | undefined;\n\n    }\n\n  }\n\n  /**\n   * Construction options of dimensions.\n   *\n   * @typeparam Unit  Allowed units type.\n   */\n  export interface Opts<Unit extends string> extends StypValue.Opts {\n\n    /**\n     * A kind of dimension.\n     */\n    dim: Kind<Unit>;\n\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation.\n *\n * This is either a {@link StypAddSub addition/subtraction}, or {@link StypMulDiv multiplication/division}.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport type StypCalc<Unit extends string> = StypAddSub<Unit> | StypMulDiv<Unit>;\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport interface StypAddSub<Unit extends string> extends StypNumericStruct<StypAddSub<Unit>, Unit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<Unit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '+' | '-';\n\n  /**\n   * Right operand.\n   */\n  readonly right: StypNumeric<Unit>;\n\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport interface StypMulDiv<Unit extends string> extends StypNumericStruct<StypMulDiv<Unit>, Unit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<Unit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '*' | '/';\n\n  /**\n   * Right operand.\n   */\n  readonly right: number;\n\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { itsEach, overKeys } from 'a-iterable';\nimport { StypProperties } from '../rule';\nimport { StypValue } from './value';\n\n/**\n * A type of function that maps CSS properties to something else.\n *\n * @category CSS Value\n * @typeparam R  A type of mapped properties. This is a mapping result type.\n */\nexport type StypMapper<R> =\n/**\n * @param from  CSS properties to map.\n *\n * @returns Mapping result.\n */\n    (this: void, from: StypProperties) => R;\n\nexport namespace StypMapper {\n\n  /**\n   * CSS property mapping.\n   *\n   * It is used to recognize raw property value and convert it to the one of the given type.\n   *\n   * It is one of:\n   * - Default property value. Replaces the source property value, unless the the have the same type.\n   * - A mapping function. Replaces the source property value with the result of this function call.\n   * - An object containing mapping method called `by()`. Replaces the source property value with the result of this\n   *   method call.\n   *\n   * @typeparam R  A type of mapped properties. This is an object containing mapped properties.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export type Mapping<R, K extends keyof R> =\n      | MappingFunction<R, K>\n      | MappingObject<R, K>\n      | R[K];\n\n  /**\n   * CSS property mapping function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export type MappingFunction<R, K extends keyof R> =\n  /**\n   * @param source  A raw property value that should be converted.\n   * @param mapped  An object granting access to other mapped properties.\n   * @param key  A key of converted property.\n   *\n   * @returns Mapped property value.\n   */\n      (this: void, source: StypValue, mapped: Mapped<R>, key: K) => R[K];\n\n  /**\n   * CSS property mapping object.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export interface MappingObject<R, K extends keyof R> {\n\n    /**\n     * Maps CSS property value.\n     *\n     * @param source  A raw property value that should be converted.\n     * @param mapped  An object granting access to other mapped properties.\n     * @param key  A key of converted property.\n     *\n     * @returns Mapped property value.\n     */\n    by(source: StypValue, mapped: Mapped<R>, key: K): R[K];\n\n  }\n\n  /**\n   * Grants access to mapped values.\n   *\n   * Passed as a second argument to mapping function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   */\n  export interface Mapped<R> {\n\n    /**\n     * Original properties to convert.\n     */\n    from: StypProperties;\n\n    /**\n     * Maps the property with the given type accordingly to mapping instruction.\n     *\n     * The mapping is performed at most once per property.\n     *\n     * @param key  Mapped property key.\n     *\n     * @returns Mapped property value.\n     */\n    get<K extends keyof R>(key: K): R[K];\n\n  }\n\n  /**\n   * Mappings of CSS properties.\n   *\n   * Contains mappings for each mapped CSS property with that property name as a key.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   */\n  export type Mappings<R> = { readonly [key in keyof R]: Mapping<R, key>; };\n\n}\n\nexport const StypMapper = {\n\n  /**\n   * Maps CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   *\n   * @param mappings  Mappings of CSS properties.\n   * @param from  Raw CSS properties to map.\n   *\n   * @returns Mapped properties.\n   */\n  map<R>(mappings: StypMapper.Mappings<R>, from: StypProperties): R {\n\n    const result: { [key in keyof R]: R[key] } = {} as any;\n    const mapped = {\n      from,\n      get<K extends keyof R>(key: K): R[K] {\n        if (key in result) {\n          return result[key];\n        }\n\n        const mapper = mappingBy<R, K>(mappings[key]);\n        const mappedValue = mapper(from[key as string], this, key);\n\n        result[key] = mappedValue;\n\n        return mappedValue;\n      },\n    };\n\n    itsEach(overKeys(mappings), key => mapped.get(key));\n\n    return result;\n  },\n\n  /**\n   * Creates CSS properties mapper function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @param mappings  Mappings of CSS properties.\n   *\n   * @returns A function that maps CSS properties accordingly to the given `mappings`.\n   */\n  by<R>(mappings: StypMapper.Mappings<R>): StypMapper<R> {\n    return StypMapper.map.bind<void, StypMapper.Mappings<R>, [StypProperties], R>(undefined, mappings);\n  },\n\n};\n\nfunction mappingBy<R, K extends keyof R>(\n    mapping: StypMapper.Mapping<R, K> | undefined,\n): StypMapper.MappingFunction<R, K> {\n  switch (typeof mapping) {\n  case 'function':\n    return mapping as StypMapper.MappingFunction<R, K>;\n  case 'object':\n    return (mapping as StypMapper.MappingObject<R, K>).by.bind(mapping);\n  }\n\n  const type = typeof mapping;\n\n  return (from: StypValue): R[K] => typeof from === type ? from as any : mapping;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue } from './value';\n\n/**\n * Predefined CSS property value priorities.\n *\n * @category CSS Value\n */\nexport const enum StypPriority {\n\n  /**\n   * Usual, non-important priority.\n   *\n   * This priority is assigned to values by [[StypValueStruct.usual]] method.\n   */\n  Usual = 0,\n\n  /**\n   * Default priority.\n   *\n   * The same as `Usual`. This priority is assigned to values by default.\n   */\n  Default = Usual,\n\n  /**\n   * Important priority.\n   *\n   * This priority corresponds to values with `!important` suffix. It is applied to string values with `!important`\n   * suffix, and can be assigned to structured values using [[StypValueStruct.important]] method.\n   *\n   * All numeric priorities with higher values are rendered as `!important` ones.\n   */\n  Important = 1,\n\n}\n\n/**\n * Splits undefined CSS property value onto non-prioritized value and priority.\n *\n * @category CSS Value\n * @param value  Undefined CSS property value to split.\n *\n * @returns An `[undefined, 0]` tuple.\n */\nexport function stypSplitPriority<T extends StypValue>(value: undefined): [undefined, 0];\n\n/**\n * Splits string CSS property value onto non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value without `!priority` suffix, and numeric priority (0 or 1).\n */\nexport function stypSplitPriority(value: string): [string, 0 | 1];\n\n/**\n * Splits scalar CSS property value onto non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value and `0` priority.\n */\nexport function stypSplitPriority<T extends number | boolean>(value: T): [T, 0];\n\n/**\n * Splits arbitrary CSS property value onto value non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value and numeric priority.\n */\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number];\n\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number] {\n  if (value == null) {\n    return [undefined as T, StypPriority.Default];\n  }\n\n  switch (typeof value) {\n    case 'object':\n      return [value, value.priority];\n    case 'string':\n      if (value.endsWith(IMPORTANT_CSS_SUFFIX)) {\n        return[value.substring(0, value.length - IMPORTANT_CSS_SUFFIX.length).trim() as T, StypPriority.Important];\n      }\n  }\n\n  return [value, StypPriority.Default];\n}\n","import { StypPriority } from '../priority';\nimport { StypValue, stypValuesEqual } from '../value';\nimport {\n  StypAddSub as StypAddSub_,\n  StypDimension as StypDimension_,\n  StypMulDiv as StypMulDiv_,\n  StypNumeric,\n  StypNumericStruct,\n} from './numeric';\nimport { StypZero } from './zero';\n\n/**\n * @internal\n */\nexport class StypDimension<Unit extends string>\n    extends StypNumericStruct<StypDimension<Unit>, Unit>\n    implements StypDimension_<Unit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'dimension' {\n    return 'dimension';\n  }\n\n  /**\n   * The number value.\n   */\n  readonly val: number;\n\n  /**\n   * The unit.\n   */\n  readonly unit: Unit;\n\n  /**\n   * Constructs new structured dimension value.\n   *\n   * @param val  The numeric value.\n   * @param unit  The unit.\n   * @param opts  CSS value options.\n   */\n  constructor(val: number, unit: Unit, opts: StypDimension_.Opts<Unit>) {\n    super(opts);\n    this.val = val;\n    this.unit = unit;\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypDimension_<U> | undefined {\n\n    const thisDim: StypDimension_.Kind<any> = this.dim;\n\n    if (dim === thisDim /* same dimension */\n        || dim === thisDim.pt /* !% to compatible +% */\n        || dim === (this.unit === '%' ? dim.pt /* % to any +% */ : thisDim.noPt /* !% to compatible -% */)) {\n      return this as StypDimension_<any>;\n    }\n\n    return;\n  }\n\n  is(other: StypValue): boolean {\n    if (other === this) {\n      return true;\n    }\n    return typeof other === 'object'\n        && other.type === this.type\n        && this.unit === other.unit\n        && this.val === other.val\n        && this.priority === other.priority;\n  }\n\n  prioritize(priority: number): StypDimension<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypDimension(this.val, this.unit, { dim: this.dim, priority });\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit || this.unit, this);\n    }\n    if (addendum.type === 'dimension' && this.unit === addendum.unit) {\n      return stypDimension(this.val + addendum.val, this.unit, this);\n    }\n    return stypAddSub(this, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit?: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit || this.unit, this);\n    }\n    if (subtrahend.type === 'dimension' && this.unit === subtrahend.unit) {\n      return stypDimension(this.val - subtrahend.val, this.unit, this);\n    }\n    return stypAddSub(this, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return multiplier === 1 ? this : stypDimension(this.val * multiplier, this.unit, this);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return divisor === 1 ? this : stypDimension(this.val / divisor, this.unit, this);\n  }\n\n  negate(): StypNumeric<Unit> {\n    return stypDimension(-this.val, this.unit, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `<value><unit>` or just `0`.\n   */\n  toFormula(): string {\n    return this.val + this.unit;\n  }\n\n}\n\n/**\n * Constructs structured [dimension] CSS property value.\n *\n * @param val  Numeric value.\n * @param unit  Value unit.\n * @param opts  Construction options.\n *\n * @returns Either [[StypDimension]], or [[StypZero]] if `val === 0`.\n *\n * [dimension]: https://developer.mozilla.org/en-US/docs/Web/CSS/dimension\n *\n * @internal\n */\nexport function stypDimension<Unit extends string>(\n    val: number,\n    unit: Unit,\n    opts: StypDimension_.Opts<Unit>,\n): StypDimension_<Unit> | StypZero<Unit> {\n  return val\n      ? new StypDimension<Unit>(val, unit, opts)\n      : opts.dim.zero.prioritize(opts.priority || StypPriority.Default);\n}\n\n/**\n * @internal\n */\nexport abstract class StypCalcBase<\n    Self extends StypCalcBase<Self, Op, Right, Unit>,\n    Op extends '+' | '-' | '*' | '/',\n    Right extends number | StypNumeric<Unit>,\n    Unit extends string>\n    extends StypNumericStruct<Self, Unit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'calc' {\n    return 'calc';\n  }\n\n  readonly left: StypNumeric<Unit>;\n  readonly op: Op;\n  readonly right: Right;\n\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(\n      left: StypNumeric<Unit>,\n      op: Op,\n      right: Right,\n      opts: StypDimension_.Opts<Unit>,\n  ) {\n    super(opts);\n    this.left = left.usual();\n    this.op = op;\n    this.right = right;\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object' && other.type === this.type) {\n      return this.op === other.op\n          && this.left.is(other.left)\n          && stypValuesEqual(this.right, other.right)\n          && this.priority === other.priority;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as Unit, this);\n    }\n    return stypAddSub(this as StypNumeric<Unit>, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as Unit, this);\n    }\n    return stypAddSub(this as StypNumeric<Unit>, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return stypMul(this as StypNumeric<Unit>, multiplier);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return stypDiv(this as StypNumeric<Unit>, divisor);\n  }\n\n  abstract negate(): StypNumeric<Unit>;\n\n  abstract prioritize(priority: number): Self;\n\n  abstract toFormula(): string;\n\n  toString(): string {\n    return 'calc' + super.toString();\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @typeparam Unit  Allowed unit type.\n *\n * @internal\n */\nexport class StypAddSub<Unit extends string>\n    extends StypCalcBase<StypAddSub<Unit>, '+' | '-', StypNumeric<Unit>, Unit>\n    implements StypAddSub_<Unit> {\n\n  constructor(left: StypNumeric<Unit>, op: '+' | '-', right: StypNumeric<Unit>, opts: StypDimension_.Opts<Unit>) {\n    super(left, op, right.usual(), opts);\n  }\n\n  prioritize(priority: number): StypAddSub<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypAddSub(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypAddSub<U> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    const right = this.right.toDim(dim);\n\n    if (!right) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any> && right === this.right as StypNumeric<any>) {\n      return this as StypAddSub<any>;\n    }\n\n    return new StypAddSub<U>(left, this.op, right, { dim, priority: this.priority });\n  }\n\n  negate(): StypNumeric<Unit> {\n    return this.op === '-'\n        ? new StypAddSub(this.right, this.op, this.left, this)\n        : new StypAddSub(this.left.negate(), '-', this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right.toFormula()})`;\n  }\n\n}\n\nfunction stypAddSub<Unit extends string>(\n    left: StypNumeric<Unit>,\n    op: '+' | '-',\n    right: StypNumeric<Unit>,\n): StypNumeric<Unit> {\n  return !right.type ? left : new StypAddSub(left, op, right, left);\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @typeparam Unit  Allowed unit type.\n *\n * @internal\n */\nexport class StypMulDiv<Unit extends string>\n    extends StypCalcBase<StypMulDiv<Unit>, '*' | '/', number, Unit>\n    implements StypMulDiv_<Unit> {\n\n  prioritize(priority: number): StypMulDiv<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypMulDiv(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypMulDiv<U> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any>) {\n      return this as StypMulDiv<any>;\n    }\n\n    return new StypMulDiv<U>(left, this.op, this.right, { dim, priority: this.priority });\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return (this.op === '*'\n        ? stypMul(this.left, this.right * multiplier)\n        : stypDiv(this.left, this.right / multiplier))\n        .prioritize(this.priority);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return (this.op === '/'\n        ? stypDiv(this.left, this.right * divisor)\n        : stypMul(this.left, this.right / divisor))\n        .prioritize(this.priority);\n  }\n\n  negate(): StypNumeric<Unit> {\n    return new StypMulDiv(this.left, this.op, -this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right})`;\n  }\n\n}\n\nfunction stypMul<Unit extends string>(left: StypNumeric<Unit>, right: number): StypNumeric<Unit> {\n  return !right\n      ? left.dim.zero.prioritize(left.priority)\n      : right === 1\n          ? left.prioritize(left.priority)\n          : new StypMulDiv(left, '*', right, left);\n}\n\nfunction stypDiv<Unit extends string>(left: StypNumeric<Unit>, right: number): StypNumeric<Unit> {\n  return right === 1\n      ? left.prioritize(left.priority)\n      : new StypMulDiv(left, '/', right, left);\n}\n\n/**\n * @internal\n */\nexport function isStypNumeric(source: StypValue): source is StypNumeric<any, any> {\n  return typeof source === 'object' && (source.type === 'dimension' || source.type === 'calc' || source.type === 0);\n}\n","import { StypPriority } from '../priority';\nimport { StypValue } from '../value';\nimport { StypDimension, StypNumeric, StypNumericStruct } from './';\nimport { stypDimension } from './numeric.impl';\nimport { StypZero } from './zero';\n\nclass Zero<Unit extends string> extends StypNumericStruct<Zero<Unit>, Unit> implements StypZero<Unit> {\n\n  constructor(private readonly _byPriority: ZeroByPriority<Unit>, opts: StypDimension.Opts<Unit>) {\n    super(opts);\n  }\n\n  get type(): 0 {\n    return 0;\n  }\n\n  toDim<U extends string>(dim: StypDimension.Kind<U>): StypDimension<U> | StypZero<U> {\n    return dim.zero.prioritize(this.priority);\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object') {\n      return other.type === this.type && other.priority === this.priority;\n    }\n    if (other === 0 || other === '0') {\n      return this.priority === StypPriority.Usual;\n    }\n    if (other === '0 !important') {\n      return this.priority === StypPriority.Important;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as Unit, this);\n    }\n    return addendum.prioritize(this.priority);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as Unit, this);\n    }\n    return subtrahend.negate().prioritize(this.priority);\n  }\n\n  mul(): this {\n    return this;\n  }\n\n  div(): this {\n    return this;\n  }\n\n  negate(): this {\n    return this;\n  }\n\n  prioritize(priority: number): Zero<Unit> {\n    return this._byPriority.get(priority);\n  }\n\n  important(): Zero<Unit> {\n    return this._byPriority.important;\n  }\n\n  usual(): Zero<Unit> {\n    return this._byPriority.usual;\n  }\n\n  toFormula(): string {\n    return '0';\n  }\n\n}\n\nclass ZeroByPriority<Unit extends string> {\n\n  readonly usual: Zero<Unit>;\n  readonly important: Zero<Unit>;\n\n  constructor(readonly dim: StypDimension.Kind<Unit>) {\n    this.usual = new Zero(this, { dim });\n    this.important = new Zero(this, { dim, priority: StypPriority.Important });\n  }\n\n  get(priority: number): Zero<Unit> {\n    switch (priority) {\n      case StypPriority.Usual: return this.usual;\n      case StypPriority.Important: return this.important;\n    }\n    return new Zero(this, { dim: this.dim, priority });\n  }\n\n}\n\n/**\n * @internal\n */\nexport function newStypZero<Unit extends string>(dim: StypDimension.Kind.UnitlessZero<Unit>): StypZero<Unit> {\n  return new ZeroByPriority<Unit>(dim).usual;\n}\n","import { StypValue } from '../value';\nimport { StypDimension, StypNumeric } from './numeric';\nimport { isStypNumeric, StypDimension as StypDimension_ } from './numeric.impl';\nimport { StypZero } from './zero';\nimport { newStypZero } from './zero.impl';\n\n/**\n * @internal\n */\nexport function unitlessZeroDimensionKind<Unit extends string>(\n    {\n      pt,\n      noPt,\n    }: {\n      pt: () => StypDimension.Kind.UnitlessZero<Unit | '%'>;\n      noPt: () => StypDimension.Kind.UnitlessZero<Exclude<Unit, '%'>>;\n    },\n): StypDimension.Kind.UnitlessZero<Unit> {\n\n  const dimension: StypDimension.Kind.UnitlessZero<Unit> = {\n\n    get zero(): StypZero<Unit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return zero;\n    },\n\n    get pt() {\n      return pt();\n    },\n\n    get noPt() {\n      return noPt();\n    },\n\n    of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return val ? new StypDimension_(val, unit, { dim: this }) : zero;\n    },\n\n    by(source: StypValue): StypNumeric<Unit> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n\n      const numeric: StypNumeric<any, any> = source;\n\n      return numeric.toDim(this);\n    },\n\n  };\n\n  const zero = newStypZero<Unit>(dimension);\n\n  return dimension;\n}\n\n/**\n * @internal\n */\nexport function unitZeroDimensionKind<Unit extends string>(\n    {\n      zeroUnit,\n      withPercent,\n      noPercent,\n    }: {\n      zeroUnit: Unit;\n      withPercent?: () => StypDimension.Kind.UnitZero<Unit | '%'>;\n      noPercent?: () => StypDimension.Kind.UnitZero<Exclude<Unit, '%'>>;\n    },\n): StypDimension.Kind.UnitZero<Unit> {\n\n  const dim: StypDimension.Kind.UnitZero<Unit> = {\n\n    get pt() {\n      return withPercent && withPercent();\n    },\n\n    get noPt() {\n      return noPercent ? noPercent() : this as StypDimension.Kind.UnitZero<Exclude<Unit, '%'>>;\n    },\n\n    get zero(): StypDimension<Unit> {\n      return zero;// eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n\n    of(val: number, unit: Unit): StypDimension<Unit> {\n      return new StypDimension_(val, unit, { dim: this });\n    },\n\n    by(source: StypValue): StypNumeric<Unit, StypDimension<Unit>> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n\n      const numeric: StypNumeric<any, any> = source;\n\n      return numeric.toDim(this);\n    },\n\n  };\n\n  const zero = new StypDimension_(0, zeroUnit, { dim });\n\n  return dim;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { StypDimension, StypNumeric } from '../numeric';\nimport { unitlessZeroDimensionKind } from '../numeric/dimension-kind.impl';\n\n/**\n * Structured [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) property value.\n *\n * Can be constructed using `StypLength.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLength = StypNumeric<StypLength.Unit>;\n\nexport namespace StypLength {\n\n  /**\n   * Supported length units, excluding percent.\n   */\n  export type Unit = 'cap' | 'ch' | 'em' | 'ex' | 'ic' | 'lh' | 'rem' | 'rlh'\n      | 'vh' | 'vw' | 'vi' | 'vb' | 'vmin' | 'vmax'\n      | 'px' | 'cm' | 'mm' | 'Q' | 'in' | 'pc' | 'pt';\n\n}\n\nexport const StypLength: StypDimension.Kind.UnitlessZero<StypLength.Unit> = (/*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypLengthPt;// eslint-disable-line @typescript-eslint/no-use-before-define\n  },\n  noPt() {\n    return StypLength;\n  },\n}));\n\n/**\n * Structured [length-percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage) CSS property\n * value.\n *\n * Can be constructed using `StypLengthPt.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLengthPt = StypNumeric<StypLengthPt.Unit>;\n\nexport namespace StypLengthPt {\n\n  /**\n   * Supported length units, including percent.\n   */\n  export type Unit = StypLength.Unit | '%';\n\n}\n\nexport const StypLengthPt: StypDimension.Kind.UnitlessZero<StypLengthPt.Unit> = (\n    /*#__PURE__*/ unitlessZeroDimensionKind({\n      pt() {\n        return StypLengthPt;\n      },\n      noPt() {\n        return StypLength;\n      },\n    })\n);\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport cssesc from 'cssesc';\nimport { stypSplitPriority } from './priority';\nimport { StypValue, StypValueStruct } from './value';\n\n/**\n * Structured [URL](https://developer.mozilla.org/en-US/docs/Web/CSS/url) CSS property value.\n *\n * @category CSS Value\n */\nexport class StypURL extends StypValueStruct<StypURL> {\n\n  /**\n   * Target URL.\n   */\n  readonly url: string;\n\n  /**\n   * `url` value type.\n   */\n  get type(): 'url' {\n    return 'url';\n  }\n\n  /**\n   * Maps the given CSS property value to URL. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a [[StypURL]] class as [CSS property mapping][[StypMapper.Mapping]].\n   *\n   * Strings are treated as URLs (without `url()` functional syntax). `!important` suffix is respected.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  static by(source: StypValue): StypURL | undefined {\n    switch (typeof source) {\n      case 'string': {\n\n        const [url, priority] = stypSplitPriority(source);\n\n        return new StypURL(url, { priority });\n      }\n      case 'object':\n        if (source.type === 'url') {\n          return source;\n        }\n    }\n    return;\n  }\n\n  /**\n   * Constructs URL value.\n   *\n   * @param url  Target URL.\n   * @param opts  Construction options.\n   */\n  constructor(url: string, opts?: StypValue.Opts) {\n    super(opts);\n    this.url = url;\n  }\n\n  by(source: StypValue): StypURL {\n    return StypURL.by(source) || this;\n  }\n\n  prioritize(priority: number): StypURL {\n    return priority === this.priority ? this : new StypURL(this.url, { priority });\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === 'url'\n        && other.url === this.url\n        && other.priority === this.priority;\n  }\n\n  toString(): string {\n    return `url('${cssesc(this.url)}')`;\n  }\n\n}\n","import { filterIt, itsIterator, itsReduction, overEntries } from 'a-iterable';\nimport { asis, isPresent, nextSkip, NextSkip, valuesProvider } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  isEventSender,\n} from 'fun-events';\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue, stypValuesEqual } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * @internal\n */\nexport const noStypProperties: AfterEvent<[StypProperties]> = (/*#__PURE__*/ afterThe({}));\n\n/**\n * @internal\n */\nexport function noStypPropertiesSpec(): AfterEvent<[StypProperties]> {\n  return noStypProperties;\n}\n\n/**\n * @internal\n */\nexport function stypPropertiesBySpec(rule: StypRule, spec?: StypProperties.Spec): AfterEvent<[StypProperties]> {\n  if (!spec) {\n    return noStypProperties;\n  }\n  if (typeof spec !== 'string') {\n    if (isEventKeeper(spec)) {\n      return preventDuplicates(spec);\n    }\n    if (isEventSender(spec)) {\n      return preventDuplicates(propertiesKeeper(spec));\n    }\n    if (typeof spec === 'function') {\n\n      const senderOrProperties = spec(rule);\n\n      if (typeof senderOrProperties !== 'string') {\n        if (isEventKeeper(senderOrProperties)) {\n          return preventDuplicates(senderOrProperties);\n        }\n        if (isEventSender(senderOrProperties)) {\n          return preventDuplicates(propertiesKeeper(senderOrProperties));\n        }\n      }\n\n      return afterThe(propertiesMap(senderOrProperties));\n    }\n  }\n\n  return afterThe(propertiesMap(spec));\n}\n\nfunction propertiesKeeper(sender: EventSender<[string | StypProperties]>): AfterEvent<[string | StypProperties]> {\n  return afterSupplied(sender, valuesProvider({}));\n}\n\nfunction preventDuplicates(properties: EventKeeper<[string | StypProperties]>): AfterEvent<[StypProperties]> {\n  return afterSupplied(properties).keepThru(\n      propertiesMap,\n      passNonDuplicate(),\n      asis as (props: StypProperties) => StypProperties, // Needed to satisfy signature\n  );\n}\n\nfunction passNonDuplicate(): (update: StypProperties) => StypProperties | NextSkip {\n\n  let stored: StypProperties | undefined;\n\n  return update => {\n    if (stored && propertiesEqual(update, stored)) {\n      return nextSkip();\n    }\n    return stored = { ...update };\n  };\n}\n\nfunction propertiesMap(properties: string | StypProperties): StypProperties {\n  return typeof properties === 'string' ? { $$css: properties } : properties;\n}\n\nfunction propertiesEqual(first: StypProperties, second: StypProperties): boolean {\n\n  const s = itsIterator(propertyEntries(second));\n\n  for (const [key, value] of propertyEntries(first)) {\n\n    const { value: sentry } = s.next();\n\n    if (!sentry || key !== sentry[0] || !stypValuesEqual(value, sentry[1])) {\n      return false;\n    }\n  }\n\n  return !s.next().value;\n}\n\nfunction propertyEntries(properties: StypProperties): Iterable<[keyof StypProperties, StypValue]> {\n  return filterIt(overEntries(properties), isPresent);\n}\n\n/**\n * @internal\n */\nexport function mergeStypProperties(\n    base: AfterEvent<[StypProperties]>,\n    addendum: AfterEvent<[StypProperties]>,\n): AfterEvent<[StypProperties]> {\n  return preventDuplicates(\n      afterAll({ base, addendum }).keepThru(\n          ({ base: [baseProperties], addendum: [addendumProperties] }) => addValues(baseProperties, addendumProperties),\n      ),\n  );\n}\n\nfunction addValues(base: StypProperties, addendum: StypProperties): StypProperties {\n  return itsReduction(\n      overEntries(addendum),\n      (result, [k, v]) => addValue(result, k, v),\n      { ...base },\n  );\n}\n\nfunction addValue(\n    properties: StypProperties.Mutable,\n    key: keyof StypProperties,\n    value: StypValue,\n): StypProperties.Mutable {\n  if (priorityOf(properties[key]) <= priorityOf(value)) {\n    delete properties[key];\n    properties[key] = value;\n  }\n  return properties;\n}\n\nfunction priorityOf(value: StypValue): number {\n  switch (typeof value) {\n    case 'string':\n      return value.endsWith(IMPORTANT_CSS_SUFFIX) ? 1 : 0;\n    case 'object':\n      return value.priority;\n  }\n  return 0;\n}\n","import { flatMapIt } from 'a-iterable';\nimport { compareNames, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { isNotEmptyArray, isReadonlyArray } from '../internal';\nimport { StypPureSelector } from './pure-selector';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSubSelector } from './sub-selector';\n\n/**\n * @internal\n */\nexport function isCombinator(\n    item: string | StypSelector.Part | StypSelector.Combinator,\n): item is StypSelector.Combinator {\n  return item === '>' || item === '+' || item === '~';\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized {\n  if (!isReadonlyArray(selector)) {\n    return [normalizeKey(selector)];\n  }\n\n  const normalized: StypSelector.Mutable = [];\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (const item of selector) {\n\n    const prevCombinator = combinator;\n\n    if (combinator) {\n      normalized.push(combinator);\n      combinator = undefined;\n    }\n\n    let part: StypSelector.NormalizedPart;\n\n    if (isCombinator(item)) {\n      combinator = item;\n      if (!prevCombinator) {\n        continue;\n      }\n      part = {};\n    } else {\n      part = normalizeKey(item);\n    }\n\n    normalized.push(part);\n  }\n  if (combinator) {\n    normalized.push(combinator, {});\n  }\n\n  return normalized;\n}\n\nfunction normalizeKey(key: StypSelector.Part | string): StypSelector.NormalizedPart {\n  if (typeof key === 'string') {\n    if (!key) {\n      return {};\n    }\n    return { s: key };\n  }\n  return normalizeStypSelectorPart(key);\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelectorPart(part: StypSelector.Part): StypSelector.NormalizedPart {\n\n  const ns = part.ns || undefined;\n  const i = part.i || undefined;\n  const c = normalizeClasses(part.c);\n  const u = normalizeSubSelectors(part.u);\n\n  return {\n    ns,\n    e: (part.e !== '*' || !ns && !i && !c && u && isPseudoSubSelector(u[0])) && part.e || undefined,\n    i,\n    c,\n    u,\n    s: part.s || undefined,\n    $: normalizeQualifiers(part.$),\n  };\n}\n\nfunction normalizeClasses(\n    classes: QualifiedName | readonly QualifiedName[] | undefined,\n): readonly [QualifiedName, ...QualifiedName[]] | undefined {\n  if (!classes) {\n    return;\n  }\n  if (isQualifiedName(classes)) {\n    return [classes];\n  }\n\n  const result = classes.filter(c => !!c);\n\n  return isNotEmptyArray(result) ? result.sort(compareNames) : undefined;\n}\n\nfunction normalizeSubSelectors(\n    subs: StypSubSelector | readonly StypSubSelector[] | undefined,\n): readonly [StypSubSelector.Normalized, ...StypSubSelector.Normalized[]] | undefined {\n  if (!subs) {\n    return;\n  }\n  if (/*#__INLINE__*/ isSubSelectorsArray(subs)) {\n\n    const result = subs.map(normalizeSubSelector);\n\n    return isNotEmptyArray(result) ? result : undefined;\n  }\n\n  return [normalizeSubSelector(subs)];\n}\n\nfunction isSubSelectorsArray(\n    subs: StypSubSelector | readonly StypSubSelector[],\n): subs is readonly StypSubSelector[] {\n  return typeof subs[0] !== 'string';\n}\n\nfunction normalizeSubSelector(sub: StypSubSelector): StypSubSelector.Normalized {\n  if (!isPseudoSubSelector(sub)) {\n    return sub;\n  }\n  if (sub.length < 3) {\n    return sub as StypSubSelector.Normalized;\n  }\n\n  const [prefix, name, ...params] = sub;\n\n  if (/*#__INLINE__*/ isSubSelectorParametersArray(params)) {\n    return [prefix, name, ...params.map(normalizeStypSelector)];\n  }\n\n  return [prefix, name, normalizeStypSelector(params)];\n}\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector.Normalized): sub is StypSubSelector.NormalizedPseudo;\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo;\n\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo {\n  return sub.length > 1 && (sub[0] === ':' || sub[0] === '::');\n}\n\nfunction isSubSelectorParametersArray(\n    param: StypSubSelector.Parameter | readonly StypSubSelector.Parameter[],\n): param is readonly StypSubSelector.Parameter[] {\n  return isReadonlyArray(param[0]);\n}\n\nfunction normalizeQualifiers(\n    qualifiers: string | readonly string[] | undefined,\n): readonly [string, ...string[]] | undefined {\n  if (!qualifiers) {\n    return;\n  }\n\n  if (!isReadonlyArray(qualifiers)) {\n    qualifiers = Array.from(exposeQualifier(qualifiers));\n  } else {\n    qualifiers = Array.from(new Set(flatMapIt(qualifiers, exposeQualifier))).sort();\n  }\n\n  return isNotEmptyArray(qualifiers) ? qualifiers : undefined;\n}\n\nconst noQualifiers: Set<string> = new Set();\n\nfunction exposeQualifier(qualifier: string): Set<string> {\n  if (!qualifier) {\n    return noQualifiers;\n  }\n\n  const eqIdx = qualifier.indexOf('=');\n  const name = eqIdx < 0 ? qualifier : qualifier.substring(0, eqIdx);\n  const exposed = new Set<string>();\n  let lastExposed: string | undefined;\n\n  for (const part of name.split(':')) {\n    if (lastExposed) {\n      lastExposed += ':' + part;\n    } else {\n      lastExposed = part;\n    }\n    exposed.add(lastExposed);\n  }\n  if (eqIdx >= 0) {\n    exposed.add(qualifier);\n  }\n\n  return exposed;\n}\n\nconst noKeyAndTail: [[]] = [[]];\n\n/**\n * @internal\n */\nexport function stypRuleKeyAndTail(\n    selector: StypSelector.Normalized,\n): readonly [[]] | readonly [StypRuleKey.Nested, StypSelector.Normalized?] {\n  if (!selector.length) {\n    return noKeyAndTail;\n  }\n\n  let i = 0;\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (;;) {\n\n    const part = selector[i++];\n\n    if (isCombinator(part)) {\n      combinator = part;\n      continue;\n    }\n\n    const key: StypRuleKey = combinator ? [combinator, part] : [part];\n\n    return [key, selector.slice(i)];\n  }\n}\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * @internal\n */\nexport function stypOuterSelector(\n    selector: StypSelector.Normalized,\n): StypSelector.Normalized | undefined {\n\n  let i = selector.length - 1;\n\n  if (i <= 0) {\n    return i ? undefined : rootSelector;\n  }\n\n  do {\n    --i;\n    switch (selector[i]) {\n      case '>':\n        return selector.slice(0, i);\n      case '+':\n      case '~':\n        --i;\n        continue;\n      default:\n        return selector.slice(0, i + 1);\n    }\n  } while (i > 0);\n\n  return;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { namesEqual, NamespaceDef, QualifiedName } from 'namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { normalizeStypSelectorPart } from './selector.impl';\n\n/**\n * CSS rule query.\n *\n * It may represent a selector like `element-name#id.class1.classN` with any of sub-parts omitted.\n *\n * Queries are used to grab a subset of matching rules from `StypRule`.\n *\n * All of its properties are optional.\n *\n * @category CSS Rule\n */\nexport interface StypQuery {\n\n  /**\n   * Element namespace.\n   */\n  readonly ns?: string | NamespaceDef;\n\n  /**\n   * Element name.\n   *\n   * This is the same as `*` when absent.\n   */\n  readonly e?: QualifiedName;\n\n  /**\n   * Element identifier.\n   */\n  readonly i?: QualifiedName;\n\n  /**\n   * Element class name or names.\n   */\n  readonly c?: QualifiedName | readonly QualifiedName[];\n\n  /**\n   * Qualifier or qualifiers.\n   */\n  readonly $?: string | readonly string[];\n\n}\n\nexport namespace StypQuery {\n\n  /**\n   * Normalized CSS rule query.\n   */\n  export type Normalized = StypQuery & StypSelector.NormalizedPart;\n\n}\n\n/**\n * Normalizes arbitrary CSS rule query.\n *\n * @category CSS Rule\n * @param query  CSS rule query to normalize.\n *\n * @returns Normalized CSS rule query.\n */\nexport function stypQuery(query: StypQuery): StypQuery.Normalized {\n  return normalizeStypSelectorPart(query);\n}\n\n/**\n * Checks whether the given structured CSS `selector` matches target `query`.\n *\n * @category CSS Rule\n * @param selector  Normalized structured CSS selector.\n * @param query  Normalized CSS rule query.\n *\n * @returns `true` if `selector` matches the `query`, or `false` otherwise.\n */\nexport function stypSelectorMatches(\n    selector: StypSelector.Normalized | StypPureSelector.Normalized,\n    query: StypQuery.Normalized,\n): boolean {\n  if (!selector.length) {\n    return false;\n  }\n\n  const part = selector[selector.length - 1] as StypSelector.NormalizedPart;\n\n  if (query.ns && part.ns !== query.ns) {\n    return false;\n  }\n  if (query.e && part.e !== query.e) {\n    return false;\n  }\n  if (query.i && part.i !== query.i) {\n    return false;\n  }\n  if (query.c && !classesMatch(part.c, query.c)) {\n    return false;\n  }\n  // noinspection RedundantIfStatementJS\n  if (query.$ && !classesMatch(part.$, query.$)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction classesMatch(\n    classes: readonly QualifiedName[] | undefined,\n    query: readonly QualifiedName[],\n): boolean | undefined {\n  return classes && query.every(qClass => classes.find(mClass => namesEqual(qClass, mClass)));\n}\n","import { StypSelector } from './index';\nimport { StypPureSelector } from './pure-selector';\nimport { normalizeStypSelector } from './selector.impl';\n\n/**\n * Converts normalized pure CSS selector part to normalized pure CSS selector.\n *\n * @category CSS Rule\n * @param selector  Normalized pure CSS selector part.\n *\n * @returns Normalized pure CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * Converts normalized structured CSS selector part to normalized structured CSS selector.\n *\n * @category CSS Rule\n * @param selector  Normalized CSS selector part.\n *\n * @returns Normalized structured CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * Normalizes arbitrary pure CSS selector.\n *\n * @param selector  CSS selector to normalize.\n *\n * @returns Normalized pure CSS selector.\n */\nexport function stypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * Normalizes arbitrary structured CSS selector.\n *\n * @param selector  CSS selector to normalize.\n *\n * @returns Normalized structured CSS selector.\n */\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized {\n  return normalizeStypSelector(selector);\n}\n","import cssesc from 'cssesc';\nimport {\n  css__naming,\n  html__naming,\n  id__naming,\n  NamespaceAliaser,\n  NamespaceDef,\n  newNamespaceAliaser,\n} from 'namespace-aliaser';\nimport { cssescId } from '../internal';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSelectorFormat } from './selector-text';\nimport { isCombinator, isPseudoSubSelector } from './selector.impl';\nimport { StypSubSelector } from './sub-selector';\n\nconst ruleKeyTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${cssescId(qualifier)}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypRuleKeyText(key: StypRuleKey): string {\n  return formatStypSelector(key, ruleKeyTextOpts);\n}\n\nconst displayTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${qualifier}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypSelectorDisplayText(selector: StypSelector.Normalized): string {\n  return formatStypSelector(selector, displayTextOpts);\n}\n\nconst defaultFormat: StypSelectorFormat = {};\n\n/**\n * @internal\n */\nexport function formatStypSelector(\n    selector: StypSelector.Normalized,\n    {\n      qualify,\n      nsAlias = newNamespaceAliaser(),\n    }: StypSelectorFormat = defaultFormat,\n): string {\n\n  const format: ItemFormat = { qualify, nsAlias };\n\n  return selector.reduce(\n      (result, item) => {\n        if (isCombinator(item)) {\n          return result + item;\n        }\n        if (result && !isCombinator(result[result.length - 1])) {\n          result += ' ';\n        }\n        return result + formatItem(item, format);\n      },\n      '',\n  );\n}\n\ninterface ItemFormat extends StypSelectorFormat {\n  nsAlias: NamespaceAliaser;\n}\n\nfunction formatItem(\n    item: StypSelector.NormalizedPart,\n    {\n      qualify,\n      nsAlias,\n    }: ItemFormat,\n): string {\n\n  const { ns, e, i, c, s, u, $ } = item;\n  let hasProperties = false;\n  let out = '';\n\n  if (i) {\n    hasProperties = true;\n    out += `#${cssescId(id__naming.name(i, nsAlias))}`;\n  }\n  if (c) {\n    hasProperties = true;\n    out = c.reduce<string>(\n        (result, className) => `${result}.${cssescId(css__naming.name(className, nsAlias))}`,\n        out,\n    );\n  }\n  if (u) {\n    hasProperties = true;\n\n    const subFormat: ItemFormat = { nsAlias };\n\n    out = u.reduce(\n        (result, sub) => formatSubSelector(result, sub, subFormat),\n        out,\n    );\n  }\n  if (s) {\n    hasProperties = true;\n    out += s;\n  }\n  if (qualify && $) {\n    out = $.reduce((result, qualifier) => result + qualify(qualifier), out);\n  }\n  if (ns) {\n\n    const alias = xmlNs(ns, nsAlias);\n\n    if (alias) {\n      out = `${alias}|${e || '*'}${out}`;\n    } else {\n      out = qualifyElement();\n    }\n  } else {\n    out = qualifyElement();\n  }\n\n  return out;\n\n  function qualifyElement(): string {\n    if (hasProperties) {\n      return `${e ? html__naming.name(e, nsAlias) : ''}${out}`;\n    }\n    return `${e ? html__naming.name(e, nsAlias) : '*'}${out}`;\n  }\n}\n\nfunction formatSubSelector(\n    out: string,\n    sub: StypSubSelector.Normalized,\n    format: ItemFormat,\n): string {\n  if (isPseudoSubSelector(sub)) {\n    out += sub[0] + sub[1];\n\n    const len = sub.length;\n\n    if (len > 2) {\n      out += '(' + formatStypSelector(sub[2], format);\n      for (let i = 3; i < sub.length; ++i) {\n        out += ',' + formatStypSelector(sub[i] as StypSubSelector.NormalizedParameter, format);\n      }\n      out += ')';\n    }\n\n    return out;\n  }\n\n  const [attrName, attrOp, attrVal, attrFlag] = sub;\n\n  out += '[' + cssescId(attrName);\n  if (attrOp) {\n    out += attrOp + cssesc(attrVal!, { quotes: 'double', wrap: true });\n  }\n  if (attrFlag) {\n    out += ' ' + attrFlag;\n  }\n\n  return out + ']';\n}\n\nfunction xmlNs(ns: string | NamespaceDef, nsAlias: NamespaceAliaser): string | undefined {\n  return typeof ns === 'string' ? ns : ns.url ? nsAlias(ns) : undefined;\n}\n","/**\n * @internal\n */\nexport const FIRST_RENDER_ORDER = -0xffff;\n\n/**\n * @internal\n */\nexport function isCSSRuleGroup(sheetOrRule: CSSStyleSheet | CSSRule): sheetOrRule is (CSSGroupingRule | CSSStyleSheet) {\n  return 'cssRules' in sheetOrRule;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { filterIt, itsReduction, ObjectEntry, overEntries } from 'a-iterable';\nimport { AfterEvent } from 'fun-events';\nimport { isNotEmptyArray } from '../internal';\nimport { StypProperties, StypRule } from '../rule';\nimport { mergeStypProperties } from '../rule/properties.impl';\nimport { StypSelector, stypSelector } from '../selector';\nimport { isCombinator } from '../selector/selector.impl';\nimport { stypSplitPriority, StypValue } from '../value';\nimport { StypRenderer } from './renderer';\nimport { FIRST_RENDER_ORDER, isCSSRuleGroup } from './renderer.impl';\nimport { StyleProducer } from './style-producer';\n\nclass AtRulesRenderer implements StypRenderer.Spec {\n\n  constructor(private readonly _rule: StypRule) {\n  }\n\n  read(properties: AfterEvent<[StypProperties]>): AfterEvent<[StypProperties]> {\n\n    let outer = this._rule.outer;\n\n    while (outer) {\n      properties = mergeStypProperties(outer.read().keepThru(onlyAtProperties), properties);\n      outer = outer.outer;\n    }\n\n    return properties;\n  }\n\n  render(producer: StyleProducer, properties: StypProperties): void {\n\n    const { selector } = producer;\n    let { target } = producer;\n\n    if (!isCSSRuleGroup(target)) {\n      producer.render(properties);\n      return;\n    }\n\n    let sheet: CSSGroupingRule | CSSStyleSheet = target;\n    const extracted = extractAtSelectors(selector);\n\n    if (!extracted) {\n      producer.render(properties);\n      return;\n    }\n\n    const [atSelectors, restSelector] = extracted;\n\n    for (const atSelector of atSelectors) {\n\n      const ruleIdx = sheet.insertRule(`${buildAtSelector(properties, atSelector)}{}`, sheet.cssRules.length);\n      const nested: CSSRule = sheet.cssRules[ruleIdx];\n\n      target = nested;\n      if (isCSSRuleGroup(nested)) {\n        sheet = nested;\n      }\n    }\n\n    producer.render(properties, { target, selector: restSelector });\n  }\n\n}\n\nfunction buildAtSelector(\n    properties: StypProperties,\n    [key, [names, customQuery]]: [string, [Set<string>, string?]],\n): string {\n\n  let query = '';\n  const addQuery = (q?: StypValue): void => {\n    if (q) {\n      if (query) {\n        query += ' and ';\n      }\n      query += q;\n    }\n  };\n\n  for (const name of names) {\n\n    const [namedQuery] = stypSplitPriority(properties[name]);\n\n    addQuery(namedQuery);\n  }\n\n  addQuery(customQuery);\n\n  return query ? `${key} ${query}` : key;\n}\n\n/**\n * CSS stylesheet renderer of at-rules like `@media` queries.\n *\n * At-rules are represented by qualifiers which names start with `@` symbol. Qualifier names are used as at-rules keys,\n * and their values - as queries. If the rest of the selector is not empty, then properties are rendered in CSS\n * rule nested inside at-rule. Otherwise the properties are rendered in at-rule.\n *\n * So, for example CSS rule with `{ c: 'screen-only', $: '@media=screen' }` selector would be rendered as\n * ```css\n * @media screen {\n *   .screen-only {\n *      \\/* CSS properties *\\/\n *   }\n * }\n * ```\n *\n * Another option is to use named at-rules qualifiers. When named qualifier is used, the corresponding property is\n * searched in CSS rule and all of its outer rules. The values of all matching properties are used as queries.\n *\n * So the above example could be written as: `{ c: 'screen-only', $: '@media:screen' }` if CSS rule (or its outer\n * one) contains property `@media:screen` with value `screen`.\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport const stypRenderAtRules: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  create(rule) {\n    return new AtRulesRenderer(rule);\n  },\n\n};\n\nfunction onlyAtProperties(properties: StypProperties): StypProperties {\n  return itsReduction(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          isAtEntry,\n      ),\n      (result: StypProperties.Mutable, [key, value]: ObjectEntry<StypProperties, string>) => {\n        result[key] = value;\n        return result;\n      },\n      {},\n  );\n}\n\nfunction isAtEntry(entry: ObjectEntry<StypProperties>): entry is ObjectEntry<StypProperties, string> {\n  return String(entry[0])[0] === '@';\n}\n\nfunction extractAtSelectors(\n    selector: StypSelector.Normalized,\n): [Map<string, [Set<string>, string?]>, StypSelector.Normalized] | undefined {\n\n  const atSelectors = new Map<string, [Set<string>, string?]>();\n  const rest: StypSelector.Mutable = [];\n\n  for (const part of selector) {\n    if (isCombinator(part)) {\n      rest.push(part);\n    } else {\n      rest.push(extractPartAtSelectors(part, atSelectors));\n    }\n  }\n\n  if (!atSelectors.size) {\n    return; // No at-rule qualifiers found.\n  }\n\n  return [atSelectors, stypSelector(rest)];\n}\n\nfunction extractPartAtSelectors(\n    part: StypSelector.NormalizedPart,\n    atSelectors: Map<string, [Set<string>, string?]>,\n): StypSelector.NormalizedPart {\n\n  const qualifiers = part.$;\n\n  if (!qualifiers) {\n    return part;\n  }\n\n  const restQualifies: string[] = [];\n\n  for (const qualifier of qualifiers) {\n    if (qualifier[0] === '@') {\n      addAtSelector(atSelectors, qualifier);\n    } else {\n      restQualifies.push(qualifier);\n    }\n  }\n\n  if (restQualifies.length === qualifiers.length) {\n    return part; // No at-rule qualifiers found\n  }\n  if (isNotEmptyArray(restQualifies)) {\n    return { ...part, $: restQualifies };\n  }\n\n  return { ...part, $: undefined };\n}\n\nfunction addAtSelector(atSelectors: Map<string, [Set<string>, string?]>, qualifier: string): void {\n\n  const eqIdx = qualifier.indexOf('=');\n  let name: string;\n  let query: string | undefined;\n\n  if (eqIdx < 0) {\n    name = qualifier;\n  } else {\n    name = qualifier.substring(0, eqIdx);\n    query = qualifier.substring(eqIdx + 1);\n  }\n\n  const colonIdx = name.indexOf(':');\n  const key = colonIdx < 0 ? name : name.substring(0, colonIdx);\n  const atSelector = atSelectors.get(key);\n\n  if (!atSelector) {\n    atSelectors.set(key, [new Set<string>().add(name), query]);\n  } else {\n\n    const [names, prevQuery] = atSelector;\n\n    names.add(name);\n    if (query) {\n      atSelector[1] = prevQuery ? `${prevQuery} and ${query}` : query;\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { overEntries } from 'a-iterable';\nimport { StypProperties } from '../rule';\nimport { stypSplitPriority, StypURL, StypValue } from '../value';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { StypRenderer } from './renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\nimport { StyleProducer } from './style-producer';\n\n/**\n * CSS stylesheet renderer of global at-rules.\n *\n * It renders at-rules that should stay at the top level:\n * - `@namespace`\n * - `@import`\n *\n * At-rule parameters are taken from root CSS rule properties and treated as following rules.\n *\n * **`@import:url`** property value is treated as media query and appended after stylesheet URL. I.e.\n * ```json\n * {\n *     \"@import:path/to/included.css\": \"screen\"\n * }\n * ```\n * becomes\n * ```css\n * @import url(path/to/included.css) screen;\n * ```\n *\n * **`@namespace`** property value is treated as default namespace URL. I.e.\n * ```json\n * {\n *     \"@namespace\": \"http://www.w3.org/1999/xhtml\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace url(http://www.w3.org/1999/xhtml);\n * ```\n *\n * **`@namespace:prefix`** property value is treated as namespace URL with the given prefix. I.e\n * ```json\n * {\n *     \"@namespace:svg\": \"http://www.w3.org/2000/svg\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace svg url(http://www.w3.org/2000/svg);\n * ```\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport const stypRenderGlobals: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER + 1,\n\n  needs: stypRenderAtRules,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const sheet = producer.styleSheet;\n    let importIndex = 0;\n    let nsIndex = 0;\n\n    for (const [k, v] of overEntries(properties)) {\n\n      const key = String(k);\n\n      if (key[0] === '@') {\n\n        const [value] = stypSplitPriority(v);\n        const importDelta = renderImport(sheet, importIndex, key, value);\n\n        importIndex += importDelta;\n        nsIndex += importDelta;\n\n        const url = StypURL.by(value);\n\n        if (url) {\n          nsIndex += renderDefaultNamespace(sheet, nsIndex, key, url);\n          nsIndex += renderNamespacePrefix(sheet, nsIndex, key, url);\n        }\n      }\n    }\n\n    producer.render(properties);\n  },\n\n};\n\nconst IMPORT_PREFIX = '@import:';\n\nfunction renderImport(\n    sheet: CSSStyleSheet,\n    index: number,\n    key: string,\n    value: StypValue,\n): number {\n  if (!key.startsWith(IMPORT_PREFIX)) {\n    return 0;\n  }\n\n  const url = new StypURL(key.substring(IMPORT_PREFIX.length));\n  let css = `@import ${url}`;\n\n  if (value) {\n    css += ' ' + value;\n  }\n\n  sheet.insertRule(css + ';', index);\n\n  return 1;\n}\n\nfunction renderDefaultNamespace(\n    sheet: CSSStyleSheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (key !== '@namespace') {\n    return 0;\n  }\n\n  sheet.insertRule(`@namespace ${url};`, index);\n\n  return 1;\n}\n\nconst NS_PREFIX = '@namespace:';\n\nfunction renderNamespacePrefix(\n    sheet: CSSStyleSheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (!key.startsWith(NS_PREFIX)) {\n    return 0;\n  }\n\n  const prefix = key.substring(NS_PREFIX.length);\n\n  sheet.insertRule(`@namespace ${prefix} ${url};`, index);\n\n  return 1;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from 'a-iterable';\nimport hyphenateStyleName from 'hyphenate-style-name';\nimport { StypProperties } from '../rule';\nimport { StypPriority, stypSplitPriority } from '../value';\nimport { StyleProducer } from './style-producer';\n\n/**\n * Renders CSS properties.\n *\n * This renderer is always present, so there is typically no need to use it explicitly.\n *\n * @category Rendering\n */\nexport function stypRenderProperties(producer: StyleProducer, properties: StypProperties): void {\n\n  const cssRule = producer.addRule() as CSSStyleRule;\n  const { style } = cssRule;\n\n  itsEach(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          notCustomProperty,\n      ),\n      ([k, v]) => {\n\n        const [value, priority] = stypSplitPriority(v);\n\n        style.setProperty(\n            hyphenateStyleName(k),\n            `${value}`,\n            priority >= StypPriority.Important ? 'important' : undefined,\n        );\n      },\n  );\n\n  producer.render(properties, { target: cssRule });\n}\n\nfunction notCustomProperty(entry: ObjectEntry<StypProperties>): entry is ObjectEntry<Required<StypProperties>, string> {\n\n  const [key, value] = entry;\n\n  if (value == null) {\n    return false;\n  }\n\n  const first = String(key)[0];\n\n  return first >= 'a' && first <= 'z' || first >= 'A' && first <= 'Z';\n}\n","import { isReadonlyArray } from '../internal';\nimport { StypRule } from '../rule';\nimport { stypRenderProperties } from './properties.renderer';\nimport { StypRenderer } from './renderer';\nimport { StypOptions } from './style-producer';\n\n/**\n * @internal\n */\nexport interface StypRendererSpecFactory extends StypRenderer.Factory {\n  create(rule: StypRule): StypRenderer.Spec;\n}\n\n/**\n * @internal\n */\nexport function stypRenderFactories(opts: StypOptions): readonly StypRendererSpecFactory[] {\n\n  const factories = new Map<StypRenderer, StypRendererSpecFactory>();\n\n  addRenderers(opts.renderer);\n  factories.delete(stypRenderProperties);\n\n  return [...factories.values(), rendererFactory(stypRenderProperties)].sort(compareRenderers);\n\n  function addRenderers(renderers: StypRenderer | readonly StypRenderer[] | undefined): void {\n    if (renderers) {\n      if (isReadonlyArray(renderers)) {\n        renderers.forEach(addRenderer);\n      } else {\n        addRenderer(renderers);\n      }\n    }\n  }\n\n  function addRenderer(renderer: StypRenderer): void {\n    if (factories.has(renderer)) {\n      return;\n    }\n\n    const factory = rendererFactory(renderer);\n\n    factories.set(renderer, factory);\n    addRenderers(factory.needs);\n  }\n}\n\nfunction rendererFactory(renderer: StypRenderer): StypRendererSpecFactory {\n  if (typeof renderer === 'function') {\n    return {\n      create() {\n        return { render: renderer };\n      },\n    };\n  }\n  if (isRendererFactory(renderer)) {\n    return {\n      order: renderer.order,\n      needs: renderer.needs,\n      create(rule) {\n        return rendererSpec(renderer.create(rule));\n      },\n    };\n  }\n\n  const render = renderer.render.bind(renderer);\n\n  return {\n    order: renderer.order,\n    needs: renderer.needs,\n    create() {\n      return { render };\n    },\n  };\n}\n\nfunction isRendererFactory(renderer: StypRenderer): renderer is StypRenderer.Factory {\n  return 'create' in renderer;\n}\n\nfunction compareRenderers(first: StypRenderer.Factory, second: StypRenderer.Factory): number {\n\n  const firstOrder = first.order || 0;\n  const secondOrder = second.order || 0;\n\n  return firstOrder > secondOrder ? 1 : firstOrder < secondOrder ? -1 : 0;\n}\n\nfunction rendererSpec(renderer: ReturnType<StypRenderer.Factory['create']>): StypRenderer.Spec {\n  return typeof renderer === 'function' ? { render: renderer } : renderer;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { itsReduction, mapIt } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { AfterEvent, afterSupplied, eventSupply, EventSupply, onSupplied } from 'fun-events';\nimport { NamespaceDef, newNamespaceAliaser } from 'namespace-aliaser';\nimport { newRenderSchedule } from 'render-scheduler';\nimport { StypProperties, StypRule, StypRules } from '../rule';\nimport { StypSelector, stypSelector, StypSelectorFormat, stypSelectorText } from '../selector';\nimport { isCombinator } from '../selector/selector.impl';\nimport { stypRenderFactories } from './options.impl';\nimport { StypRenderer } from './renderer';\nimport { isCSSRuleGroup } from './renderer.impl';\nimport { StyleProducer, StyleSheetRef, StypOptions } from './style-producer';\n\n/**\n * Produces and dynamically updates basic CSS stylesheets based on the given CSS rules.\n *\n * Unlike [[produceStyle]], this function does not enable renderers but the basic one which just renders CSS properties.\n * Only select renderers can be enabled. This can be used to save a bundle size.\n *\n * @category Rendering\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a [[StypRule.rules]] to render all rules,\n * or a result of [[StypRuleList.grab]] method call to render only matching ones.\n * @param opts  Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceBasicStyle(rules: StypRules, opts: StypOptions = {}): EventSupply {\n\n  const {\n    document = window.document,\n    rootSelector = { e: 'body' },\n    addStyleSheet = addStyleElement,\n    scheduler = newRenderSchedule,\n    nsAlias = newNamespaceAliaser(),\n  } = opts;\n  const {\n    parent = document.head,\n  } = opts;\n  const view = document.defaultView || window;\n  const format: StypSelectorFormat = { nsAlias };\n  const factories = stypRenderFactories(opts);\n  const renderSupply = renderRules(rules);\n  const trackSupply = trackRules();\n\n  return eventSupply()\n      .needs(renderSupply)\n      .needs(trackSupply)\n      .cuts(renderSupply)\n      .cuts(trackSupply);\n\n  function styleProducer(\n      rule: StypRule,\n      renderer: StypRenderer.Function,\n      production: {\n        styleSheet: CSSStyleSheet;\n        target: CSSStyleSheet | CSSRule;\n        selector: StypSelector.Normalized;\n      },\n  ): StyleProducer {\n\n    class Styp implements StyleProducer {\n\n      get document(): Document {\n        return document;\n      }\n\n      get parent(): ParentNode {\n        return parent;\n      }\n\n      get rule(): StypRule {\n        return rule;\n      }\n\n      get styleSheet(): CSSStyleSheet {\n        return production.styleSheet;\n      }\n\n      get target(): CSSStyleSheet | CSSRule {\n        return production.target;\n      }\n\n      get selector(): StypSelector.Normalized {\n        return production.selector;\n      }\n\n      nsAlias(ns: NamespaceDef): string {\n        return nsAlias(ns);\n      }\n\n      render(properties: StypProperties, options?: StypRenderer.Options): void {\n        if (!options) {\n          renderer(this, properties);\n        } else {\n          renderer(\n              styleProducer(\n                  rule,\n                  renderer,\n                  {\n                    styleSheet: production.styleSheet,\n                    target: options.target || production.target,\n                    selector: options.selector || production.selector,\n                  },\n              ),\n              properties,\n          );\n        }\n      }\n\n      addRule(_selector: StypSelector.Normalized = production.selector): CSSRule {\n\n        const target = production.target;\n\n        if (!isCSSRuleGroup(target)) {\n          return target;\n        }\n\n        const ruleIndex = target.insertRule(`${selectorText(_selector)}{}`, target.cssRules.length);\n\n        return target.cssRules[ruleIndex];\n      }\n\n    }\n\n    return new Styp();\n  }\n\n  function selectorText(selector: StypSelector.Normalized): string {\n    return stypSelectorText(selector, format);\n  }\n\n  function renderRules(rulesToRender: Iterable<StypRule>): EventSupply {\n    return itsReduction<EventSupply, EventSupply>(\n        mapIt(rulesToRender, renderRule),\n        (prev, supply) => eventSupply().cuts(supply).cuts(prev),\n        eventSupply(),\n    );\n  }\n\n  function trackRules(): EventSupply {\n\n    const supply = eventSupply();\n\n    return onSupplied(rules).to({\n      supply,\n      receive: (_ctx, added) => {\n        added.forEach(r => renderRule(r).needs(supply));\n      },\n    });\n  }\n\n  function renderRule(rule: StypRule): EventSupply {\n\n    const [reader, renderer] = rendererForRule(rule);\n    let sheetRef: StyleSheetRef | undefined;\n    const selector = ruleSelector(rule);\n    const schedule = scheduler({ window: view });\n\n    return reader.to(renderProperties).whenOff(removeStyle);\n\n    function renderProperties(properties: StypProperties): void {\n      schedule(() => {\n        if (sheetRef) {\n          clearProperties(sheetRef.styleSheet);\n        }\n\n        const producer = styleProducer(\n            rule,\n            renderer,\n            {\n              get styleSheet() {\n                if (!sheetRef) {\n                  sheetRef = addStyleSheet(producer);\n                }\n                return sheetRef.styleSheet;\n              },\n              get target() {\n                return this.styleSheet;\n              },\n              selector,\n            },\n        );\n\n        producer.render(properties);\n      });\n    }\n\n    function removeStyle(): void {\n      schedule(() => {\n\n        const lastSheetRef = sheetRef;\n\n        if (lastSheetRef) {\n          sheetRef = undefined;\n          return lastSheetRef.remove();\n        }\n        // Otherwise element is removed before anything rendered.\n        // Should never happen for properly constructed rule.\n      });\n    }\n\n    function clearProperties(sheet: CSSStyleSheet): void {\n      while (sheet.cssRules.length) {\n        sheet.deleteRule(sheet.cssRules.length - 1);\n      }\n    }\n  }\n\n  function ruleSelector(rule: StypRule): StypSelector.Normalized {\n\n    const selector = rule.selector;\n\n    if (!selector.length) {\n      // Use configured root selector\n      return stypSelector(rootSelector);\n    }\n    if (isCombinator(selector[0])) {\n      // First combinator is relative to root selector\n      return [...stypSelector(rootSelector), ...selector];\n    }\n\n    return selector;\n  }\n\n  function rendererForRule(rule: StypRule): [AfterEvent<[StypProperties]>, StypRenderer.Function] {\n\n    const specs = factories.map(factory => factory.create(rule));\n    const reader = specs.reduce(\n        (read, spec) => spec.read ? afterSupplied(spec.read(read)) : read,\n        rule.read(),\n    );\n\n    return [reader, renderAt(0)];\n\n    function renderAt(index: number): StypRenderer.Function {\n      return (producer, properties) => {\n\n        const nextIndex = index + 1;\n        let nextRenderer: StypRenderer.Function;\n\n        if (nextIndex === factories.length) {\n          nextRenderer = noop;\n        } else {\n          nextRenderer = renderAt(nextIndex);\n        }\n\n        const nextProducer = styleProducer(producer.rule, nextRenderer, producer);\n\n        specs[index].render(nextProducer, properties);\n      };\n    }\n  }\n}\n\nfunction addStyleElement(producer: StyleProducer): StyleSheetRef {\n\n  const { document, parent } = producer;\n  const element = document.createElement('style');\n\n  element.setAttribute('type', 'text/css');\n  element.append(document.createTextNode(''));\n\n  parent.append(element);\n\n  return {\n    styleSheet: element.sheet as CSSStyleSheet,\n    remove() {\n      element.parentElement!.removeChild(element);\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { NamespaceAliaser } from 'namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { stypSelector } from './selector-constructor';\nimport { formatStypSelector } from './selector-text.impl';\n\n/**\n * Structured CSS selector textual format.\n *\n * @category CSS Rule\n */\nexport interface StypSelectorFormat {\n\n  /**\n   * Qualifier formatting function. When present, it is called for each qualifier to build its\n   * textual representation. When unspecified, the qualifiers won't be attached to resulting CSS selector text.\n   *\n   * @param qualifier  Qualifier to format.\n   *\n   * @returns Textual representation of `qualifier`.\n   */\n  qualify?: (qualifier: string) => string;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * New instance will be created if not specified.\n   */\n  nsAlias?: NamespaceAliaser;\n\n}\n\n/**\n * Converts structured CSS selector to its textual representation.\n *\n * @category CSS Rule\n * @param selector  Target CSS selector.\n * @param format  CSS selector format.\n *\n * @returns CSS selector string.\n */\nexport function stypSelectorText(selector: StypSelector | StypPureSelector, format?: StypSelectorFormat): string {\n  return formatStypSelector(stypSelector(selector), format);\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { StypProperties } from '../rule';\nimport { StyleProducer } from './style-producer';\n\n/**\n * Renders raw CSS text. I.e. the contents of [[StypProperties.Generic.$$css]] property.\n *\n * It should be rendered before CSS properties normally to add the rendered rule as a first one.\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport function stypRenderText(producer: StyleProducer, properties: StypProperties): void {\n\n  const css = properties.$$css;\n\n  if (!css) {\n    producer.render(properties);\n  } else {\n\n    const cssRule = producer.addRule() as CSSStyleRule;\n\n    cssRule.style.cssText = css;\n    producer.render(properties, { target: cssRule });\n  }\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { filterIt, itsEmpty, itsReduction, mapIt, overArray } from 'a-iterable';\nimport { isPresent } from 'call-thru';\nimport { NamespaceDef } from 'namespace-aliaser';\nimport { StypProperties } from '../rule';\nimport { StypSelector } from '../selector';\nimport { isCombinator } from '../selector/selector.impl';\nimport { StypURL } from '../value';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { StypRenderer } from './renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\nimport { StyleProducer } from './style-producer';\n\n/**\n * CSS stylesheet renderer of global XML namespace definitions.\n *\n * Renders `@namespace` declarations for CSS selectors containing namespace definitions.\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport const stypRenderXmlNs: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  needs: stypRenderGlobals,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const xmlNsDefs = extractXmlNsDefs(producer.selector);\n\n    producer.render(itsEmpty(xmlNsDefs) ? properties : declareNss());\n\n    function declareNss(): StypProperties {\n      return itsReduction(xmlNsDefs, declareNs, { ...properties });\n    }\n\n    function declareNs(result: StypProperties.Mutable, ns: NamespaceDef): StypProperties.Mutable {\n\n      const alias = producer.nsAlias(ns);\n\n      result[`@namespace:${alias}`] = new StypURL(ns.url);\n\n      return result;\n    }\n  },\n\n};\n\nfunction extractXmlNsDefs(selector: StypSelector.Normalized): Iterable<NamespaceDef> {\n  return filterIt<NamespaceDef | null, NamespaceDef>(\n      mapIt(\n          overArray(selector),\n          part => !isCombinator(part) && part.ns && typeof part.ns !== 'string' ? part.ns : null,\n      ),\n      isPresent,\n  );\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { EventSupply } from 'fun-events';\nimport { isReadonlyArray } from '../internal';\nimport { StypRules } from '../rule';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { produceBasicStyle } from './produce-basic-style';\nimport { StypRenderer } from './renderer';\nimport { StypOptions } from './style-producer';\nimport { stypRenderText } from './text.renderer';\nimport { stypRenderXmlNs } from './xml-ns.renderer';\n\n/**\n * Produces and dynamically updates CSS stylesheets based on the given CSS rules.\n *\n * Appends `<style>` element(s) to the given parent DOM node (`document.head` by default) and updates them when CSS\n * rules change.\n *\n * This function enables all default renderers. E.g. the one supporting raw CSS text rules. If some of them are not\n * needed a [[produceBasicStyle]] variant of this function may be used instead.\n *\n * @category Rendering\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a [[StypRule.rules]] to render all rules,\n * or a result of [[StypRuleList.grab]] method call to render only matching ones.\n * @param opts  Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceStyle(rules: StypRules, opts: StypOptions = {}): EventSupply {\n  return produceBasicStyle(rules, { ...opts, renderer: defaultRenderers(opts.renderer) });\n}\n\nfunction defaultRenderers(renderer: StypRenderer | readonly StypRenderer[] | undefined): readonly StypRenderer[] {\n\n  const result: StypRenderer[] = [\n    stypRenderAtRules,\n    stypRenderXmlNs,\n    stypRenderGlobals,\n    stypRenderText,\n  ];\n\n  if (renderer) {\n    if (isReadonlyArray(renderer)) {\n      result.push(...renderer);\n    } else {\n      result.push(renderer);\n    }\n  }\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { StypQuery, StypRuleKey, StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { StypRules } from './rules';\n\n/**\n * CSS rule.\n *\n * Represents CSS selector and corresponding CSS properties.\n *\n * @category CSS Rule\n */\nexport abstract class StypRule implements EventKeeper<[StypProperties]> {\n\n  /**\n   * A reference to the root CSS rule.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * A reference to outer CSS rule.\n   *\n   * The outer rule is the one for enclosing element.\n   * I.e. for the rule with selector is `a b+c` the parent one is `a b`, while the outer one is `a`.\n   *\n   * This is `null` for the root rule and may be `null` for the rule removed from hierarchy.\n   */\n  abstract readonly outer: StypRule | null;\n\n  /**\n   * CSS selector of this rule.\n   */\n  abstract readonly selector: StypSelector.Normalized;\n\n  /**\n   * A key of this rule in the enclosing one.\n   */\n  abstract readonly key: StypRuleKey;\n\n  /**\n   * Whether this rule's properties are empty.\n   *\n   * This is `true` when the rule properties are constant and empty.\n   *\n   * Empty CSS rules returned from `rule()` method when there is no matching rule found.\n   */\n  abstract readonly empty: boolean;\n\n  /**\n   * Dynamic list of all CSS rules in hierarchy starting from this one.\n   */\n  abstract readonly rules: StypRuleHierarchy;\n\n  /**\n   * Build `AfterEvent` keeper of CSS properties of this rule.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of CSS properties map.\n   */\n  abstract read(): AfterEvent<[StypProperties]>;\n\n  /**\n   * Starts sending CSS properties of this rule and their updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of CSS properties map.\n   *\n   * @returns CSS properties supply.\n   */\n  abstract read(receiver: EventReceiver<[StypProperties]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[StypProperties]> {\n    return this.read();\n  }\n\n  /**\n   * Sets CSS properties of this rule.\n   *\n   * @param properties  CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: StypProperties.Spec): this;\n\n  /**\n   * Appends CSS properties to this rule.\n   *\n   * @param properties  CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  add(properties: StypProperties.Spec): this {\n    return this.rules.add([], properties) as this;\n  }\n\n  /**\n   * Clears CSS properties of this rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n  /**\n   * Removes this rule from hierarchy along with all nested rules.\n   *\n   * @param reason  Optional removal reason.\n   *\n   * @returns `this` (just removed) rule instance.\n   */\n  abstract remove(reason?: any): this;\n\n}\n\n/**\n * Dynamically updated list of CSS rules.\n *\n * This is an iterable of rules, an EventSender` of their updates, and an `EventKeeper` of itself.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleList implements StypRules, EventKeeper<[StypRuleList]> {\n\n  /**\n   * Builds an `AfterEvent` keeper of rule list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of this rule list.\n   */\n  abstract read(): AfterEvent<[StypRuleList]>;\n\n  /**\n   * Starts sending rule list and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of this rule list.\n   *\n   * @returns Rule list supply.\n   */\n  abstract read(receiver: EventReceiver<[StypRuleList]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[StypRuleList]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `OnEvent` sender of this rule list updates.\n   *\n   * The list updates receiver accepts two arguments:\n   * - An array of added rules\n   * - An array of removed rules.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of rule list updates.\n   */\n  abstract onUpdate(): OnEvent<[StypRule[], StypRule[]]>;\n\n  /**\n   * Starts sending updates to this rule list to the given `receiver`.\n   *\n   * @param receiver  Target receiver of updates to this rule list.\n   *\n   * @returns Rule list updates supply.\n   */\n  abstract onUpdate(receiver: EventReceiver<[StypRule[], StypRule[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n    return this.onUpdate();\n  }\n\n  abstract [Symbol.iterator](): IterableIterator<StypRule>;\n\n  /**\n   * Grabs rules from this list matching the given `query`.\n   *\n   * @param query  CSS rule query to match.\n   *\n   * @returns Dynamic list of rules in this list matching the given query.\n   */\n  abstract grab(query: StypQuery): StypRuleList;\n\n}\n\n/**\n * Dynamic list of all CSS rules in hierarchy starting from its root.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleHierarchy extends StypRuleList {\n\n  /**\n   * Dynamic list containing only root CSS rule.\n   *\n   * This list never changes actually.\n   */\n  abstract readonly self: StypRuleList;\n\n  /**\n   * Dynamic list of all CSS rules directly nested within the root one.\n   */\n  abstract readonly nested: StypRuleList;\n\n  /**\n   * Appends CSS properties to nested rule.\n   *\n   * Creates target rule if necessary.\n   *\n   * @param selector  Target rule selector.\n   * @param properties  Optional CSS properties specifier.\n   *\n   * @returns Modified CSS rule.\n   */\n  abstract add(selector: StypSelector, properties?: StypProperties.Spec): StypRule;\n\n  /**\n   * Returns nested CSS rule matching the given `selector`.\n   *\n   * @param selector  Target rule selector.\n   *\n   * @returns Either matching CSS rule, or `undefined` if not found.\n   */\n  abstract get(selector: StypSelector): StypRule | undefined;\n\n  /**\n   * Watches for CSS rule properties.\n   *\n   * The properties are empty when the watched rule does not exist.\n   *\n   * @param selector  CSS selector of watched rule.\n   *\n   * @returns An `AfterEvent` registrar of CSS properties receiver.\n   */\n  abstract watch(selector: StypSelector): AfterEvent<[StypProperties]>;\n\n}\n","import { filterIt, itsIterable } from 'a-iterable';\nimport { asis, valueProvider, valuesProvider } from 'call-thru';\nimport { AfterEvent, afterSent, EventReceiver, EventSupply, OnEvent, onEventBy, onSupplied } from 'fun-events';\nimport { stypQuery, StypQuery, stypSelectorMatches } from '../selector';\nimport { StypRule, StypRuleList } from './rule';\nimport { StypRules } from './rules';\n\n/**\n * @internal\n */\nexport class Rules extends StypRuleList {\n\n  private readonly _buildList: () => Iterable<StypRule>;\n  private readonly _filterArray: (rules: StypRule[]) => StypRule[];\n  // noinspection JSMismatchedCollectionQueryUpdate\n  private _ruleSet?: Set<StypRule>; // `undefined` updates are not tracked\n\n  constructor(private readonly _list: StypRules, ruleMatches?: (rule: StypRule) => boolean) {\n    super();\n    if (ruleMatches) {\n      this._buildList = () => filterIt(_list, ruleMatches);\n      this._filterArray = rules => rules.filter(ruleMatches);\n    } else {\n      this._buildList = () => _list;\n      this._filterArray = asis;\n    }\n  }\n\n  read(): AfterEvent<[StypRuleList]>;\n  read(receiver: EventReceiver<[StypRuleList]>): EventSupply;\n  read(receiver?: EventReceiver<[StypRuleList]>): AfterEvent<[StypRuleList]> | EventSupply {\n    return (this.read = afterSent<[Rules]>(\n        this.onUpdate().thru(valueProvider(this)),\n        valuesProvider(this),\n    ).F)(receiver);\n  }\n\n  onUpdate(): OnEvent<[StypRule[], StypRule[]]>;\n  onUpdate(receiver: EventReceiver<[StypRule[], StypRule[]]>): EventSupply;\n  onUpdate(receiver?: EventReceiver<[StypRule[], StypRule[]]>): OnEvent<[StypRule[], StypRule[]]> | EventSupply {\n    return (this.onUpdate = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n      const rules = this._ruleSet || (this._ruleSet = new Set(this._buildList()));\n\n      onSupplied(this._list).to({\n        supply: receiver.supply.whenOff(() => this._ruleSet = undefined),\n        receive: (context, added, removed) => {\n          added = this._filterArray(added);\n          removed = this._filterArray(removed);\n          if (removed.length || added.length) {\n            removed.forEach(rule => rules.delete(rule));\n            added.forEach(rule => rules.add(rule));\n            receiver.receive(context, added, removed);\n          }\n        },\n      });\n    }).share().F)(receiver);\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    if (this._ruleSet) {\n      // List changes are tracked.\n      return this._ruleSet.values();\n    }\n    // List changes are not currently tracked.\n    // Request the rules explicitly.\n    return itsIterable(this._buildList());\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function grabRules(list: StypRuleList, query: StypQuery): StypRuleList {\n\n  const q = stypQuery(query);\n\n  return new Rules(list, rule => stypSelectorMatches(rule.selector, q));\n}\n","import { itsIterable } from 'a-iterable';\nimport { valueProvider, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSent,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { StypQuery, StypRuleKey, stypSelector, StypSelector } from '../selector';\nimport { stypRuleKeyText } from '../selector/selector-text.impl';\nimport { stypOuterSelector, stypRuleKeyAndTail } from '../selector/selector.impl';\nimport { StypProperties } from './properties';\nimport { mergeStypProperties, noStypPropertiesSpec, stypPropertiesBySpec } from './properties.impl';\nimport { StypRule, StypRuleHierarchy, StypRuleList } from './rule';\nimport { StypRules } from './rules';\nimport { grabRules, Rules } from './rules.impl';\n\nclass AllRules extends StypRuleHierarchy {\n\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  readonly self: StypRuleList;\n\n  constructor(private readonly _root: StypRule$, readonly nested: NestedRules) {\n    super();\n    this.self = selfRuleList(_root, this);\n  }\n\n  read(): AfterEvent<[AllRules]>;\n  read(receiver: EventReceiver<[AllRules]>): EventSupply;\n  read(receiver?: EventReceiver<[AllRules]>): AfterEvent<[AllRules]> | EventSupply {\n    return (this.read = afterSent<[AllRules]>(\n        this._updates.on().thru(valueProvider(this)),\n        valuesProvider(this),\n    ).F)(receiver);\n  }\n\n  onUpdate(): OnEvent<[StypRule$[], StypRule$[]]>;\n  onUpdate(receiver: EventReceiver<[StypRule$[], StypRule$[]]>): EventSupply;\n  onUpdate(receiver?: EventReceiver<[StypRule$[], StypRule$[]]>): OnEvent<[StypRule$[], StypRule$[]]> | EventSupply {\n    return (this.onUpdate = this._updates.on().F)(receiver);\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule$> {\n    return iterateAllRules(this._root);\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  add(selector: StypSelector, properties?: StypProperties.Spec): StypRule$ {\n    return extendRule(this._root, stypSelector(selector), properties, true);\n  }\n\n  get(selector: StypSelector): StypRule$ | undefined {\n    return this._get(stypSelector(selector));\n  }\n\n  private _get(selector: StypSelector.Normalized): StypRule$ | undefined {\n\n    const [key, tail] = stypRuleKeyAndTail(selector);\n\n    if (!tail) {\n      return this._root;\n    }\n\n    const found = this.nested._rule(stypRuleKeyText(key));\n\n    if (!found) {\n      return;\n    }\n\n    return found.rules.get(tail);\n  }\n\n  watch(selector: StypSelector): AfterEvent<[StypProperties]> {\n\n    const request = stypSelector(selector);\n\n    return afterEventBy<[StypProperties]>(receiver => {\n\n      const tracker = trackValue<StypProperties>({});\n      const propertiesSupply = this.read().consume(() => {\n\n        const found = this._get(request);\n\n        return found && found\n            .read(properties => tracker.it = properties)\n            .whenOff(() => tracker.it = {});\n      });\n\n      return tracker.read(receiver).cuts(propertiesSupply);\n    }).share();\n  }\n\n  _add(rule: StypRule$, sendUpdate: boolean): void {\n    rule.rules.onUpdate((added, removed) => this._updates.send(added, removed));\n    if (sendUpdate) {\n      this._updates.send(allRules(rule), []);\n    }\n  }\n\n  _remove(reason?: any): void {\n\n    const removed = allRules(this._root);\n\n    this._updates.send([], removed);\n    removed.forEach(rule => {\n      rule.rules._updates.done(reason);\n      rule._spec.done(reason);\n    });\n  }\n\n}\n\nfunction selfRuleList(rule: StypRule$, all: AllRules): StypRuleList {\n\n  const onUpdate = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  const rules = [rule];\n\n  all.onUpdate((_added, removed) => {\n    if (removed[0] === rule) {\n      rules.length = 0;\n      onUpdate.send([], [rule]);\n    }\n  }).cuts(onUpdate);\n\n  class Self implements StypRules {\n\n    [OnEvent__symbol](): OnEvent<[StypRule$[], StypRule$[]]> {\n      return onUpdate.on();\n    }\n\n    [Symbol.iterator](): IterableIterator<StypRule$> {\n      return itsIterable(rules);\n    }\n\n  }\n\n  return new Rules(new Self());\n}\n\nfunction allRules(rule: StypRule$): StypRule$[] {\n  return Array.from(iterateAllRules(rule));\n}\n\nfunction *iterateAllRules(rule: StypRule$): IterableIterator<StypRule$> {\n  yield rule;\n  for (const nested of rule.rules.nested) {\n    yield* allRules(nested);\n  }\n}\n\nclass NestedRules extends StypRuleList {\n\n  readonly _all: AllRules;\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  private readonly _byKey = new Map<string, StypRule$>();\n\n  constructor(root: StypRule$) {\n    super();\n    this._all = new AllRules(root, this);\n  }\n\n  read(): AfterEvent<[NestedRules]>;\n  read(receiver: EventReceiver<[NestedRules]>): EventSupply;\n  read(receiver?: EventReceiver<[NestedRules]>): AfterEvent<[NestedRules]> | EventSupply {\n    return (this.read = afterSent<[NestedRules]>(\n        this._updates.on().thru(valueProvider(this)),\n        valuesProvider(this),\n    ).F)(receiver);\n  }\n\n  onUpdate(): OnEvent<[StypRule[], StypRule[]]>;\n  onUpdate(receiver: EventReceiver<[StypRule[], StypRule[]]>): EventSupply;\n  onUpdate(receiver?: EventReceiver<[StypRule[], StypRule[]]>): OnEvent<[StypRule[], StypRule[]]> | EventSupply {\n    return (this.onUpdate = this._updates.on().F)(receiver);\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule$> {\n    return this._byKey.values();\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  _rule(key: string): StypRule$ | undefined {\n    return this._byKey.get(key);\n  }\n\n  _add(key: string, rule: StypRule$, sendUpdate: boolean): void {\n    this._byKey.set(key, rule);\n    rule.rules.onUpdate((_added, removed) => {\n      if (removed[0] === rule) {\n        this._byKey.delete(key);\n        this._updates.send([], [rule]);\n      }\n    });\n    if (sendUpdate) {\n      this._updates.send([rule], []);\n    }\n    this._all._add(rule, sendUpdate);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class StypRule$ extends StypRule {\n\n  private readonly _root: StypRule$;\n  private _outer?: StypRule$ | null;\n  private readonly _selector: StypSelector.Normalized;\n  private readonly _key: StypRuleKey;\n  readonly _spec: ValueTracker<StypProperties.Builder>;\n  private readonly _nested: NestedRules;\n\n  get root(): StypRule$ {\n    return this._root;\n  }\n\n  get outer(): StypRule$ | null {\n    if (this._outer !== undefined) {\n      return this._outer;\n    }\n\n    const outerSelector = stypOuterSelector(this.selector);\n\n    return this._outer = outerSelector && this.root.rules.get(outerSelector) || null;\n  }\n\n  get selector(): StypSelector.Normalized {\n    return this._selector;\n  }\n\n  get key(): StypRuleKey {\n    return this._key;\n  }\n\n  get empty(): boolean {\n    return this._spec.it === noStypPropertiesSpec;\n  }\n\n  get rules(): AllRules {\n    return this._nested._all;\n  }\n\n  constructor(\n      root: StypRule$ | undefined,\n      selector: StypSelector.Normalized,\n      key: StypRuleKey,\n      spec: StypProperties.Builder = noStypPropertiesSpec,\n  ) {\n    super();\n    this._root = root || this;\n    this._selector = selector;\n    this._key = key;\n    this._spec = trackValue(spec);\n    this._nested = new NestedRules(this);\n  }\n\n  read(): AfterEvent<[StypProperties]>;\n  read(receiver: EventReceiver<[StypProperties]>): EventSupply;\n  read(receiver?: EventReceiver<[StypProperties]>): AfterEvent<[StypProperties]> | EventSupply {\n    return (this.read = this._spec.read().keepThru(builder => nextAfterEvent(builder(this))).F)(receiver);\n  }\n\n  set(properties?: StypProperties.Spec): this {\n    this._spec.it = properties ? r => stypPropertiesBySpec(r, properties) : noStypPropertiesSpec;\n    return this;\n  }\n\n  remove(reason?: any): this {\n    this.rules._remove(reason);\n    return this;\n  }\n\n}\n\nfunction extendRule(\n    rule: StypRule$,\n    targetSelector: StypSelector.Normalized,\n    properties: StypProperties.Spec | undefined,\n    sendUpdate: boolean,\n): StypRule$ {\n\n  const [key, tail] = stypRuleKeyAndTail(targetSelector);\n\n  if (!tail) {\n    // Target rule\n    rule._spec.it = extendSpec(rule, properties);\n    return rule;\n  }\n\n  const keyText = stypRuleKeyText(key);\n  const found = rule.rules.nested._rule(keyText);\n\n  if (found) {\n    return extendRule(found, tail, properties, sendUpdate);\n  }\n\n  const newNested = new StypRule$(rule.root, [...rule.selector, ...key], key);\n  const result = extendRule(newNested, tail, properties, false); // Send only a top-level update\n\n  rule.rules.nested._add(keyText, newNested, sendUpdate);\n\n  return result;\n}\n\nfunction extendSpec(rule: StypRule$, properties: StypProperties.Spec | undefined): StypProperties.Builder {\n\n  const oldSpec = rule._spec.it;\n\n  if (!properties) {\n    return oldSpec;\n  }\n\n  if (rule.empty) {\n    return r => stypPropertiesBySpec(r, properties);\n  }\n\n  return r => mergeStypProperties(oldSpec(r), stypPropertiesBySpec(r, properties));\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { stypPropertiesBySpec } from './properties.impl';\nimport { StypRule } from './rule';\nimport { StypRule$ as StypRule_ } from './rule.impl';\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * Constructs root CSS rule representing global CSS declarations.\n *\n * All other rules are nested within single root.\n *\n * The root CSS rule selector is empty.\n *\n * @category CSS Rule\n * @param properties  Initial CSS rule properties specifier.\n *\n * @returns New root CSS rule.\n */\nexport function stypRoot(properties?: StypProperties.Spec): StypRule {\n  return new StypRule_(undefined, rootSelector, [], properties ? r => stypPropertiesBySpec(r, properties) : undefined);\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { nextArg, valueProvider } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  isEventKeeper,\n} from 'fun-events';\nimport { StypSelector } from '../selector';\nimport { StypMapper } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * A type safe reference to CSS rule.\n *\n * Allows to access an modify CSS properties of the rule in a type safe manner.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties structure of referenced rule.\n */\nexport abstract class StypRuleRef<T extends StypProperties<T>> implements EventKeeper<[T]> {\n\n  /**\n   * Builds an `AfterEvent` keeper of CSS properties.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of typed CSS properties map.\n   */\n  abstract read(): AfterEvent<[T]>;\n\n  /**\n   * Starts sending CSS properties and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of types CSS properties map.\n   *\n   * @returns CSS properties supply.\n   */\n  abstract read(receiver: EventReceiver<[T]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read();\n  }\n\n  /**\n   * Sets CSS properties of the referenced rule.\n   *\n   * @param properties  CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Appends CSS properties to the references CSS rule.\n   *\n   * @param properties  CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract add(properties: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Clears CSS properties of the referenced rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n}\n\n/**\n * CSS rule referrer.\n *\n * This is a function that obtains CSS rule reference relative to the given root.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties interface of referenced rule.\n */\nexport type RefStypRule<T extends StypProperties<T>> =\n/**\n * @param root  Root CSS rule the constructed reference will be relative to.\n *\n * @returns CSS rule reference.\n */\n    (this: void, root: StypRule) => StypRuleRef<T>;\n\n\nclass StypRuleRef$<T extends StypProperties<T>> extends StypRuleRef<T> {\n\n  constructor(\n      private readonly _root: StypRule,\n      private readonly _selector: StypSelector,\n      private readonly _map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>,\n  ) {\n    super();\n  }\n\n  read(): AfterEvent<[T]>;\n  read(receiver: EventReceiver<[T]>): EventSupply;\n  read(receiver?: EventReceiver<[T]>): AfterEvent<[T]> | EventSupply {\n    return (this.read = afterAll({\n      ms: this._map(this._root),\n      ps: this._root.rules.watch(this._selector),\n    }).keepThru(\n        ({\n          ms: [_mappings],\n          ps: [_properties],\n        }) => nextArg<T>(StypMapper.map<T>(_mappings, _properties)),\n    ).F)(receiver);\n  }\n\n  add(properties: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector, properties);\n    return this;\n  }\n\n  set(properties?: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector).set(properties);\n    return this;\n  }\n\n}\n\n/**\n * @category CSS Rule\n */\nexport const RefStypRule = {\n\n  /**\n   * Constructs a CSS rule referrer that maps original CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam T  CSS properties structure of referenced rule.\n   * @param selector  CSS selector of target rule.\n   * @param mappings  Either a mappings of CSS properties, an event keeper sending such mappings, or a function\n   * returning one of them and accepting a root CSS rule as its only argument.\n   * The constructed reference will be relative to as its only parameter.\n   *\n   * @returns New CSS rule key instance.\n   */\n  by<T extends StypProperties<T>>(\n      selector: StypSelector,\n      mappings:\n          | StypMapper.Mappings<T>\n          | EventKeeper<[StypMapper.Mappings<T>]>\n          | ((this: void, root: StypRule) => StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>),\n  ): RefStypRule<T> {\n\n    let map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>;\n\n    if (typeof mappings === 'function') {\n      map = root => mappingsKeeper(mappings(root));\n    } else {\n      map = valueProvider(mappingsKeeper(mappings));\n    }\n\n    return root => new StypRuleRef$(root, selector, map);\n  },\n\n};\n\nfunction mappingsKeeper<T extends StypProperties<T>>(\n    mappings: StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>,\n): EventKeeper<[StypMapper.Mappings<T>]> {\n  return isEventKeeper(mappings) ? mappings : afterThe(mappings);\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { afterAll, AfterEvent, AfterEvent__symbol, EventKeeper, EventReceiver, EventSupply } from 'fun-events';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\nimport { RefStypRule, StypRuleRef } from './rule-ref';\n\n/**\n * Named CSS rule references complying to the CSS properties structure.\n *\n * Implements an event keeper interface by sending named CSS properties structures for each CSS rule reference.\n *\n * @category CSS Rule\n * @typeparam R  A type of target map of named CSS properties structures.\n */\nexport class StypRuleRefs<R extends StypRuleRefs.Struct<R>> implements EventKeeper<[R]> {\n\n  /**\n   * CSS rule references by name.\n   *\n   * Each property in this map is a CSS rule reference corresponding to the same named property in properties structure.\n   * I.e. it has the same name and the same properties structure of referenced rule.\n   */\n  readonly refs: { readonly [K in keyof R]: StypRuleRef<R[K]> };\n\n  /**\n   * Constructs named CSS rules by resolving CSS rule referrers.\n   *\n   * @typeparam R  A type of target map of named CSS properties structures.\n   * @param referrers  Named CSS rule referrers to resolve.\n   * @param root  A root CSS rule the references will be relative to.\n   *\n   * @returns New names CSS rules instance.\n   */\n  static by<R extends StypRuleRefs.Struct<R>>(\n      referrers: { readonly [K in keyof R]: RefStypRule<R[K]> },\n      root: StypRule,\n  ): StypRuleRefs<R>;\n\n  static by<R extends StypRuleRefs.Struct<R>>(\n      referrers: { readonly [name: string]: RefStypRule<any> },\n      root: StypRule,\n  ): StypRuleRefs<R> {\n\n    const refs: { [K in keyof R]?: StypRuleRef<any> } = {};\n\n    for (const key of Object.keys(referrers)) {\n      refs[key as keyof R] = referrers[key](root);\n    }\n\n    return new StypRuleRefs<R>(refs as { [K in keyof R]: StypRuleRef<R[K]> });\n  }\n\n  /**\n   * Constructs named CSS rules.\n   *\n   * @param refs  A map of named CSS rule references.\n   */\n  constructor(refs: { readonly [K in keyof R]: StypRuleRef<R[K]> }) {\n    this.refs = refs;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of named CSS properties structures for each CSS rule reference.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of map of named CSS properties structures.\n   */\n  read(): AfterEvent<[R]>;\n\n  /**\n   * Starts sending named CSS properties structures for each CSS rule reference and updates to the given `receiver`.\n   *\n   * @param receiver Target receiver of map of named CSS properties structures.\n   *\n   * @returns Supply of maps of named CSS properties structures.\n   */\n  read(receiver: EventReceiver<[R]>): EventSupply;\n  read(receiver?: EventReceiver<[R]>): AfterEvent<[R]> | EventSupply {\n\n    const fromAll: AfterEvent<[{ [K in keyof R]: [StypProperties<any>] }]> = afterAll(this.refs);\n\n    return (this.read = (fromAll.keepThru(flattenProperties) as AfterEvent<[R]>).F)(receiver);\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[R]> {\n    return this.read();\n  }\n\n}\n\nfunction flattenProperties<R extends StypRuleRefs.Struct<R>>(\n    propertiesMap: { readonly [name: string]: [StypProperties<any>] },\n): R {\n\n  const result: { [name: string]: StypProperties<any> } = {};\n\n  for (const name of Object.keys(propertiesMap)) {\n    result[name] = propertiesMap[name][0];\n  }\n\n  return result as R;\n}\n\nexport namespace StypRuleRefs {\n\n  /**\n   * A map of named CSS properties structures.\n   *\n   * Each property in this map corresponds to CSS rule reference with the same CSS properties structure.\n   */\n  export type Struct<R = { readonly [name: string]: StypProperties<any> }> = {\n    readonly [K in keyof R]: StypProperties<any>;\n  };\n\n  /**\n   * A map of named CSS rule referrers.\n   *\n   * These referrers then resolved to the same named CSS rule references.\n   *\n   * @typeparam R  A type of target map of named CSS properties structures.\n   */\n  export type Referrers<R extends Struct<R>> = {\n    readonly [K in keyof R]: RefStypRule<R[K]>;\n  };\n\n}\n","/**\n * @packageDocumentation\n * @module style-producer\n */\nimport { itsEach } from 'a-iterable';\nimport {\n  EventNotifier,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  isEventSender,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  onEventBy,\n  onNever,\n  onSupplied,\n} from 'fun-events';\nimport { StypRule, StypRuleList } from './rule';\nimport { Rules } from './rules.impl';\n\n/**\n * Dynamically updated CSS rule set.\n *\n * This is an iterable of rules, and an `EventSender` of their updates.\n *\n * @category CSS Rule\n */\nexport interface StypRules extends Iterable<StypRule>, EventSender<[StypRule[], StypRule[]]> {\n\n  [Symbol.iterator](): IterableIterator<StypRule>;\n\n}\n\nexport namespace StypRules {\n\n  /**\n   * A source of CSS rules.\n   *\n   * A dynamically updated CSS rule set can be constructed out of one or more sources by [[stypRules]] and\n   * [[lazyStypRules]] functions.\n   *\n   * This can be one of:\n   * - Single `StypRule` instance.\n   *   A `StypRule.rules.self` is used instead. I.e. a list containing only the rule itself.\n   * - A `StypRules` instance.\n   *   It is used as is.\n   * - A promise of one of the above.\n   *   The resolved value is used as an actual source.\n   *   No rules are available until resolution.\n   * - A function returning one of the above.\n   *   The function call result is used as an actual source.\n   *   The function will be called lazily upon rules access.\n   */\n  export type Source =\n      | StypRule\n      | StypRules\n      | Promise<StypRule | StypRules>\n      | ((this: void) => StypRule | StypRules | Promise<StypRule | StypRules>);\n\n}\n\n/**\n * @internal\n */\nconst noStypRules: StypRuleList = (/*#__PURE__*/ new Rules({\n  [OnEvent__symbol]() {\n    return onNever;\n  },\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return [][Symbol.iterator]();\n  },\n}));\n\n/**\n * Constructs dynamically updated CSS rule list out of rule sources.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function stypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(rulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction rulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? evalRules(source) : rulesByValue(source);\n}\n\n/**\n * Constructs lazily updated CSS rule list out of rule sources.\n *\n * In contrast to [[stypRules]] this one does not evaluate sources (e.g. does not call source functions) until there\n * is an updates receiver registered.\n *\n * This means that the constructed rule set won't necessary contain the rules from all sources originally. It will\n * report them as updates instead.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function lazyStypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(lazyRulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction lazyRulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? lazyRules(source) : rulesByValue(source);\n}\n\n/**\n * @internal\n */\nfunction rulesByList(sources: StypRules[]): StypRuleList {\n  if (sources.length === 1) {\n\n    const source = sources[0];\n\n    return source instanceof StypRuleList ? source : new Rules(source);\n  }\n  return new Rules({\n    *[Symbol.iterator](): IterableIterator<StypRule> {\n      for (const rules of sources) {\n        yield* rules;\n      }\n    },\n    [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n      return onEventBy<[StypRule[], StypRule[]]>(receiver => {\n        sources.forEach(source => onSupplied(source).to({\n          supply: eventSupply().needs(receiver.supply),\n          receive(context, added, removed) {\n            receiver.receive(context, added, removed);\n          },\n        }));\n      }).share();\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction evalRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  let _rules: StypRules | undefined;\n\n  return {\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return rules()[Symbol.iterator]();\n    },\n    [OnEvent__symbol]() {\n      return rules()[OnEvent__symbol]();\n    },\n  };\n\n  function rules(): StypRules {\n    return _rules || (_rules = rulesByValue(source()));\n  }\n}\n\n/**\n * @internal\n */\nfunction lazyRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    const rules = rulesByValue(source());\n\n    reportExistingRules(rules, ruleSet, receiver);\n    rules[OnEvent__symbol]().to({\n      supply: receiver.supply.whenOff(() => ruleSet.clear()),\n      receive(context, added, removed) {\n        removed.forEach(rule => ruleSet.delete(rule));\n        added.forEach(rule => ruleSet.add(rule));\n        receiver.receive(context, added, removed);\n      },\n    });\n  }).share();\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction rulesByValue(source: StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n  return source instanceof StypRule ? source.rules.self : isEventSender(source) ? source : asyncRules(source);\n}\n\n/**\n * @internal\n */\nfunction asyncRules(source: Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    let sourceSupply = noEventSupply();\n    const { supply } = receiver;\n\n    supply.cuts(sourceSupply)\n        .whenOff(() => ruleSet.clear());\n\n    source.then(resolution => {\n      if (!supply.isOff) {\n\n        const rules = resolution instanceof StypRule ? resolution.rules : resolution;\n\n        reportExistingRules(rules, ruleSet, receiver);\n\n        sourceSupply = onSupplied(rules).to({\n          receive(context, added, removed) {\n            removed.forEach(rule => ruleSet.delete(rule));\n            added.forEach(rule => ruleSet.add(rule));\n            receiver.receive(context, added, removed);\n          },\n        }).needs(supply);\n      }\n    });\n  }).share();\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction reportExistingRules(\n    rules: StypRules,\n    ruleSet: Set<StypRule>,\n    receiver: EventReceiver.Generic<[StypRule[], StypRule[]]>,\n): void {\n\n  const existing: StypRule[] = [];\n\n  itsEach(rules, rule => {\n    existing.push(rule);\n    ruleSet.add(rule);\n  });\n  if (existing.length) {\n\n    const dispatcher = new EventNotifier<[StypRule[], StypRule[]]>();\n\n    dispatcher.on(receiver);\n    dispatcher.send(existing, []); // Report existing rules as just added\n  }\n}\n","/**\n * @module delta-set\n */\n/**\n * A `Set` implementation that keeps a delta of changes made to it.\n *\n * @typeparam T  A type of elements of delta set.\n */\nexport class DeltaSet<T> extends Set<T> {\n\n  /** @internal */\n  private readonly _added: Set<T>;\n\n  /** @internal */\n  private readonly _removed: Set<T>;\n\n  /**\n   * Constructs new delta set.\n   *\n   * @param values  An iterable of elements be add to constructed delta set. Or `null` to add nothing.\n   */\n  constructor(values?: Iterable<T> | null) {\n    super();\n    this._added = new Set<T>(values);\n    this._removed = new Set<T>();\n    this._added.forEach(value => this.add(value));\n  }\n\n  /**\n   * Appends a new element with a specified value to the end of this delta set. Unless the set contains this element\n   * already.\n   *\n   * Records element addition and forgets its removal unless the set contains it already.\n   *\n   * @param value  The value of the element to add.\n   *\n   * @returns `this` delta set.\n   */\n  add(value: T): this {\n    if (!this.has(value)) {\n      this._added.add(value);\n      this._removed.delete(value);\n      super.add(value);\n    }\n    return this;\n  }\n\n  /**\n   * Removes the specified element from this delta set.\n   *\n   * Records element removal and forgets its addition if removal succeed.\n   *\n   * @param value  The value of the element to remove.\n   *\n   * @returns `true` if element removed successfully; or `false` if this set did not contain the element.\n   */\n  delete(value: T): boolean {\n    if (super.delete(value)) {\n      this._added.delete(value);\n      this._removed.add(value);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all elements from this delta set.\n   *\n   * Records all elements removal and forgets all elements additions.\n   */\n  clear(): void {\n    this._added.clear();\n    this.forEach(value => this._removed.add(value));\n    super.clear();\n  }\n\n  /**\n   * Applies changes to this delta set.\n   *\n   * First removes elements to `remove`. Then appends elements to `add`.\n   *\n   * Records all changes made.\n   *\n   * @param add  An iterable of elements to add.\n   * @param remove  An iterable of elements to remove.\n   *\n   * @returns `this` delta set.\n   */\n  delta(add: Iterable<T>, remove: Iterable<T> = []): this {\n    deltaSetDeltaReceiver(this)(add, remove);\n    return this;\n  }\n\n  /**\n   * Replays changes made to this set in target receiver.\n   *\n   * @param receiver  A receiver of changes delta. E.g. another `Set`.\n   *\n   * @returns `this` delta set.\n   */\n  redelta(receiver: DeltaSet.DeltaReceiver<T>): this {\n\n    const receive = typeof receiver === 'function' ? receiver : deltaSetDeltaReceiver(receiver);\n\n    receive([...this._added], [...this._removed]);\n\n    return this;\n  }\n\n  /**\n   * Forgets all changes made to this set.\n   *\n   * Does not alter the set contents.\n   *\n   * @returns `this` delta set.\n   */\n  undelta(): this {\n    this._added.clear();\n    this._removed.clear();\n    return this;\n  }\n\n}\n\nexport namespace DeltaSet {\n\n  /**\n   * A delta set changes receiver.\n   *\n   * This can be either an {@link DeltaReceiverObject object}, or a {@link DeltaReceiverFunction function}.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiver<T> =\n      | DeltaReceiverFunction<T>\n      | DeltaReceiverObject<T>;\n\n  /**\n   * A delta set changes receiver function.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiverFunction<T> =\n  /**\n   * @param added  An array of added elements.\n   * @param removed  An array of removed elements.\n   */\n      (this: void, added: T[], remove: T[]) => void;\n\n  /**\n   * A delta set changes receiver object.\n   *\n   * A `Set` class implements this interface.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export interface DeltaReceiverObject<T> {\n\n    /**\n     * Receives an element that has been added to delta set.\n     *\n     * @param value  The value of the added element.\n     */\n    add(value: T): void;\n\n    /**\n     * Receives an element that has been remove from delta set.\n     *\n     * @param value  The value of the removed element.\n     */\n    delete(value: T): void;\n\n  }\n\n}\n\n/**\n * @internal\n */\nfunction deltaSetDeltaReceiver<T>(\n    receiver: { add(value: T): void; delete(value: T): void; },\n): (this: void, add: Iterable<T>, remove: Iterable<T>) => void {\n  return (add, remove) => {\n    for (const removed of remove) {\n      receiver.delete(removed);\n    }\n    for (const added of add) {\n      receiver.add(added);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeparam Instance  Aspect instance type.\n * @typeparam Kind  Aspect application kind.\n */\nexport interface InAspect<Instance, Kind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeparam Value  Input value type.\n   * @param control  Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, Instance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   */\n  export interface Key<Instance, Kind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<Instance, Kind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam ConvertedInstance  A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<Value, Instance, ConvertedInstance extends Instance = Instance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: Instance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by [[InControl.convert]] method.\n     *\n     * @typeparam To  Converted input value type.\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<To>(target: InControl<To>): Applied<To, ConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of [[convertTo]] when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<Value>): Applied<Value, Instance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Result<OfInstance, OfValue, OfKind extends Kind> =\n        Applied<OfValue, Instance<OfInstance, OfValue, OfKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Instance<OfInstance, OfValue, OfKind extends Kind> =\n        ReturnType<Map<OfInstance, OfValue>[OfKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     */\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): OfInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance, Kind>,\n    build: <V>(this: void, control: InControl<V>, origin?: InControl<any>) => Instance,\n    instance?: Instance,\n    origin?: InControl<any>,\n): InAspect.Applied<Value, Instance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<To>(target: InControl<To>): InAspect.Applied<To, Instance> {\n      return inAspectSameOrBuild<To, Instance, Kind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<Value>): InAspect.Applied<Value, Instance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as Instance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance | null, Kind>,\n    instance: Instance | null = null,\n): InAspect.Applied<Value, Instance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<Instance>(instance: Instance): InAspect.Applied<any, Instance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from 'namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * [[InNamespaceAliaser.to]] converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @param nsAlias  Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { newRenderSchedule, RenderScheduler } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by [[InRenderScheduler.to]] converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @param scheduler  Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(scheduler: InRenderScheduler): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, flatMapIt, itsReduction, mapIt } from 'a-iterable';\nimport { isPresent, noop, valueProvider } from 'call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n */\nexport type InConverter<From, To> =\n    | InConverter.Conversion<From, To>\n    | InConverter.Factory<From, To>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<From, To>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Conversion<From, To> =\n      | InConverter.Value.Conversion<From, To>\n      | InConverter.Aspect.Conversion<To>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Value<From, To> =\n      | InConverter.Value.Factory<From, To>\n      | InConverter.Value.Conversion<From, To>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Aspect<From, To = From> =\n      | InConverter.Aspect.Conversion<To>\n      | InConverter.Aspect.Factory<From, To>;\n\n}\n\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => Conversion<From, To>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Conversion<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: From): To;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: To): From;\n\n  }\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To = From> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<To>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Conversion<Value> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, Value, Kind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeparam Value  Input value type.\n * @param converters  Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<Value>(\n    ...converters: InConverter.Aspect<Value, Value>[]\n): InConverter.Aspect.Factory<Value, Value>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter: InConverter.Value<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Value.Factory<From, To>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter?: InConverter<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To>;\n\nexport function intoConvertedBy<From, To>(\n    valueOrAspectConverter?: InConverter<From, To> | InConverter.Aspect<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To> {\n\n  type AspectApplicator = <Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = mapIt<InConverter.Aspect<From, To>, InConverter.Aspect.Factory<From, To>>(\n      converters,\n      inConverter,\n  );\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<From, To> => {\n\n    const conversion = converter(from, to);\n    const conversions = flatMapIt<InConverter.Conversion<From, To>>([\n        [conversion],\n        filterIt<InConverter.Aspect.Conversion<To> | undefined, InConverter.Aspect.Conversion<To>>(\n            mapIt(\n                aspectConverters,\n                acf => acf(from, to),\n            ),\n            isPresent,\n        ),\n    ]);\n\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<From, To>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeparam Value  Input value type.\n * @param aspects  Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<Value>(\n    aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[],\n): InConverter.Aspect.Factory<Value> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<Value>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion  Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<From, To>(\n    conversion: InConverter.Conversion<From, To>,\n): conversion is InConverter.Aspect.Conversion<To> {\n  return !(conversion as any).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Value<From, To>,\n): InConverter.Value.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Aspect<From, To>,\n): InConverter.Aspect.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To>,\n): InConverter.Factory<From, To>;\n\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { asis, noop } from 'call-thru';\nimport {\n  EventEmitter,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InControl<Value> extends ValueTracker<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: Value;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get [EventSupply__symbol](): EventSupply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n  ): InAspect.Application.Instance<Instance, Value, Kind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup  A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to set up.\n   * @param setup  A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<Instance, Value, Kind>, control: this) => void,\n  ): this;\n\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<Instance, Kind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<Instance, Value, Kind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<Value, Value>[]\n  ): InControl<Value>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control converter.\n   * @param and  Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(\n      by: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<To>;\n\n  convert<To>(\n      by?: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<Value> | InControl<To> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<Instance, Value, Kind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<Instance, Value, Kind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param _aspect  An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      _aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<Instance, Kind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<Instance, Kind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeparam Control  Input control type.\n   */\n  export type ValueType<Control extends InControl<any>> = Control extends InControl<infer Value> ? Value : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<From, To> extends InControl<To> {\n\n  private readonly _supply: EventSupply;\n  private readonly _on = new EventEmitter<[To, To]>();\n  private readonly _it: ValueTracker<[To, number]>;\n  protected readonly _applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  constructor(src: InControl<From>, by: InConverter.Factory<From, To>) {\n    super();\n    this._supply = eventSupply().needs(src);\n\n    let lastRev = 0;\n    let backward: From | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: From) => To;\n    let get: (value: To) => From;\n    let convertAspect: <Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    if (isInAspectConversion(conversion)) {\n      set = asis as (value: From) => To;\n      get = asis as (value: To) => From;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    eventSupplyOf(this._it).needs(this._supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply;\n  }\n\n  get it(): To {\n    return this._it.it[0];\n  }\n\n  set it(value: To) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  on(): OnEvent<[To, To]>;\n  on(receiver: EventReceiver<[To, To]>): EventSupply;\n  on(receiver?: EventReceiver<[To, To]>): OnEvent<[To, To]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { EventReceiver, EventSupply, eventSupply, EventSupply__symbol, OnEvent } from 'fun-events';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nclass InSameValueControl<Value> extends InControl<Value> {\n\n  private _supply?: EventSupply;\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply || (this._supply = eventSupply().needs(this._control));\n  }\n\n  get it(): Value {\n    return this._control.it;\n  }\n\n  set it(value: Value) {\n    this._control.it = value;\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._control.on().F)(receiver);\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @param control  Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<Value>(control: InControl<Value>): InControl<Value> {\n  return new InSameValueControl(control);\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n *\n * @category Control\n */\nexport abstract class AbstractInControl<Value> extends InControl<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<Value>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender, EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InContainer<Value> extends AbstractInControl<Value> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   *\n   * @typeparam L  Input container layout interface.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * Builds an `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container updates sender.\n   */\n  abstract on(): OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * Starts sending container updates to the given receiver.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * @param receiver  Target container updates receiver.\n   *\n   * @returns Container updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InContainer.Entry[], InContainer.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container contents snapshot keeper.\n   */\n  abstract read(): AfterEvent<[InContainer.Snapshot]>;\n\n  /**\n   * Starts sending container contents and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of container snapshot updates.\n   *\n   * @returns Container contents supply.\n   */\n  abstract read(receiver: EventReceiver<[InContainer.Snapshot]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read();\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of parent updates.\n   */\n  abstract on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * Starts sending parent updates to the given `receiver`.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * @param receiver  Target parent updates receiver.\n   *\n   * @returns Parent updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of control parents.\n   */\n  abstract read(): AfterEvent<[InParents.All]>;\n\n  /**\n   * Starts sending control parents and updates to the given `receiver`\n   *\n   * @param receiver  Target control parents receiver.\n   *\n   * @returns Control parents supply.\n   */\n  abstract read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read();\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry  Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): EventSupply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  private readonly _map = new Map<InParents.Entry, EventSupply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    eventSupplyOf(this._on).needs(this._control);\n  }\n\n  add(entry: InParents.Entry): EventSupply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = eventSupply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n  on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InParents.Entry[], InParents.Entry[]]>,\n  ): OnEvent<[InParents.Entry[], InParents.Entry[]]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  read(): AfterEvent<[InParents.All]>;\n  read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n  read(receiver?: EventReceiver<[InParents.All]>): AfterEvent<[InParents.All]> | EventSupply {\n\n    const allParents = (): IterableIterator<InParents.Entry> => this._map.keys();\n\n    return (this.read = afterSent(\n        this.on().thru(allParents),\n        () => [allParents()],\n    ).F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, EventReceiver, EventSupply } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport abstract class InElement<Value, Elt = HTMLElement> extends AbstractInControl<Value> {\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: Elt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of user input.\n   *\n   * @returns `AfterEvent` keeper of user input.\n   */\n  abstract input(): AfterEvent<[InElement.Input<Value>]>;\n\n  /**\n   * Starts sending user input and updates to the given `receiver`.\n   *\n   * @param receiver  Target user input receiver.\n   *\n   * @returns User input supply.\n   */\n  abstract input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<Value, any>,\n        ) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Input<Value> {\n\n    /**\n     * The value user entered.\n     */\n    value: Value;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt } from 'a-iterable';\nimport { nextArgs, NextCall, nextSkip, valuesProvider } from 'call-thru';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * Creates an `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of input mode updates.\n   */\n  abstract on(): OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * Starts sending input mode updates to the given `receiver`\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * @param receiver  Target input mode updates receiver.\n   *\n   * @returns Input mode updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input mode.\n   */\n  abstract read(): AfterEvent<[InMode.Value]>;\n\n  /**\n   * Starts sending input mode and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of input mode.\n   *\n   * @returns Input mode supply.\n   */\n  abstract read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read();\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode  Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source  A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): EventSupply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason  Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.done(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._tracker);\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n      case 'off':\n      case 'ro':\n      case '-on':\n      case '-ro':\n        break;\n      default:\n        value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    return (this.on = this._tracker.on().F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on().thru(() => this._all),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.keepThru(\n        (set: Set<AfterEvent<[InMode.Value]>>) => nextAfterEvent(afterEach(...set)),\n        mergeInModes,\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): EventSupply {\n\n    const supply = eventSupply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    eventSupplyOf(this.own).needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read().keepThru_(parentsInMode));\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  read(): AfterEvent<[InMode.Value]>;\n  read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n  read(receiver?: EventReceiver<[InMode.Value]>): AfterEvent<[InMode.Value]> | EventSupply {\n\n    let last: InMode.Value = 'on';\n\n    return (this.read = afterSent<[InMode.Value]>(\n            afterAll({\n              derived: this._derived.read,\n              own: this.own,\n            }).thru(\n                ({\n                  derived: [derived],\n                  own: [own],\n                }) => {\n\n                  let next: InMode.Value;\n\n                  if (own === 'off' || derived === 'off') {\n                    next = 'off';\n                  } else {\n\n                    let off = false;\n\n                    if (own[0] === '-') {\n                      off = true;\n                      own = own.substring(1) as InMode.Value;\n                    }\n                    if (derived[0] === '-') {\n                      off = true;\n                      derived = derived.substring(1) as InMode.Value;\n                    }\n                    next = derived === 'ro' ? 'ro' : own;\n                    if (off) {\n                      next = '-' + next as InMode.Value;\n                    }\n                  }\n\n                  return last === next ? nextSkip() : nextArgs(last = next);\n                },\n            ),\n            valuesProvider<[InMode.Value]>(last),\n        ).F\n    )(receiver);\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    let lastUpdate: InMode.Value = 'on';\n\n    return (this.on = this.read().thru(value => {\n\n      const old = lastUpdate;\n\n      return old === value ? nextSkip() : nextArgs(lastUpdate = value, old);\n    }).F)(receiver);\n  }\n\n  derive(source: InMode.Source): EventSupply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control))\n            .tillOff(this._control),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off' : (\n          element.getAttribute('readonly') != null ? 'ro' : 'on'\n      );\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n    case 'off':\n      element.setAttribute('disabled', '');\n      break;\n    case 'ro':\n    case '-ro':\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      element.setAttribute('readonly', '');\n      break;\n    default:\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('disabled', '');\n      element.removeAttribute('disabled');\n      // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n      element.setAttribute('readonly', '');\n      element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): NextCall<OnEventCallChain, [InMode.Value]> {\n\n  const parentList = Array.from(parents);\n\n  if (!parentList.length) {\n    return nextArgs('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return nextAfterEvent(afterEach(...parentModes).keepThru_(mergeInModes));\n}\n\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...flatMapIt<InMode.Value>(modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes  Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n      case 'off':\n        return 'off';\n      case 'ro':\n        ro = true;\n        break;\n      case '-on':\n        off = true;\n        break;\n      case '-ro':\n        off = true;\n        ro = true;\n        break;\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll, AfterEvent } from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport type InData<Value> = AfterEvent<[InData.DataType<Value>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <V>(ctrl: InControl<V>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).keepThru(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? nextArgs(value as any)\n            : nextArgs(),\n    ));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<Value, InData<Value>, InData<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeparam Value  Input value type.\n   */\n  export type DataType<Value> =\n      | (Value extends object ? { [K in keyof Value]?: DataType<Value[K]> } : Value)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, itsIterable, mapIt, overEntries } from 'a-iterable';\nimport { nextArg, nextArgs, NextCall, noop } from 'call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  nextAfterEvent,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroup<Model extends object> extends InContainer<Model> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<Model>;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<Instance, Model, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Controls<Model> = {\n    readonly [K in keyof Model]?: InControl<Model[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Entry<Model, K extends keyof Model = any> = readonly [K, InControl<Model[K]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export interface Snapshot<Model> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<Model>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key  Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<Model>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>, EventKeeper<[InGroup.Snapshot<Model>]> {\n\n  abstract on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  abstract on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n\n  abstract read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  abstract read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @param key  A key of input control to set. I.e. corresponding model property key.\n   * @param control  Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<K extends keyof Model>(key: K, control: InControl<Model[K]> | undefined): EventSupply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls  A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<Model>): EventSupply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key  A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof Model): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<Model> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<Model>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, EventSupply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<Model> implements InGroup.Snapshot<Model> {\n\n  constructor(private readonly _map: Map<keyof Model, InGroupEntry>) {\n  }\n\n  get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<Model>[K];\n  }\n\n  [Symbol.iterator](): IterableIterator<InControl<any>> {\n    return itsIterable(mapIt(this._map.values(), ([control]) => control));\n  }\n\n  entries(): IterableIterator<InGroup.Entry<Model>> {\n    return itsIterable(mapIt(this._map.entries(), ([key, [control]]) => [key, control]));\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<Model extends object> {\n\n  readonly _supply = eventSupply();\n  private _map = new Map<keyof Model, InGroupEntry>();\n  private _shot?: InGroupSnapshot<Model>;\n\n  constructor(private readonly _controls: InGroupControlControls<Model>) {\n  }\n\n  set<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]> | undefined,\n      added: [keyof Model, InGroupEntry][],\n      removed: [keyof Model, InGroupEntry][],\n  ): EventSupply {\n\n    const replaced = this._map.get(key);\n    let supply: EventSupply;\n\n    if (control) {\n      supply = eventSupply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = noEventSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]>,\n      supply: EventSupply,\n  ): InGroupEntry {\n    return [\n      control,\n      eventSupply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof Model, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof Model, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<Model> {\n    return this._shot || (this._shot = new InGroupSnapshot<Model>(this._map));\n  }\n\n  clear(): [keyof Model, InGroupEntry][] {\n\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<Model extends object> extends InGroupControls<Model> {\n\n  private readonly _map: InGroupMap<Model>;\n  private readonly _updates = new EventEmitter<[[keyof Model, InGroupEntry][], [keyof Model, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<Model>) {\n    super();\n\n    const applyModelToControls = (model: Model): void => {\n      this.read().once(snapshot => {\n\n        const withValues = new Set<keyof Model>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<Model>(this);\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>,\n  ): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]> | EventSupply {\n    return (this.on = this._updates.on().thru(\n        (added, removed) => nextArgs(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ).F)(receiver);\n  }\n\n  read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n  read(receiver?: EventReceiver<[InGroup.Snapshot<Model>]>): AfterEvent<[InGroup.Snapshot<Model>]> | EventSupply {\n    return (this.read = afterSent(\n        this._updates.on().thru(\n            () => this._map.snapshot(),\n        ),\n        () => [this._map.snapshot()],\n    ).F)(receiver);\n  }\n\n  set<K extends keyof Model>(\n      keyOrControls: K | InGroup.Controls<Model>,\n      newControl?: InControl<Model[K]> | undefined,\n  ): EventSupply {\n\n    const group = this._group;\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n    let supply: EventSupply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = eventSupply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: Model | undefined;\n\n      added.forEach(([key, [control, supply]]) => {\n        control.aspect(InParents)\n            .add({ parent: group })\n            .needs(supply)\n            .cuts(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(([key, [control, supply]]) => {\n        control.read().tillOff(supply).to(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<Model extends object>(\n    [key, [control]]: [keyof Model, InGroupEntry],\n): InGroup.Entry<Model> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<Model extends object> extends InGroup<Model> {\n\n  private readonly _model: ValueTracker<Model>;\n  readonly controls: InGroupControlControls<Model>;\n\n  constructor(\n      model: Model,\n      opts: {\n        readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    eventSupplyOf(this).whenOff(() => this.controls.clear());\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._model);\n  }\n\n  get it(): Model {\n    return this._model.it;\n  }\n\n  set it(value: Model) {\n    this._model.it = value;\n  }\n\n  on(): OnEvent<[Model, Model]>;\n  on(receiver: EventReceiver<[Model, Model]>): EventSupply;\n  on(receiver?: EventReceiver<[Model, Model]>): OnEvent<[Model, Model]> | EventSupply {\n    return (this.on = this._model.on().F)(receiver);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<Model extends object>(group: InGroup<Model>): InData<Model> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).keepThru_(\n      readInGroupData,\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<Model extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<Model>];\n      model: [Model];\n      mode: [InMode.Value];\n    },\n): NextCall<OnEventCallChain, [InData.DataType<Model>?]> {\n  if (!InMode.hasData(mode)) {\n    return nextArgs();\n  }\n\n  const csData: { [key in keyof Model]: InData<any> } = {} as any;\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof Model] = control.aspect(InData);\n  });\n\n  return nextAfterEvent(afterAll(csData).keepThru(controlsData => {\n\n    const data: Partial<Model> = { ...model };\n\n    itsEach(overEntries(controlsData), ([key, [controlData]]) => {\n      data[key] = controlData;\n    });\n\n    return nextArg(data as InData.DataType<Model>);\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n * @param model  Initial model of the group.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<Model extends object>(\n    model: Model,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n    } = {},\n): InGroup<Model> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<OfValue extends object ? OfValue : never> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { AfterEvent, afterThe } from 'fun-events';\n\n/**\n * @internal\n */\nconst _requireNothing = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return _requireNothing;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { CallChain, nextArgs, NextCall, valueProvider } from 'call-thru';\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n */\nexport type InValidator<Value> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<Value>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<Value>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Simple<Value> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control  Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<Value>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n * @param validator  Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<Value>(\n    validator: InValidator<Value>,\n): (this: void, control: InControl<Value>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n  return control => control.read().keepThru(simpleInValidator(control, validator));\n}\n\n/**\n * @internal\n */\nfunction simpleInValidator<Value>(\n    control: InControl<Value>,\n    validator: InValidator.Simple<Value>,\n): (value: Value) => NextCall<CallChain, InValidation.Message[]> {\n  return () => {\n\n    const messages = validator.validate(control);\n\n    return messages == null\n        ? nextArgs()\n        : Array.isArray(messages)\n            ? nextArgs(...messages)\n            : nextArgs(messages);\n  };\n}\n","import { flatMapIt, itsEach } from 'a-iterable';\nimport { asis, noop, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSupply,\n  eventSupply,\n} from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<Value> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<Value>) => EventSupply;\n\n  constructor(control: InControl<Value>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, EventSupply>();\n    const validatorMessages = new Map<InValidator<Value>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => void = noop;\n\n    this._messages = afterEventBy(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider()).to(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => {\n\n        const supply = validator.to(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).share().tillOff(control);\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = eventSupply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values(), asis);\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { flatMapIt, itsEach, mapIt, overEntries } from 'a-iterable';\nimport { nextArgs, NextCall } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  nextAfterEvent,\n  OnEventCallChain,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild<Value, InValidation<Value>, 'validation'>(\n        control,\n        InValidation,\n        <V>(ctrl: InControl<V>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<V>(ctrl);\n\n          if (origin) {\n\n            const from = origin.aspect(InValidation);\n\n            validation.by(from.read().keepThru(result => nextArgs(...result.messages())));\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InValidation<Value> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @return `AfterEvent` keeper of validation result keeper.\n   */\n  abstract read(): AfterEvent<[InValidation.Result]>;\n\n  /**\n   * Starts sending validation result and updates to the given `receiver`\n   *\n   * @param receiver  Target validation result receiver.\n   *\n   * @returns Validation results supply.\n   */\n  abstract read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read();\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators  Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<Value>[]): EventSupply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code  Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code  Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes  Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator]() {\n    return [][Symbol.iterator]();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    itsEach(\n        messages,\n        message => {\n\n          let nonEmpty = false;\n\n          itsEach(overEntries(message), ([code, codePresent]) => {\n            if (codePresent) {\n              nonEmpty = true;\n\n              const prev = this._byCode.get(code);\n\n              if (prev) {\n                prev.push(message);\n              } else {\n                this._byCode.set(code, [message]);\n              }\n            }\n          });\n\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          if (nonEmpty) {\n            this._all.push(message);\n          }\n        },\n    );\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): IterableIterator<InValidation.Message> {\n    return this._all[Symbol.iterator]();\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages  Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<Value> extends InValidation<Value> {\n\n  readonly _messages: InValidationMessages<Value>;\n\n  constructor(control: InControl<Value>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    const container = control.aspect(InContainer);\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n\n  }\n\n  by(...validators: InValidator<Value>[]): EventSupply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n  read(): AfterEvent<[InValidation.Result]>;\n  read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n  read(receiver?: EventReceiver<[InValidation.Result]>): AfterEvent<[InValidation.Result]> | EventSupply {\n    return (this.read = afterSupplied(this._messages).keepThru(inValidationResult).F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read().keepThru(\n      nestedInValidations,\n      combineInValidationResults,\n  );\n}\n\n/**\n * @internal\n */\nfunction nestedInValidations(\n    controls: InContainer.Snapshot,\n): NextCall<OnEventCallChain, [InValidation.Result][]> {\n  return nextAfterEvent(afterEach(...mapIt(controls, control => control.aspect(InValidation))));\n}\n\n/**\n * @internal\n */\nfunction combineInValidationResults(\n    ...results: [InValidation.Result][]\n): NextCall<OnEventCallChain, InValidation.Message[]> {\n  return nextArgs<InValidation.Message[]>(\n      ...flatMapIt(mapIt(results, result => result[0])),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @param validators  Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<Value>(...validators: InValidator<Value>[]): InValidator<Value> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<Value>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { EventKeeper } from 'fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read().keepThru(value => value ? nextArgs() : { missing: 'missing' })\n      : requirePresent;\n}\n","import { asis, nextArgs, nextSkip } from 'call-thru';\nimport {\n  AfterEvent,\n  afterSent,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n} from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport class AbstractInElement<Value, Elt extends HTMLElement> extends InElement<Value, Elt> {\n\n  readonly events: DomEventDispatcher;\n  private readonly _get: (this: AbstractInElement<Value, Elt>) => Value;\n  private readonly _set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n  private readonly _input: EventEmitter<[InElement.Input<Value>, Value]> = new EventEmitter();\n  private _value: Value;\n  private _update: (value: Value, oldValue: Value) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element  HTML input element the constructed control is based on.\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get  Input value getter.\n   * @param set  Input value setter.\n   */\n  constructor(\n      readonly element: Elt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n        readonly get: (this: AbstractInElement<Value, Elt>) => Value;\n        readonly set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: Value, oldValue: Value): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    eventSupplyOf(this.events).needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    function update(input: InElement.Input<Value>, oldValue: Value): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<Value>, Value] | undefined;\n\n        // Record corrections\n        self._update = (newValue: Value, old: Value) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._input);\n  }\n\n  get it(): Value {\n    return this._get();\n  }\n\n  set it(value: Value) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  input(): AfterEvent<[InElement.Input<Value>]>;\n  input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n  input(receiver?: EventReceiver<[InElement.Input<Value>]>): AfterEvent<[InElement.Input<Value>]> | EventSupply {\n    return (this.input = afterSent<[InElement.Input<Value>]>(\n        this._input.on().thru(asis), // remove the second parameter\n        () => [{ value: this.it }],\n    ).F)(receiver);\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._input.on().thru(\n        ({ value: newValue }, oldValue) => newValue === oldValue ? nextSkip() : nextArgs(newValue, oldValue),\n    ).F)(receiver);\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update  Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<Value>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input').to(onInput);\n    this.events.on('change').to(onInput);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element  Target text input element.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { noop } from 'call-thru';\nimport {\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when [[InElement]] aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot | null = element.getRootNode\n        ? element.getRootNode() as any\n        : element.ownerDocument;\n\n    this._it = trackValue(!!owner && owner.activeElement === element);\n    eventSupplyOf(this).needs(inElement);\n\n    events.on('focus').to(() => this._it.it = true);\n    events.on('blur').to(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._it);\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  on(): OnEvent<[boolean, boolean]>;\n  on(receiver: EventReceiver<[boolean, boolean]>): EventSupply;\n  on(receiver?: EventReceiver<[boolean, boolean]>): OnEvent<[boolean, boolean]> | EventSupply {\n    return (this.on = this._it.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { itsEach, mapIt } from 'a-iterable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  eventSupplyOf,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * Builds `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input status flags.\n   */\n  abstract read(): AfterEvent<[InStatus.Flags]>;\n\n  /**\n   * Starts sending input status flags and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of input status flags.\n   *\n   * @returns Input status flags supply.\n   */\n  abstract read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read();\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched  Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited  Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    eventSupplyOf(this._flags).needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = this._flags.read().F)(receiver);\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input().keepThru(({ event }) => !!event) : afterThe(false),\n  }).keepThru(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  );\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = containerInStatusFlags(this._container).F)(receiver);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markEdited(edited),\n        ),\n    );\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markTouched(touched),\n        ),\n    );\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read().tillOff(container).keepThru_(\n      (snapshot: InContainer.Snapshot) => nextAfterEvent(afterEach(...inControlStatuses(snapshot))),\n      combineInStatusFlags,\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @param element  A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(element: InStyledElement | null = null): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { DeltaSet } from 'delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventKeeper,\n  EventNotifier,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { css__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { RenderSchedule } from 'render-scheduler';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of CSS classes map.\n   */\n  abstract read(): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Starts sending CSS classes for styled element and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of CSS classes map.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @returns `AfterEvent` keeper of added and removed classes.\n   */\n  abstract track(): AfterEvent<[readonly string[], readonly string[]]>;\n\n  /**\n   * Starts sending current, added and removed CSS classes to the given `receiver`\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @param receiver  Target receiver of added and removed CSS classes.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source  A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): EventSupply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element  Target element to apply CSS classes to.\n   * @param schedule  DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): EventSupply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason  An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by [[InNamespaceAliaser]] aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  private readonly _sources: ValueTracker<[Map<AfterEvent<[InCssClasses.Map]>, EventSupply>]> = trackValue([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n\n    eventSupplyOf(_control).whenOff(reason => this.done(reason));\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  read(): AfterEvent<[InCssClasses.Map]>;\n  read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n  read(receiver?: EventReceiver<[InCssClasses.Map]>): AfterEvent<[InCssClasses.Map]> | EventSupply {\n    return (this.read = this._sources.read().tillOff(this._control).keepThru_(\n        ([sources]) => nextAfterEvent(afterEach(...sources.keys())),\n        (...classes) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        },\n    ).F)(receiver);\n  }\n\n  track(): AfterEvent<[readonly string[], readonly string[]]>;\n  track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n  track(\n      receiver?: EventReceiver<[readonly string[], readonly string[]]>,\n  ): AfterEvent<[readonly string[], readonly string[]]> | EventSupply {\n    return (this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    }).F)(receiver);\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).keepThru(\n        (...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        },\n    );\n  }\n\n  add(source: InCssClasses.Source): EventSupply {\n\n    const inSupply = eventSupplyOf(this._control);\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = eventSupply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source).to({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).share();\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): EventSupply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark  Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when  {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  let marks: InCssClasses.Spec[];\n\n  if (!mark) {\n    marks = defaultInCssErrorMarks;\n  } else if (Array.isArray(mark)) {\n    marks = mark.length ? mark : defaultInCssErrorMarks;\n  } else {\n    marks = [mark];\n  }\n\n  return control => control.aspect(InValidation).read().keepThru(\n      errors => hasError(errors) ? nextArgs(...marks) : nextArgs(),\n  );\n}\n","/**\n * @packageDocumentation\n * @module input-aspects\n */\nimport { nextArgs } from 'call-thru';\nimport { afterAll } from 'fun-events';\nimport { NamespaceDef, QualifiedName } from 'namespace-aliaser';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InStatus } from '../focus';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns  A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).keepThru(\n        ({ md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          return nextArgs(...names);\n        },\n    );\n  };\n}\n"],"names":["asis","value","noop","isPresent","valueProvider","valuesProvider","values","NextCall__symbol","Symbol","nextCall","callNext","result","chain","fn","isNextCall","target","nextArg","arg","pass","nextArgs","args","call","nextEach","elements","element","nextSkip","skip","isArrayLike","itsRevertible","iterable","itsIterator","iterator","itsIterable","makeIt","iterate","reverse","[object Object]","reversible","reverseIt","source","reverseArray","reversed","Array","from","array","i","length","itsEach","action","itsEmpty","next","done","itsFirst","itsReduction","reducer","initialValue","reduced","filterIt","test","flatMapIt","convert","mapIt","thruIt","it","passes","index","lastPass","handleResult","callResult","push","item","oldResult","newResult","res","ArrayLikeIterableMethods","AIterable","noneAIterable","every","name","is","makeAIterable","itsEvery","this","itsSome","fns","thru","NoneAIterable","super","overArray","noneIterable","overKeys","Reflect","ownKeys","overEntries","keys","mapToEntries","_keys","key","ContextKey__symbol","ContextKey","ContextSeedKey","seedKey","opts","seeder","seed","isEmpty","byDefault","ContextKeyError","Error","message","contextValueSpec","spec","byProvider","withDeps","a","by","with","deps","context","map","dep","get","isConstant","viaAlias","via","ctx","asInstance","selfInstance","Object","as","toAsInstance","Type","DepType","TypeError","ContextValues","ContextRegistry","initial","Map","_initial","_seeding","provide","found","_seeds","seeding","set","factory","cache","newValues","bind","_nonCachedValues","registry","Values","cached","constructed","defaultUsed","findSeed","valueOpts","or","defaultProvider","defaultValue","grow","growValue","other","combine","SimpleContextSeeder","provider","_providers","indexOf","splice","sourceValues","flatMap","first","second","SimpleSeedKey","SimpleContextKey","SingleContextKey","last","itsLast","MultiContextKey","defaultSources","providers","entry","filter","AfterEvent__symbol","isEventKeeper","EventSupply__symbol","EventSupply","off","_off","reason","_whenOff","callback","prev","isOff","another","eventSupplyOf","needs","whenOff","peer","eventSupply","eventReceiver","receiver","generic","supply","_context","event","receive","receiveByEach","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","processEvent","shift","recurrentReceivers","idx","recurrentReceiver","recurrentEvent","EventNotifier","rcs","_rcs","Set","clear","size","add","delete","OnEvent__symbol","isEventSender","NoSupply","noSupply","noEventSupply","sendEventsTo","once","onSource","to","share","shared","sharedSupply","initialEvents","undefined","_ctx","on","dispatch","forEach","chains","chainSupply","existing","prevSupply","sender","parentSupply","nextChain","firstChain","tillOff","required","dependentSupply","cuts","neverReceive","OnEvent","_on","F","onEvent","onCutOff","Promise","resolve","reject","e","then","onEventBy","consume","consumerSupply","thru_","register","noEvent","AfterEvent","_or","dest","reported","_last","_rcn","afterEventBy","keepThru_","fallback","afterSent","afterSupplied","supplier","afterAll","sources","afterEach","afterThe","nextAfterEvent","keeper","EventEmitter","onNever","onSupplied","onAny","suppliers","remained","removeSupplier","onAsync","sourceSupply","numInProcess","numSent","numReceived","lastIndex","promise","onAnyAsync","toSend","statePath","path","isArray","PathEntry","_drop","emitter","newValue","oldValue","nested","_nested","slice","_dropIfEmpty","dontCreateMissing","created","_remove","Trackers","_entry","_root","nest","SubStateTracker","_trackers","_path","_tracker","onUpdate","StateTracker","update","subTracker","track","ValueTracker","read","valueReceiver","onRecurrent","recurrentValue","extract","acceptValuesFrom","byNone","container","_by","TrackedValue","_it","trackValue","ValueSync","old","third","syncWithTracker","tracker","syncTrackers","extractTracker","tracker1","tracker2","supply1","supply2","Naming","nsAlias","local","ns","DefaultNaming","alias","default__naming","html__naming","XmlNaming","id__naming","CssNaming","css__naming","NamespaceDef","url","aliases","naming","applyAlias","isQualifiedName","isNameAndNamespace","compareNames","compareStrings","firstName","firstUrl","newNamespaceAliaser","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","ContextUpSeeder","concat","providersTracker","keepThru","prov","toUpSrcKeeper","flatUpSources","upSrcKeepers","src","isUpSrcKeeper","ContextSeedUpKey","ContextUpKeyUpKey","_key","ContextUpKey","SingleContextUpKey","upKey","backup","FnContextKey","createUpKey","delegated","RenderScheduleConfig","options","win","node","window","ownerDocument","defaultView","messages","error","console","RenderQ__symbol","RenderQ","q","ref","schedule","doSchedule","queue","shot","config","postponed","execution","reset","suspend","exec","postpone","resume","pull","scheduled","customRenderScheduler","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","executed","nextQueue","activeQueue","nextEnqueued","RenderQueue","replace","shots","animationRenderQueues","WeakMap","defaultRenderScheduler","task","requestAnimationFrame","replacement","newRenderSchedule","OnDomEvent","listener","onDomEventBy","capture","instead","preventDefault","just","stopPropagation","stopImmediatePropagation","passive","domEventContext","DomEventDispatcher","_target","type","domListener","addEventListener","removeEventListener","dispatchEvent","hthvItem","$","n","t","v","x","p","pl","addParam","param","nextInItem","input","c","s","d","delimiterOf","datePattern","parseDateTime","out","substring","match","parseNone","itemParser","named","tagged","extra","parseQuotedString","unquoted","quotedStringParser","parseAngleBrackets","angleBracketsParser","parseExtra","tag","extraItem","nextInComment","spacesParser","start","paramParser","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParserOpts","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","hasOwnProperty","regexAnySingleEscape","regexSingleEscape","regexExcessiveSpaces","cssesc","defaults","merge","quotes","isIdentifier","firstChar","charAt","output","counter","character","codePoint","charCodeAt","toString","toUpperCase","escapeEverything","$0","$1","$2","wrap","version","uppercasePattern","msPattern","toHyphenLower","toLowerCase","cssescId","id","isReadonlyArray","isNotEmptyArray","StypValueStruct","priority","prioritize","stypValuesEqual","StypColorStruct","StypRGB","coords","r","intCoord","g","b","coord","rgb","hsl","max","Math","min","l","round","StypHSL","h","StypColor","hueAsFraction","hueToRgb","newT","mixStypColors","color1","color2","weight","w","rgba1","rgba2","aDiff","w1","w2","StypNumericStruct","dim","toFormula","StypMapper","mappings","mapped","mappedValue","mapping","mappingBy","mapper","stypSplitPriority","endsWith","trim","StypDimension","val","unit","thisDim","pt","noPt","addendum","stypDimension","stypAddSub","subtrahend","multiplier","divisor","zero","StypCalcBase","left","op","right","usual","stypMul","stypDiv","StypAddSub","toDim","negate","StypMulDiv","Zero","_byPriority","important","ZeroByPriority","unitlessZeroDimensionKind","dimension","StypDimension_","isStypNumeric","StypLength","StypLengthPt","StypURL","noStypProperties","noStypPropertiesSpec","stypPropertiesBySpec","rule","preventDuplicates","propertiesKeeper","senderOrProperties","propertiesMap","properties","stored","propertyEntries","sentry","propertiesEqual","passNonDuplicate","$$css","mergeStypProperties","base","baseProperties","addendumProperties","k","priorityOf","addValue","addValues","isCombinator","normalizeStypSelector","selector","normalizeKey","normalized","combinator","prevCombinator","part","normalizeStypSelectorPart","classes","sort","normalizeClasses","u","subs","isSubSelectorsArray","normalizeSubSelector","normalizeSubSelectors","isPseudoSubSelector","normalizeQualifiers","sub","prefix","params","qualifiers","exposeQualifier","noQualifiers","qualifier","eqIdx","exposed","lastExposed","split","noKeyAndTail","stypRuleKeyAndTail","rootSelector","classesMatch","query","qClass","find","mClass","namesEqual","stypSelector","ruleKeyTextOpts","qualify","stypRuleKeyText","formatStypSelector","defaultFormat","format","reduce","hasProperties","className","subFormat","attrName","attrOp","attrVal","attrFlag","formatSubSelector","xmlNs","qualifyElement","formatItem","isCSSRuleGroup","sheetOrRule","AtRulesRenderer","_rule","outer","onlyAtProperties","producer","render","sheet","extracted","atSelectors","rest","extractPartAtSelectors","extractAtSelectors","restSelector","atSelector","ruleIdx","insertRule","buildAtSelector","cssRules","names","customQuery","addQuery","namedQuery","stypRenderAtRules","order","create","isAtEntry","String","restQualifies","addAtSelector","colonIdx","prevQuery","stypRenderGlobals","FIRST_RENDER_ORDER","styleSheet","importIndex","nsIndex","importDelta","renderImport","renderDefaultNamespace","renderNamespacePrefix","startsWith","css","stypRenderProperties","cssRule","addRule","style","notCustomProperty","setProperty","hName","hyphenateStyleName","rendererFactory","renderer","isRendererFactory","rendererSpec","compareRenderers","firstOrder","secondOrder","produceBasicStyle","rules","document","addStyleSheet","addStyleElement","scheduler","parent","head","view","factories","addRenderers","renderers","addRenderer","has","stypRenderFactories","renderSupply","renderRule","trackSupply","added","trackRules","styleProducer","production","_selector","ruleIndex","stypSelectorText","reader","specs","renderAt","nextIndex","nextRenderer","nextProducer","rendererForRule","sheetRef","ruleSelector","deleteRule","clearProperties","lastSheetRef","remove","createElement","setAttribute","append","createTextNode","parentElement","removeChild","stypRenderText","cssText","stypRenderXmlNs","xmlNsDefs","declareNs","produceStyle","defaultRenderers","StypRule","StypRuleList","StypRuleHierarchy","Rules","_list","ruleMatches","_buildList","_filterArray","_ruleSet","removed","grabRules","list","stypQuery","stypSelectorMatches","AllRules","self","all","_added","selfRuleList","_updates","iterateAllRules","extendRule","targetSelector","sendUpdate","tail","_spec","oldSpec","empty","extendSpec","keyText","newNested","StypRule$","root","_add","_get","request","propertiesSupply","allRules","NestedRules","_all","_byKey","_outer","outerSelector","stypOuterSelector","builder","stypRoot","StypRule_","StypRuleRef$","_map","ms","ps","watch","_mappings","_properties","RefStypRule","mappingsKeeper","StypRuleRefs","refs","referrers","fromAll","flattenProperties","noStypRules","stypRules","rulesByList","rulesFromSource","_rules","rulesByValue","evalRules","lazyStypRules","lazyRulesFromSource","ruleSet","reportExistingRules","lazyRules","resolution","asyncRules","dispatcher","DeltaSet","_removed","deltaSetDeltaReceiver","InAspect__symbol","inAspectNull","instance","convertTo","inAspectSameOrBuild","control","aspectKey","build","origin","attachTo","aspect","inAspectSameOrNull","inAspectValue","InputAspects__NS","InNamespaceAliaser__aspect","applyTo","InNamespaceAliaser","applyAspect","InRenderScheduler__aspect","InRenderScheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","aspectConverters","conversion","acf","cv","isInAspectConversion","intoConvertedAspects","aspects","noopInConversion","InControl","_aspect","aspectKeyOrSetup","aspectSetup","and","InConverted","_aspects","applied","_applyAspect","_supply","backward","lastRev","convertAspect","rev","prevValue","prevRev","InSameValueControl","_control","AbstractInControl","_aspectConversion","InContainer__aspect","InContainer","InParents__aspect","InControlParents","InParents","existingSupply","allParents","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","mode","own","OwnModeTracker","getAttribute","initialInMode","DerivedInModes","mergeInModes","derive","InParentsAspect","parentsInMode","removeAttribute","applyInMode","derived","_derived","lastUpdate","parents","parentList","modes","ro","inModeValue","InData__aspect","InData","hasData","InGroup__aspect","InGroup","inControlReplacedReason","InGroupSnapshot","entries","InGroupMap","_controls","replaced","newEntry","modify","_shot","InGroupControlControls","_group","model","snapshot","withValues","controlEntryToGroupEntry","keyOrControls","newControl","group","newModel","applyControlsToModel","InGroupControl","_model","controls","cs","readInGroupData","csData","controlsData","data","controlData","inGroup","_requireNothing","requireNothing","inValidator","validator","validate","simpleInValidator","dontRemove","InValidationMessages","validators","validatorMessages","_messages","resultSupply","validatorSupply","InValidation__aspect","InValidation","validation","InControlValidation","noInValidationErrors","ok","hasBut","InValidationErrors","nonEmpty","code","codePresent","_byCode","codes","some","inValidationResult","nestedInValidations","combineInValidationResults","nestedInValidationMessages","numValidators","requireAll","results","requirePresent","missing","AbstractInElement","_set","_value","doUpdate","_update","correction","_input","events","listenForInput","onInput","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","activeElement","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","_flags","flags","updateInStatusFlags","elementInStatusFlags","_container","inControlStatuses","combineInStatusFlags","markEdited","markTouched","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","_schedule","controlSchedule","_sources","mergeInCssClassesMap","classesSent","flag","delta","redelta","undelta","inSupply","classesSupply","classList","updateClasses","defaultInCssErrorMarks","defaultInCssHasError","errors","inCssError","mark","when","hasError","marks","inCssInfo","cls","md","vl","st","valid"],"mappings":"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"}