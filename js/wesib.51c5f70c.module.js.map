{"version":3,"file":"wesib.51c5f70c.module.js","sources":["../../node_modules/@wesib/wesib/src/boot/bootstrap-context.key.impl.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap-context.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap-default.ts","../../node_modules/@wesib/wesib/src/component/definition/component-factory.ts","../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-window.ts","../../node_modules/@wesib/wesib/src/boot/globals/default-namespace-aliaser.ts","../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-root.ts","../../node_modules/@wesib/wesib/src/common/types.impl.ts","../../node_modules/@wesib/wesib/src/common/array-set.ts","../../node_modules/@wesib/wesib/src/common/functions.ts","../../node_modules/@wesib/wesib/src/common/meta-accessor.ts","../../node_modules/@wesib/wesib/src/common/classes.ts","../../node_modules/@wesib/wesib/src/common/promises.ts","../../node_modules/@wesib/wesib/src/feature/feature-def.ts","../../node_modules/@wesib/wesib/src/feature/feature.decorator.ts","../../node_modules/@wesib/wesib/src/feature/feature-context.ts","../../node_modules/@wesib/wesib/src/feature/feature-needs-error.ts","../../node_modules/@wesib/wesib/src/component/component-def.ts","../../node_modules/@wesib/wesib/src/component/component.decorator.ts","../../node_modules/@wesib/wesib/src/component/component-context.key.impl.ts","../../node_modules/@wesib/wesib/src/component/component-event.key.impl.ts","../../node_modules/@wesib/wesib/src/component/content-root.ts","../../node_modules/@wesib/wesib/src/component/state-updater.ts","../../node_modules/@wesib/wesib/src/component/component-context.ts","../../node_modules/@wesib/wesib/src/component/component-event.ts","../../node_modules/@wesib/wesib/src/component/component-mount.ts","../../node_modules/@wesib/wesib/src/boot/globals/element-adapter.ts","../../node_modules/@wesib/wesib/src/boot/impl/component-factory.symbol.impl.ts","../../node_modules/@wesib/wesib/src/component/definition/custom-elements.ts","../../node_modules/@wesib/wesib/src/component/definition/definition.context.key.impl.ts","../../node_modules/@wesib/wesib/src/component/definition/element-def.ts","../../node_modules/@wesib/wesib/src/component/definition/definition-context.ts","../../node_modules/@wesib/wesib/src/boot/impl/bootstrap-value-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/component-value-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/definition-value-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/element-builder.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/component-registry.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-loader.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-request.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-requester.impl.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap/bootstrap-components.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-path.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-state-update.impl.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-registrar.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-registry.impl.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attributes-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute.decorator.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-def.impl.ts","../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-path.ts","../../node_modules/@wesib/wesib/src/feature/state/component-state.ts","../../node_modules/@wesib/wesib/src/feature/state/state-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/render/render-scheduler.ts","../../node_modules/@wesib/wesib/src/feature/render/element-render.ts","../../node_modules/@wesib/wesib/src/feature/render/render-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/render/render.decorator.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-content-root.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-dom-event.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-root-builder.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-dom-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-content-def.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/attach-shadow.decorator.ts","../../node_modules/@wesib/generic/src/fetch/fetch-agent-key.impl.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch-agent.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch.impl.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch.ts","../../node_modules/@wesib/generic/src/navigation/navigation.event.ts","../../node_modules/@wesib/generic/src/navigation/navigation.ts","../../node_modules/@wesib/generic/src/navigation/navigation-agent.ts","../../node_modules/@wesib/generic/src/navigation/page-param.ts","../../node_modules/@wesib/generic/src/navigation/page-param-context.ts","../../node_modules/@wesib/generic/src/navigation/nav-history.impl.ts","../../node_modules/@wesib/generic/src/navigation/navigation-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/navigation.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/caching-page-loader.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-requests.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-agent.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-url-modifier.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-loader.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-param.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-cache-buster.impl.ts","../../node_modules/@wesib/generic/src/util/import-node.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-style-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-title-agent.impl.ts","../../node_modules/@wesib/generic/src/styp/component-style-producer.ts","../../node_modules/@wesib/generic/src/styp/component-styp-render.ts","../../node_modules/@wesib/generic/src/styp/element-id-class.impl.ts","../../node_modules/@wesib/generic/src/styp/component-style-producer.impl.ts","../../node_modules/@wesib/generic/src/styp/basic-style-producer-support.feature.ts","../../node_modules/@wesib/generic/src/styp/component-styp-options.ts","../../node_modules/@wesib/generic/src/styp/produce-style.decorator.ts","../../node_modules/@wesib/generic/src/theme/theme.ts","../../node_modules/@wesib/generic/src/theme/theme-factory.ts","../../node_modules/@wesib/generic/src/theme/theme-style.ts","../../node_modules/@wesib/generic/src/theme/theme.impl.ts","../../node_modules/@wesib/generic/src/theme/theme-support.feature.ts","../../node_modules/@wesib/generic/src/theme/theme-factory.impl.ts","../../node_modules/@wesib/generic/src/tree/element-node.ts","../../node_modules/@wesib/generic/src/tree/element-node-list.impl.ts","../../node_modules/@wesib/generic/src/tree/node-attributes.impl.ts","../../node_modules/@wesib/generic/src/tree/node-properties.impl.ts","../../node_modules/@wesib/generic/src/tree/element-node.impl.ts","../../node_modules/@wesib/generic/src/tree/component-tree-support.feature.ts"],"sourcesContent":["import { SingleContextKey } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = /*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context');\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { AfterEvent, OnEvent } from 'fun-events';\nimport { Class } from '../common';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, ComponentFactory, DefinitionContext } from '../component/definition';\nimport { LoadedFeature } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to [[FeatureDef.init]] method so that the feature can configure itself.\n *\n * Extends `BootstrapValues` interface. The values are {@link FeatureDef.set pre-configured} in feature definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * Registers component definition listener.\n   *\n   * This listener will be called when new component class is defined, but before its custom element class constructed.\n   *\n   * @param listener  A listener to notify on each component definition.\n   *\n   * @return An event supply.\n   */\n  abstract readonly onDefinition: OnEvent<[DefinitionContext]>;\n\n  /**\n   * Registers component construction listener.\n   *\n   * This listener will be called right before component is constructed.\n   *\n   * @param listener  A listener to notify on each component construction.\n   *\n   * @return An event supply.\n   */\n  abstract readonly onComponent: OnEvent<[ComponentContext]>;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentType  Component class constructor.\n   *\n   * @return A promise that is resolved to component factory when the given `componentType` is registered.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>>;\n\n  /**\n   * Registers bootstrap readiness callback.\n   *\n   * The registered callback function will be called once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the callback will be notified immediately.\n   *\n   * @param callback  A callback to notify on bootstrap completion.\n   */\n  abstract whenReady(callback: (this: void) => void): void;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * This method returns an event keeper reporting the loaded feature info. Registering a receiver starts feature\n   * loading. Once all feature info supplies are cut off the feature will be released and unloaded.\n   *\n   * @param feature  The feature to load.\n   *\n   * @returns  An `AfterEvent` keeper of loaded feature info.\n   */\n  abstract load(feature: Class): AfterEvent<[LoadedFeature]>;\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKeyDefault } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @param provide  A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<Value, Key extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: Key) => Value | null | undefined,\n): ContextKeyDefault<Value, Key> {\n  return (context, key) => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext ? provide(bootstrapContext, key) : bootstrapContext.get(key);\n  };\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { Class } from '../../common';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentClass } from './component-class';\nimport { ElementDef } from './element-def';\n\nconst ComponentFactory__key = /*#__PURE__*/ new SingleContextKey<ComponentFactory>('component-factory');\n\n/**\n * A factory of components of particular type.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentFactory<T extends object = any> {\n\n  /**\n   * A key of definition context value containing a component factory.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentFactory> {\n    return ComponentFactory__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  abstract readonly elementDef: ElementDef;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: any): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connected = true;\n\n    return mount;\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = /*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n);\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { NamespaceAliaser } from 'namespace-aliaser';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> =\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser');\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = any;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of [[BootstrapWindow]].\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = /*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n);\n","/**\n * @internal\n */\nexport function isArray<T>(value: T | T[]): value is T[];\n\n/**\n * @internal\n */\nexport function isArray<T>(value: T | readonly T[]): value is readonly T[];\n\nexport function isArray<T>(value: T | readonly T[]): value is T[] {\n  return Array.isArray(value);\n}\n","/**\n * @module @wesib/wesib\n */\nimport { AIterable } from 'a-iterable';\nimport { isArray } from './types.impl';\n\n/**\n * @category Utility\n */\nexport class ArraySet<T> extends AIterable<T> {\n\n  readonly items: Set<T>;\n\n  constructor(value?: T | readonly T[]) {\n    super();\n    this.items = value == null ? new Set() : isArray(value) ? new Set(value) : new Set([value]);\n  }\n\n  get value(): T | T[] | undefined {\n    switch (this.items.size) {\n    case 0: return;\n    case 1: return this.items[Symbol.iterator]().next().value;\n    default: return [...this.items];\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.items[Symbol.iterator]();\n  }\n\n  add(...items: T[]): this {\n    items.forEach(item => this.items.add(item));\n    return this;\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  merge(items: readonly T[] | T | undefined): this {\n    if (items == null) {\n      return this;\n    }\n    if (isArray(items)) {\n      return this.add(...items);\n    }\n    return this.add(items);\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\n/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @category Utility\n * @typeparam P  Function parameter types as tuple.\n * @typeparam R  A type of function result.\n * @typeparam T  A type if `this` object expected by function.\n * @param first  The first function to call.\n * @param second  The second function to call.\n * @param merge  Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<P extends any[], R, T>(\n    first: (this: T, ...args: P) => R,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: (this: T, ...args: P) => R,\n    merge?: (first: R, second: R) => R): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge?: (first: R, second: R) => R): ((this: T, ...args: P) => R) | undefined;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R = (_f, s) => s): ((this: T, ...args: P) => R) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function(this: T, ...args: P) {\n    return merge(\n      first.apply(this, args),\n      second.apply(this, args));\n  };\n}\n","/**\n * @module @wesib/wesib\n */\nimport { Class, superClassOf } from './classes';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<M> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  of(type: Class): M | undefined {\n\n    const def = (type as any)[this.symbol];\n    const superType = superClassOf(type, st => this.symbol in st);\n    const superDef = superType && this.of(superType);\n\n    if (!def) {\n      return;\n    }\n\n    return superDef && superDef !== def ? this.merge(superDef, def) : def;\n  }\n\n  define<C extends Class>(type: C, ...defs: M[]): C {\n\n    const prevDef = this.of(type);\n    let def: M;\n\n    if (prevDef) {\n      def = this.merge(prevDef, ...defs);\n    } else {\n      def = this.merge(...defs);\n    }\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: def,\n        });\n\n    return type;\n  }\n\n  abstract merge(...defs: M[]): M;\n\n}\n","/**\n * @module @wesib/wesib\n */\n/**\n * Arbitrary class constructor.\n *\n * @category Utility\n * @typeparam T  A type of object.\n */\nexport interface Class<T extends object = any> extends Function {\n  new(...args: any[]): T;\n  prototype: T;\n}\n\n/**\n * Detects super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @category Utility\n * @param type  The class constructor to find super class of.\n * @param satisfying  The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  const prototype = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * @module @wesib/wesib\n */\n/**\n * @category Utility\n */\nexport class PromiseResolver<T = void> {\n\n  readonly promise: Promise<T>;\n  private _resolve!: (value: T) => void;\n  private _reject!: (error: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  resolve(value: T) {\n    this._resolve(value);\n  }\n\n  reject(error: any) {\n    this._reject(error);\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextValueSpec } from 'context-values';\nimport { BootstrapContext } from '../boot';\nimport { ArraySet, Class, mergeFunctions, MetaAccessor } from '../common';\nimport { ComponentContext } from '../component';\nimport { DefinitionContext } from '../component/definition';\nimport { FeatureContext } from './feature-context';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = /*#__PURE__*/ Symbol('feature-def');\n\n/**\n * Feature definition.\n *\n * @category Core\n */\nexport interface FeatureDef {\n\n  /**\n   * Features this one requires.\n   */\n  readonly needs?: Class | readonly Class[];\n\n  /**\n   * Features this one provides.\n   *\n   * The feature always provides itself.\n   */\n  readonly has?: Class | readonly Class[];\n\n  /**\n   * Bootstrap context value(s) to declare prior to bootstrap.\n   */\n  readonly set?:\n      | ContextValueSpec<BootstrapContext, any, any[], any>\n      | ContextValueSpec<BootstrapContext, any, any[], any>[];\n\n  /**\n   * Definition context value(s) to declare per each component class definition.\n   */\n  readonly perDefinition?:\n      | ContextValueSpec<DefinitionContext, any, any[], any>\n      | ContextValueSpec<DefinitionContext, any, any[], any>[];\n\n  /**\n   * Component context value(s) to declare per each component construction.\n   */\n  readonly perComponent?:\n      | ContextValueSpec<ComponentContext, any, any[], any>\n      | ContextValueSpec<ComponentContext, any, any[], any>[];\n\n  /**\n   * Bootstraps this feature by calling the given bootstrap context methods.\n   *\n   * @param this  Feature class.\n   * @param context  Feature initialization context.\n   */\n  init?(this: Class, context: FeatureContext): void;\n\n}\n\nclass FeatureMeta extends MetaAccessor<FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(...defs: readonly FeatureDef[]): FeatureDef {\n    return defs.reduce<FeatureDef>(\n        (prev, def) => ({\n          set: new ArraySet(prev.set).merge(def.set).value,\n          needs: new ArraySet(prev.needs).merge(def.needs).value,\n          has: new ArraySet(prev.has).merge(def.has).value,\n          init: mergeFunctions<[FeatureContext], void, Class>(prev.init, def.init),\n          perDefinition: new ArraySet(prev.perDefinition).merge(def.perDefinition).value,\n          perComponent: new ArraySet(prev.perComponent).merge(def.perComponent).value,\n        }),\n        {});\n  }\n\n}\n\nconst meta = /*#__PURE__*/ new FeatureMeta();\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts a feature definition from its type.\n   *\n   * @param featureType  Target feature class constructor.\n   *\n   * @returns A feature definition. May be empty when there is no feature definition found in the given `featureType`.\n   */\n  of(featureType: Class): FeatureDef {\n    return meta.of(featureType) || {};\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs  Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  merge(...defs: readonly FeatureDef[]): FeatureDef {\n    return meta.merge(...defs);\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeparam T  Feature type.\n   * @param type  Feature class constructor.\n   * @param defs  Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends Class>(type: T, ...defs: readonly FeatureDef[]): T {\n    return meta.define(type, ...defs);\n  },\n\n};\n","/**\n * @module @wesib/wesib\n */\nimport { Class, TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to [[bootstrapComponents]] function or referenced by other features.\n *\n * This is an alternative to direct call to [[FeatureDef.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated feature class.\n * @param def  Feature definition.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<T extends Class = any>(def: FeatureDef): TypedClassDecorator<T> {\n  return (type: T) => FeatureDef.define(type, def);\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from 'context-values';\nimport { AfterEvent, OnEvent } from 'fun-events';\nimport { BootstrapContext } from '../boot';\nimport { Class } from '../common';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, ComponentFactory, DefinitionContext } from '../component/definition';\nimport { LoadedFeature } from './loaded-feature';\n\nconst FeatureContext_key = new SingleContextKey<FeatureContext>('feature-context');\n\n/**\n * Feature initialization context.\n */\nexport abstract class FeatureContext extends BootstrapContext {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext_key;\n  }\n\n  get onDefinition(): OnEvent<[DefinitionContext]> {\n    return this.get(BootstrapContext).onDefinition;\n  }\n\n  get onComponent(): OnEvent<[ComponentContext]> {\n    return this.get(BootstrapContext).onComponent;\n  }\n\n  whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  /**\n   * Provides a value available in each component definition context.\n   *\n   * @typeparam D  A type of dependencies.\n   * @typeparam S  The type of context value sources.\n   * @param spec  Component definition context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract perDefinition<D extends any[], S>(spec: ContextValueSpec<DefinitionContext, any, D, S>): () => void;\n\n  /**\n   * Provides a value available in each component context.\n   *\n   * @typeparam D  A type of dependencies.\n   * @typeparam S  The type of context value sources.\n   * @param spec  Component context value specifier.\n   *\n   * A function that removes the given context value specifier when called.\n   */\n  abstract perComponent<D extends any[], S>(spec: ContextValueSpec<ComponentContext, any, D, S>): () => void;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  /**\n   * Registers feature readiness callback.\n   *\n   * The registered callback function will be called once bootstrap is complete and the feature is loaded.\n   *\n   * If the above condition satisfied, the callback will be notified immediately.\n   *\n   * @param callback  A callback to notify on feature load.\n   */\n  abstract whenReady(callback: (this: void) => void): void;\n\n  load(feature: Class): AfterEvent<[LoadedFeature]> {\n    return this.get(BootstrapContext).load(feature);\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\n\n/**\n * Feature need.\n *\n * Indicates why one feature needs another one. The reason can be one of:\n *\n * - `needs` when feature {@link FeatureDef.needs depends} on another one, or\n * - `has` when feature {@link FeatureDef.has provides} another one.\n */\nexport type FeatureNeed = [Class, 'needs' | 'has', Class];\n\n/**\n * An error in feature needs. I.e. circular dependency.\n */\nexport class FeatureNeedsError extends Error {\n\n  /**\n   * Feature needs causing this error.\n   */\n  readonly needs: readonly FeatureNeed[];\n\n  /**\n   * Constructs feature needs error.\n   *\n   * @param needs  Feature needs causing the error.\n   */\n  constructor(needs: readonly FeatureNeed[]) {\n    super(\n        'Circular feature needs: '\n        + needs.reduce(\n        (prev, [feature, reason, need]) =>\n            (prev ? prev : feature.name) + ` ${reason} ${need.name}`, ''));\n    this.needs = needs;\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextValueSpec } from 'context-values';\nimport { QualifiedName } from 'namespace-aliaser';\nimport { ArraySet, Class, mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureDef } from '../feature';\nimport { ComponentContext } from './component-context';\nimport { ComponentClass, DefinitionContext, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = /*#__PURE__*/ Symbol('component-def');\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport interface ComponentDef<T extends object = any> {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend?: ElementDef.Extend;\n\n  /**\n   * Definition context value(s) to declare prior to component class definition.\n   */\n  readonly set?:\n      | ContextValueSpec<DefinitionContext<T>, any, any[], any>\n      | ContextValueSpec<DefinitionContext<T>, any, any[], any>[];\n\n  /**\n   * Component context value(s) to declare per each component construction.\n   */\n  readonly perComponent?:\n      | ContextValueSpec<ComponentContext<T>, any, any[], any>\n      | ContextValueSpec<ComponentContext<T>, any, any[], any>[];\n\n  /**\n   * Additional feature definition options.\n   */\n  readonly feature?: FeatureDef;\n\n  /**\n   * Defines this component by calling the given component definition context methods.\n   *\n   * This function is called before the custom element is defined.\n   *\n   * @param this  Component class.\n   * @param context  Component definition context.\n   */\n  define?(this: Class<T>, context: DefinitionContext<T>): void;\n\n}\n\nclass ComponentMeta extends MetaAccessor<ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return defs.reduce(\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          set: new ArraySet(prev.set).merge(def.set).value,\n          define: mergeFunctions(prev.define, def.define),\n          perComponent: new ArraySet(prev.perComponent).merge(def.perComponent).value,\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {});\n  }\n\n}\n\nconst meta = /*#__PURE__*/ new ComponentMeta();\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts a component definition from its type.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Target component class constructor.\n   *\n   * @returns Component definition. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(componentType: ComponentClass<T>): ComponentDef<T> {\n    return meta.of(componentType) as ComponentDef<T> || {};\n  },\n\n  /**\n   * Merges multiple (partial) component definitions.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Partial component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  merge<T extends object>(...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return meta.merge(...defs);\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends an existing component definition and stores it under [[ComponentDef__symbol]] key.\n   *\n   * Note that each component is also a feature able to register itself, so it can be passed directly to\n   * [[bootstrapComponents]] function or added as a requirement of another feature.\n   *\n   * @typeparam T  A type of component.\n   * @param type  Component class constructor.\n   * @param defs  Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends ComponentClass>(\n      type: T,\n      ...defs: ComponentDef<InstanceType<T>>[]\n  ): T {\n\n    const def = this.merge(...defs);\n    const prevDef = meta.of(type);\n\n    meta.define(type, def);\n\n    const { feature } = def;\n\n    if (feature) {\n      FeatureDef.define(type, feature);\n    }\n    if (prevDef) {\n      return type; // Define component only once.\n    }\n\n    return FeatureDef.define(\n        type,\n        {\n          init: function (context) {\n            context.define(this);\n          },\n        });\n  },\n\n};\n","/**\n * @module @wesib/wesib\n */\nimport { TypedClassDecorator } from '../common';\nimport { ComponentDef } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component class decorator.\n *\n * Decorate a class with this decorator to define a component like this:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with [[BootstrapContext.define]] method, or used as a feature, e.g. passed to\n * [[bootstrapComponents]] function, or added to [[FeatureDef.needs]] property of another feature.\n *\n * This is an alternative to direct call to [[ComponentDef.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n * @param def  A component definition or just custom element name.\n *\n * @returns A component class decorator.\n */\nexport function Component<T extends ComponentClass = any>(\n    def: ComponentDef<InstanceType<T>> | string,\n): TypedClassDecorator<T> {\n  return (type: T) => ComponentDef.define(type, typeof def === 'string' ? { name: def } : def);\n}\n","import { SingleContextKey } from 'context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = /*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context');\n","import { SingleContextKey } from 'context-values';\nimport { DomEventDispatcher, OnDomEvent } from 'fun-events';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = /*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault() {\n        return {\n          dispatch(context: ComponentContext, event: Event): boolean {\n            return context.element.dispatchEvent(event);\n          },\n          on<E extends Event>(context: ComponentContext, type: string): OnDomEvent<E> {\n\n            const dispatcher = new DomEventDispatcher(context.element);\n\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n);\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * @category Core\n */\nexport type ContentRoot = ParentNode;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = /*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(ComponentContext__key).element;\n      },\n    },\n);\n","/**\n * @module @wesib/wesib\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { FnContextKey, FnContextRef } from 'context-values';\nimport { StatePath } from 'fun-events';\n\n/**\n * Component state updater function.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeparam V  Updated value type\n * @param path  Updated state node path.\n * @param newValue  New value.\n * @param oldValue  Replaced value.\n */\n    <V>(this: void, path: StatePath, newValue: V, oldValue: V) => void;\n\n/**\n * A key of component context value containing a component state updates receiver function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Note that this value is not provided, unless the `StateSupport` feature is enabled.\n *\n * @category Core\n */\nexport const StateUpdater: FnContextRef<Parameters<StateUpdater>> = /*#__PURE__*/ new FnContextKey(\n    'state-updater',\n    {\n      byDefault: valueProvider(noop),\n    },\n);\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { EventSupply, OnDomEvent, OnEvent, StatePath } from 'fun-events';\nimport { BootstrapContext__key } from '../boot/bootstrap-context.key.impl';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of a custom element and component properties containing a reference to component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = /*#__PURE__*/ Symbol('component-context');\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapContext.perComponent]] method.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.onComponent component construction event} receiver. In these cases you may wish to\n   * add a [[whenReady]] callback.\n   */\n  abstract readonly component: T;\n\n  /**\n   * Component mount.\n   *\n   * This is defined when component is mounted to arbitrary element by [[ComponentFactory.mountTo]]. Ot is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the custom element is connected.\n   *\n   * This becomes `true` right before [[whenOn]] event is sent, and becomes `false` right before [[whenOff]] event is\n   * sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An `OnEvent` sender of custom element connection events.\n   *\n   * The registered receivers are called when custom element is connected, i.e. its `connectedCallback()` method is\n   * called. If component is connected already the receiver is called immediately.\n   *\n   * Sends a connection supply that is cut off once custom element is disconnected.\n   */\n  abstract readonly whenOn: OnEvent<[EventSupply]>;\n\n  /**\n   * An `OnEvent` sender of custom element disconnection events.\n   *\n   * The registered receivers are called when custom element is disconnected, i.e. its `disconnectedCallback()` method\n   * is called. If component is ready but disconnected, the receiver is called immediately.\n   */\n  abstract readonly whenOff: OnEvent<[]>;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * Note that state update has no effect unless [[StateSupport]] feature is enabled or [[StateUpdater]] context value\n   * is provided by other means.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  readonly updateState: StateUpdater = updateComponentState.bind(this);\n\n  /**\n   * Extracts component context from its custom element or from component itself.\n   *\n   * @param element  Custom element instance created for the component or the component itself.\n   *\n   * @return Component context reference stored under [[ComponentContext__symbol]] key.\n   *\n   * @throws TypeError  When the given `element` does not contain component context reference.\n   */\n  static of<T extends object>(element: any): ComponentContext<T> {\n\n    const context = element[ComponentContext__symbol];\n\n    if (!context) {\n      throw TypeError(`No component context found in ${element}`);\n    }\n\n    return context;\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): ContentRoot {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Registers component readiness callback.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.onComponent component construction event} receiver.\n   * The registered callback will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the callback will be notified immediately.\n   *\n   * @param callback  A callback to notify on component construction.\n   */\n  abstract whenReady(callback: (this: void, component: T) => void): void;\n\n  /**\n   * Registers component destruction callback.\n   *\n   * This callback is notified when [[destroy]] method is called. If the component is destroyed already the callback\n   * is notified immediately.\n   *\n   * Multiple callbacks will be called in the order reverse to their registration order.\n   *\n   * @param callback  A callback to notify on component destruction.\n   */\n  abstract whenDestroyed(callback: (this: void, reason: any) => void): void;\n\n  /**\n   * Returns a `super` property value inherited from custom element parent.\n   *\n   * @param key  Target property key.\n   */\n  abstract elementSuper(key: PropertyKey): any;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return this.get(ComponentEventDispatcher__key).on(this, type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event  An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(BootstrapContext__key).get(ComponentEventDispatcher__key).dispatch(this, event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   *\n   * @param reason  Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n\nfunction updateComponentState<V>(this: ComponentContext<any>, key: StatePath, newValue: V, oldValue: V) {\n  this.get(StateUpdater)(key, newValue, oldValue);\n}\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextRef } from 'context-values';\nimport { OnDomEvent } from 'fun-events';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using [[ComponentEventDispatcher]] available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is thrown when component is bound to element. I.e. when HTML element is upgraded to custom one\n *   defined by component, or component is bound to the element. This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Constructs component event.\n   *\n   * @param type  Event type.\n   * @param eventInitDict  Event initialization dictionary.\n   */\n  constructor(type: string, eventInitDict?: EventInit) {\n    super(type, eventInitDict);\n  }\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentContext.of(this.target);\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param context  Target component context.\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(context: ComponentContext, event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @param context  Target component context.\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(context: ComponentContext, type: string): OnDomEvent<E>;\n\n}\n\n/**\n * A key of bootstrap context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> =\n    /*#__PURE__*/ ComponentEventDispatcher__key;\n","/**\n * @module @wesib/wesib\n */\nimport { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by [[ComponentFactory.mountTo]] method.\n *\n * Mounted components do not maintain their connection status automatically. It is a calling code responsibility to set\n * their connection status by updating [[ComponentMount.connected]] property. E.g. by periodically calling a\n * [[ComponentMount.checkConnected]] method, or by using an [[AutoConnectSupport]] feature.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * Updating this property triggers appropriate listeners registered in [[ComponentContext]].\n   *\n   * The initial state is set by [[checkConnected]] method.\n   */\n  abstract connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element;\n  }\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextUpKey, ContextUpRef, ContextValueOpts, ContextValues } from 'context-values';\nimport { AfterEvent, EventKeeper } from 'fun-events';\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\n\n/**\n * Element adapter is a function able to convert a raw element to component. E.g. mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * Multiple element adapters can be registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element  Target raw element to adapt.\n *\n * @returns An adapted component's context, or `undefined` if element can not be adapted.\n */\n    (this: void, element: any) => ComponentContext | undefined;\n\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ElementAdapter> {\n\n  constructor() {\n    super('element-adapter');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          ElementAdapter,\n          EventKeeper<ElementAdapter[]> | ElementAdapter, AfterEvent<ElementAdapter[]>>,\n  ): ElementAdapter {\n\n    const defaultElementAdapter = (element: any) => element[ComponentContext__symbol];\n\n    let result: ElementAdapter;\n\n    opts.seed((...adapters) => {\n\n      const combined = adapters.reduce(\n          (prev, adapter) => (element: any) => prev(element) || adapter(element),\n          defaultElementAdapter,\n      );\n\n      result = combined !== defaultElementAdapter\n          ? combined\n          : opts.byDefault(() => defaultElementAdapter) || defaultElementAdapter;\n    });\n\n    return element => result(element);\n  }\n\n}\n\n/**\n * A key of bootstrap context value containing combined [[ElementAdapter]] instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ElementAdapter> = /*#__PURE__*/ new ElementAdapterKey();\n","import { ComponentClass, ComponentFactory } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const ComponentFactory__symbol = /*#__PURE__*/ Symbol('component-factory');\n\n/**\n * @internal\n */\nexport function componentFactoryOf<T extends object>(componentType: ComponentClass<T>): ComponentFactory<T> {\n\n  const factory = (componentType as any)[ComponentFactory__symbol];\n\n  if (!factory) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n\n  return factory;\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, SingleContextKey } from 'context-values';\nimport { html__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { componentFactoryOf } from '../../boot/impl/component-factory.symbol.impl';\nimport { Class, PromiseResolver } from '../../common';\nimport { ComponentClass } from './component-class';\n\nconst CustomElements__key = /*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: createCustomElements,\n    },\n);\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName  A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType  A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName  Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\nfunction createCustomElements(values: ContextValues) {\n\n  const customElements: CustomElementRegistry = values.get(BootstrapWindow).customElements;\n  const nsAlias = values.get(DefaultNamespaceAliaser);\n\n  class WindowCustomElements extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name, extend } = factory.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            });\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name } = factory.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise;\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new WindowCustomElements();\n}\n\nconst ComponentResolver__symbol = /*#__PURE__*/ Symbol('component-resolver');\n\nfunction componentResolver(componentType: ComponentClass): PromiseResolver<void> {\n  return (componentType as any)[ComponentResolver__symbol]\n      || ((componentType as any)[ComponentResolver__symbol] = new PromiseResolver());\n}\n","import { SingleContextKey } from 'context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = /*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context');\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class } from '../../common';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n */\nexport const ElementDef: SingleContextRef<ElementDef> = /*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || (values.get(BootstrapWindow) as any).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n);\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../component-context';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * `BootstrapContext.perDefinition()` method. All [[BootstrapContext]] values are available too.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * Registers component construction listener.\n   *\n   * This listener will be called right before the defined component is constructed.\n   *\n   * @param listener  A listener to notify on each defined component construction.\n   *\n   * @return An event supply.\n   */\n  abstract readonly onComponent: OnEvent<[ComponentContext]>;\n\n  /**\n   * Registers component definition readiness callback.\n   *\n   * The custom element class is not constructed yet when `DefinitionListener` or `ComponentDef.define()` is called.\n   * The registered callback will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the callback will be notified immediately.\n   *\n   * @param callback  A callback to notify on custom element class construction.\n   */\n  abstract whenReady(callback: (this: void, elementType: Class) => void): void;\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeparam D  A type of dependencies.\n   * @typeparam S  The type of context value sources.\n   * @param spec  Component context value specifier.\n   */\n  abstract perComponent<S>(spec: ContextValueSpec<ComponentContext<T>, any, any[], S>): void;\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, ContextValues, SingleContextKey } from 'context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapValueRegistry__key =\n    /*#__PURE__*/ new SingleContextKey<BootstrapValueRegistry>('bootstrap-value-registry');\n\n/**\n * @internal\n */\nexport class BootstrapValueRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapValueRegistry> {\n    return BootstrapValueRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapValueRegistry {\n    return new BootstrapValueRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapValueRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, ContextSeeds, SingleContextKey } from 'context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst ComponentValueRegistry__key = new SingleContextKey<ComponentValueRegistry>(\n    'component-value-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentValueRegistry()),\n    },\n);\n\n/**\n * @internal\n */\nexport class ComponentValueRegistry extends ContextRegistry<ComponentContext> {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentValueRegistry> {\n    return ComponentValueRegistry__key;\n  }\n\n  constructor(initial?: ContextSeeds<ComponentContext>) {\n    super(initial);\n  }\n\n}\n","import {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextSeeds,\n  ContextValues,\n  SingleContextKey,\n} from 'context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst DefinitionValueRegistry__key = new SingleContextKey<DefinitionValueRegistry>(\n    'definition-value-registry',\n    {\n      byDefault: bootstrapDefault(context => new DefinitionValueRegistry(context)),\n    },\n);\n\n/**\n * @internal\n */\nexport class DefinitionValueRegistry extends ContextRegistry<DefinitionContext> {\n\n  static get [ContextKey__symbol](): ContextKey<DefinitionValueRegistry> {\n    return DefinitionValueRegistry__key;\n  }\n\n  constructor(initial?: ContextSeeds<DefinitionContext> | ContextValues) {\n    super(initial);\n  }\n\n}\n","import { nextArgs, nextSkip, noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec, SingleContextKey } from 'context-values';\nimport { EventEmitter, eventSupply, EventSupply, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { ArraySet, Class } from '../../common';\nimport {\n  ComponentContext as ComponentContext_,\n  ComponentContext__symbol,\n  ComponentDef,\n  ComponentEvent,\n  ComponentMount as ComponentMount_,\n} from '../../component';\nimport {\n  ComponentClass,\n  ComponentFactory as ComponentFactory_,\n  DefinitionContext as DefinitionContext_,\n  ElementDef,\n} from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ComponentValueRegistry } from './component-value-registry.impl';\nimport { DefinitionValueRegistry } from './definition-value-registry.impl';\n\n/**\n * Creates new component of the given type.\n *\n * It makes component context available under `[ComponentContext__symbol]` key in constructed component.\n * The component context is also available inside component constructor by temporarily assigning it to component\n * prototype.\n *\n * @typeparam T  A type of component.\n * @param type  Component class constructor.\n * @param context  Target component context.\n */\nfunction newComponent<T extends object>(type: ComponentClass<T>, context: ComponentContext_<T>): T {\n\n  const proto = type.prototype as any;\n  const prevContext = proto[ComponentContext__symbol];\n\n  proto[ComponentContext__symbol] = context;\n  try {\n\n    const component = new type(context);\n\n    Object.defineProperty(component, ComponentContext__symbol, { value: context });\n\n    return component;\n  } finally {\n    proto[ComponentContext__symbol] = prevContext;\n  }\n}\n\nconst enum ComponentStatus {\n  Building,\n  Ready,\n  Off,\n  On,\n}\n\nconst ComponentStatus__symbol = /*#__PURE__*/ Symbol('component-status');\n\nfunction elementStatus(element: any): ValueTracker<ComponentStatus> {\n  return element[ComponentStatus__symbol];\n}\n\nconst ElementBuilder__key = /*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(context => new ElementBuilder(context)),\n    },\n);\n\n/**\n * @internal\n */\nexport class ElementBuilder {\n\n  private readonly _definitionValueRegistry: DefinitionValueRegistry;\n  private readonly _componentValueRegistry: ComponentValueRegistry;\n  readonly definitions = new EventEmitter<[DefinitionContext_]>();\n  readonly components = new EventEmitter<[ComponentContext_]>();\n\n  static get [ContextKey__symbol](): ContextKey<ElementBuilder> {\n    return ElementBuilder__key;\n  }\n\n  constructor(context: BootstrapContext) {\n    this._definitionValueRegistry = context.get(DefinitionValueRegistry);\n    this._componentValueRegistry = context.get(ComponentValueRegistry);\n  }\n\n  buildElement<T extends object>(componentType: ComponentClass<T>): ComponentFactory_<T> {\n\n    const def = ComponentDef.of(componentType);\n    const builder = this;\n    const onComponent = new EventEmitter<[ComponentContext_]>();\n    let typeValueRegistry!: ComponentValueRegistry;\n    const ready = trackValue(false);\n    const whenReady: OnEvent<[]> = ready.read.thru(cls => cls ? nextArgs() : nextSkip());\n    let definitionContext: DefinitionContext;\n\n    function createValueRegistry() {\n      return builder._componentValueRegistry.append(typeValueRegistry);\n    }\n\n    class ComponentFactory extends ComponentFactory_<T> {\n\n      get componentType() {\n        return definitionContext.componentType;\n      }\n\n      get elementType() {\n        return definitionContext.elementType;\n      }\n\n      get elementDef() {\n        return definitionContext.elementDef;\n      }\n\n      mountTo(element: any): ComponentMount_<T> {\n        if (element[ComponentContext__symbol]) {\n          throw new Error(`Element ${element} already bound to component`);\n        }\n\n        const mount = builder._createComponent({\n          definitionContext,\n          onComponent,\n          valueRegistry: createValueRegistry(),\n          element,\n          elementSuper(key) {\n            return element[key];\n          },\n          createMount(context: ComponentContext_<T>) {\n\n            class ComponentMount extends ComponentMount_<T> {\n\n              get context() {\n                return context;\n              }\n\n              get connected() {\n                return elementStatus(element).it === ComponentStatus.On;\n              }\n\n              set connected(value: boolean) {\n                elementStatus(element).it = value ? ComponentStatus.On : ComponentStatus.Off;\n              }\n\n              checkConnected(): boolean {\n\n                const el: Element = element;\n                const doc = el.ownerDocument;\n\n                return this.connected = doc != null && doc.contains(el);\n              }\n\n            }\n\n            return new ComponentMount();\n          },\n        }).mount as ComponentMount_<T>;\n\n        mount.checkConnected();\n        componentCreated(mount.context);\n\n        return mount;\n      }\n\n    }\n\n    const componentFactory = new ComponentFactory();\n\n    class DefinitionContext extends DefinitionContext_<T> {\n\n      readonly get: ContextValues['get'];\n\n      get componentType() {\n        return componentType;\n      }\n\n      get onComponent() {\n        return onComponent.on;\n      }\n\n      get elementType(): Class {\n        throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n      }\n\n      constructor() {\n        super();\n\n        const definitionRegistry = new DefinitionValueRegistry(builder._definitionValueRegistry.seedIn(this));\n\n        definitionRegistry.provide({ a: DefinitionContext_, is: this });\n        definitionRegistry.provide({ a: ComponentFactory_, is: componentFactory });\n        this.get = definitionRegistry.newValues().get;\n        new ArraySet(def.set).forEach(spec => definitionRegistry.provide(spec));\n\n        typeValueRegistry = new ComponentValueRegistry(definitionRegistry.seedIn(this));\n        new ArraySet(def.perComponent).forEach(spec => typeValueRegistry.provide(spec));\n      }\n\n      whenReady(callback: (this: void, elementType: Class) => void) {\n        whenReady.once(() => callback(this.elementType));\n      }\n\n      perComponent<S>(spec: ContextValueSpec<ComponentContext_, any, any[], S>): void {\n        typeValueRegistry.provide(spec);\n      }\n\n    }\n\n    definitionContext = new DefinitionContext();\n\n    if (def.define) {\n      def.define.call(componentType, definitionContext);\n    }\n    this.definitions.send(definitionContext);\n\n    const elementType = this._elementType(definitionContext, onComponent, createValueRegistry());\n\n    Object.defineProperty(definitionContext, 'elementType', {\n      configurable: true,\n      enumerable: true,\n      value: elementType,\n    });\n\n    ready.it = true;\n\n    return componentFactory;\n  }\n\n  private _elementType<T extends object>(\n      definitionContext: DefinitionContext_<T>,\n      onComponent: EventEmitter<[ComponentContext_<T>]>,\n      valueRegistry: ComponentValueRegistry) {\n\n    const builder = this;\n    const elementDef = definitionContext.get(ElementDef);\n\n    class Element extends elementDef.extend.type {\n\n      // Component context reference\n      [ComponentContext__symbol]: ComponentContext_<T>;\n\n      constructor() {\n        super();\n\n        const context = builder._createComponent({\n          definitionContext,\n          onComponent,\n          valueRegistry,\n          element: this,\n          createMount: noop,\n          elementSuper: (key) => {\n            // @ts-ignore\n            return super[key] as any;\n          },\n        });\n\n        componentCreated(context);\n      }\n\n      // noinspection JSUnusedGlobalSymbols\n      connectedCallback() {\n        elementStatus(this).it = ComponentStatus.On;\n      }\n\n      // noinspection JSUnusedGlobalSymbols\n      disconnectedCallback() {\n        elementStatus(this).it = ComponentStatus.Off;\n      }\n\n    }\n\n    return Element;\n  }\n\n  private _createComponent<T extends object>(\n      {\n        definitionContext,\n        onComponent,\n        valueRegistry,\n        element,\n        createMount,\n        elementSuper,\n      }: ComponentMeta<T>): ComponentContext_<T> {\n\n    const status = trackValue<ComponentStatus>(ComponentStatus.Building);\n    const aliveSupply = status.on(noop);\n    const whenReady: OnEvent<[]> = status.read.thru(sts => sts ? nextArgs() : nextSkip());\n    const whenOff: OnEvent<[]> = status.read.thru(sts => sts === ComponentStatus.Off ? nextArgs() : nextSkip());\n    const whenOn: OnEvent<[EventSupply]> = status.read.thru(\n        sts => {\n          if (sts !== ComponentStatus.On) {\n            return nextSkip();\n          }\n\n          const offSupply = eventSupply();\n\n          whenOff.once(() => offSupply.off());\n\n          return nextArgs(offSupply);\n        },\n    );\n\n    let mount: ComponentMount_<T> | undefined;\n    const values = valueRegistry.newValues();\n\n    class ComponentContext extends ComponentContext_<T> {\n\n      readonly get = values.get;\n      readonly elementSuper = elementSuper;\n\n      get componentType() {\n        return definitionContext.componentType;\n      }\n\n      get element() {\n        return element;\n      }\n\n      get component(): T {\n        throw new Error('The component is not constructed yet. Consider to use a `whenReady()` callback');\n      }\n\n      get mount(): ComponentMount_<T> | undefined {\n        return mount || (mount = createMount(this));\n      }\n\n      get connected(): boolean {\n        return status.it === ComponentStatus.On;\n      }\n\n      get whenOn(): OnEvent<[EventSupply]> {\n        return whenOn;\n      }\n\n      get whenOff(): OnEvent<[]> {\n        return whenOff;\n      }\n\n      whenReady(callback: (this: void, component: T) => void) {\n        whenReady.once(() => callback(this.component));\n      }\n\n      whenDestroyed(callback: (this: void, reason: any) => void): void {\n        aliveSupply.whenOff(callback);\n      }\n\n      destroy(reason?: any): void {\n        status.done(reason);\n      }\n\n    }\n\n    const context = new ComponentContext();\n\n    context.whenDestroyed(() => removeElement(context));\n    valueRegistry.provide({ a: ComponentContext_, is: context });\n\n    augmentElement();\n\n    this.components.send(context);\n    onComponent.send(context);\n\n    const component = newComponent(definitionContext.componentType, context);\n\n    Object.defineProperty(context, 'component', {\n      configurable: true,\n      enumerable: true,\n      value: component,\n    });\n\n    status.it = ComponentStatus.Ready;\n\n    return context;\n\n    function augmentElement() {\n      Object.defineProperty(element, ComponentContext__symbol, { value: context });\n      Object.defineProperty(element, ComponentStatus__symbol, { writable: true, value: status });\n    }\n  }\n\n}\n\ninterface ComponentMeta<T extends object> {\n  definitionContext: DefinitionContext_<T>;\n  onComponent: EventEmitter<[ComponentContext_<T>]>;\n  valueRegistry: ComponentValueRegistry;\n  element: any;\n\n  elementSuper(name: PropertyKey): any;\n\n  createMount(context: ComponentContext_<T>): ComponentMount_<T> | undefined;\n}\n\nfunction componentCreated(context: ComponentContext_) {\n  context.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true }));\n}\n\nfunction removeElement(context: ComponentContext_) {\n\n  const { element, mount } = context;\n\n  if (mount) {\n    mount.connected = false; // Disconnect mounted element\n  }\n\n  const parentNode: Element = element.parentElement;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n","import { ComponentFactory__symbol } from '../../boot/impl/component-factory.symbol.impl';\nimport { ElementBuilder } from '../../boot/impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _definitionQueue: (() => void)[] = [];\n\n  constructor(private readonly _context: FeatureContext) {\n    _context.whenReady(() => {\n      this._definitionQueue.forEach(definition => definition());\n      delete this._definitionQueue;\n    });\n  }\n\n  get customElements(): CustomElements {\n    return this._context.get(CustomElements);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>) {\n    this._definitionQueue.push(() => {\n\n      const elementBuilder = this._context.get(ElementBuilder);\n      const factory = elementBuilder.buildElement(componentType);\n\n      (componentType as any)[ComponentFactory__symbol] = factory;\n\n      this.customElements.define(componentType, factory.elementType);\n    });\n  }\n\n}\n","import { filterIt, mapIt } from 'a-iterable';\nimport { isPresent, NextArgs, nextArgs, NextSkip, nextSkip } from 'call-thru';\nimport { ContextRegistry, ContextUpKey, ContextValueOpts, ContextValues, ContextValueSpec } from 'context-values';\nimport { afterAll, afterEach, AfterEvent, afterEventBy, afterThe, EventKeeper, OnEvent, trackValue } from 'fun-events';\nimport { BootstrapContext } from '../../boot';\nimport { BootstrapValueRegistry, ComponentValueRegistry, DefinitionValueRegistry } from '../../boot/impl';\nimport { ArraySet, Class } from '../../common';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\nimport { FeatureClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureKey__symbol = /*#__PURE__*/ Symbol('feature-key');\n\n/**\n * @internal\n */\nexport class FeatureKey extends ContextUpKey<AfterEvent<[FeatureLoader?]>, FeatureClause> {\n\n  static of(feature: Class): FeatureKey {\n\n    const feat = feature as any;\n\n    return feat[FeatureKey__symbol] || (feat[FeatureKey__symbol] = new FeatureKey(feature));\n  }\n\n  private constructor(feature: Class) {\n    super(`feature:${feature.name}`);\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[FeatureLoader?]>,\n          EventKeeper<FeatureClause[]> | FeatureClause,\n          AfterEvent<FeatureClause[]>>,\n  ): AfterEvent<[FeatureLoader?]> | null | undefined {\n    return loadFeature(\n        opts.context.get(BootstrapContext),\n        opts.seed.keep.thru(preferredFeatureClause),\n    );\n  }\n\n}\n\nfunction preferredFeatureClause(...clauses: FeatureClause[]): FeatureClause | undefined {\n\n  let required = false;\n  let preferred: FeatureClause | undefined;\n\n  for (const clause of clauses) {\n    switch (clause[1]) {\n      case 'is':\n        required = true;\n        if (!preferred) {\n          preferred = clause;\n        }\n        break;\n      case 'has':\n        preferred = clause;\n        break;\n      case 'needs':\n        required = true;\n    }\n  }\n\n  return required ? preferred : undefined;\n}\n\nfunction loadFeature(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<[FeatureLoader?]> {\n  return afterEventBy<[FeatureLoader?]>(receiver => {\n\n    let origin: Class | undefined;\n    let source: OnEvent<[FeatureLoader?]> = afterThe();\n    let stageId: Promise<FeatureStageId> = Promise.resolve('idle');\n\n    return afterAll({\n      clause: from,\n      deps: loadFeatureDeps(bsContext, from),\n    }).dig_(({ clause: [clause], deps }) => {\n      if (!clause) {\n        return afterThe();\n      }\n\n      const [request, , target] = clause;\n\n      if (request.feature === origin) {\n        return source; // Origin didn't change. Reuse the source.\n      }\n\n      origin = request.feature;\n\n      if (target !== origin) {\n        // Originated from replacement feature provider. Reuse its loader.\n        return source = bsContext.get(FeatureKey.of(origin)).thru_(\n            loader => {\n              loader!.to(stageId);\n              stageId = loader!.stage;\n              return loader;\n            },\n        );\n      }\n\n      // Create feature's own loader\n      const ownLoader = new FeatureLoader(bsContext, request, deps).to(stageId);\n      const ownSource = afterThe(ownLoader);\n\n      return source = afterEventBy<[FeatureLoader]>(\n          rcv => ownSource(rcv).whenOff(() => {\n            stageId = ownLoader.unload();\n          }),\n      ).share(); // Can be accessed again when reused\n    })(receiver);\n  }).keep.thru(\n      preventDuplicateLoader(),\n  );\n}\n\nfunction preventDuplicateLoader():\n    <NextReturn>(\n        loader?: FeatureLoader,\n    ) => NextArgs<[FeatureLoader?], NextReturn> | NextSkip<[FeatureLoader?], NextReturn> {\n\n  let lastLoader: FeatureLoader | null | undefined = null; // Initially `null` to differ from `undefined`\n\n  return <NextReturn>(loader?: FeatureLoader) => {\n    if (lastLoader === loader) {\n      return nextSkip();\n    }\n    lastLoader = loader;\n\n    if (!loader) {\n      return nextArgs<[FeatureLoader?], NextReturn>();\n    }\n\n    return nextArgs<[FeatureLoader?], NextReturn>(loader);\n  };\n}\n\nfunction loadFeatureDeps(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<FeatureLoader[]> {\n  return from.keep.dig_(clause => {\n    if (!clause) {\n      return afterThe();\n    }\n\n    const [{ def }] = clause;\n    const needs = new ArraySet(def.needs);\n\n    if (!needs.size) {\n      return afterThe();\n    }\n\n    return afterEach(...needs.map(dep => bsContext.get(FeatureKey.of(dep))))\n        .keep.thru_(presentFeatureDeps);\n  });\n}\n\nfunction presentFeatureDeps<NextReturn>(...deps: [FeatureLoader?][]): NextArgs<FeatureLoader[], NextReturn> {\n  return nextArgs<FeatureLoader[], NextReturn>(\n      ...filterIt<FeatureLoader | undefined, FeatureLoader>(\n          mapIt(deps, dep => dep[0]),\n          isPresent,\n      ),\n  );\n}\n\n/**\n * @internal\n */\nexport class FeatureLoader {\n\n  readonly down: Promise<void>;\n  private _stage: Promise<FeatureStage>;\n  private _down!: () => void;\n  readonly state = trackValue(false);\n\n  constructor(\n      readonly bsContext: BootstrapContext,\n      readonly request: FeatureRequest,\n      readonly deps: FeatureLoader[],\n  ) {\n    this.down = new Promise(resolve => this._down = resolve);\n    this._stage = Promise.resolve(new SetupFeatureStage(this));\n  }\n\n  get stage(): Promise<FeatureStageId> {\n    return this._stage.then(stage => stage.after);\n  }\n\n  get ready(): boolean {\n    return this.state.it;\n  }\n\n  to(stageId: Promise<FeatureStageId>): this {\n\n    const lastStage = this._stage;\n\n    this._stage = stageId.then(id => lastStage.then(stage => stage[id]()));\n\n    return this;\n  }\n\n  async setup(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.setup()));\n  }\n\n  async init(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.init()));\n  }\n\n  async unload(): Promise<FeatureStageId> {\n\n    const prevStage = this._stage;\n\n    delete this._stage; // Unloaded feature should never be accessed again.\n\n    const stage = await prevStage;\n    const stageId = await stage.stop();\n\n    this._down();\n\n    return stageId;\n  }\n\n}\n\ntype FeatureStageId = 'idle' | 'setup' | 'init';\ntype FeatureStageStop = (this: void) => Promise<any>;\n\nabstract class FeatureStage {\n\n  abstract readonly after: FeatureStageId;\n\n  constructor(\n      readonly loader: FeatureLoader,\n      private readonly _stop: FeatureStageStop = () => Promise.resolve(),\n  ) {}\n\n  async idle(): Promise<this> {\n    return this;\n  }\n\n  abstract setup(): Promise<FeatureStage>;\n\n  abstract init(): Promise<FeatureStage>;\n\n  stop(): Promise<FeatureStageId> {\n    return this._stop().then(() => this.after);\n  }\n\n  protected perDep(action: (dep: FeatureLoader) => Promise<void>): Promise<any> {\n\n    const { deps } = this.loader;\n\n    return Promise.all(deps.map(dep => action(dep)));\n  }\n\n}\n\nclass SetupFeatureStage extends FeatureStage {\n\n  get after() {\n    return 'idle' as const;\n  }\n\n  async setup(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.setup());\n\n    const { bsContext, request: { def: { set, perDefinition, perComponent } } } = this.loader;\n    const [context, unloads] = newFeatureContext(bsContext, this.loader);\n    const bootstrapValueRegistry = bsContext.get(BootstrapValueRegistry);\n\n    new ArraySet(set).forEach(spec => unloads.push(bootstrapValueRegistry.provide(spec)));\n    new ArraySet(perDefinition).forEach(spec => context.perDefinition(spec));\n    new ArraySet(perComponent).forEach(spec => context.perComponent(spec));\n\n    return new InitFeatureStage(\n        this.loader,\n        context,\n        async () => unloads.forEach(unload => unload()),\n    );\n  }\n\n  init(): Promise<FeatureStage> {\n    return this.setup().then(stage => stage.init());\n  }\n\n}\n\nclass InitFeatureStage extends FeatureStage {\n\n  get after() {\n    return 'setup' as const;\n  }\n\n  constructor(\n      state: FeatureLoader,\n      private readonly _context: FeatureContext,\n      stop: FeatureStageStop,\n  ) {\n    super(state, stop);\n  }\n\n  async setup(): Promise<FeatureStage> {\n    return this;\n  }\n\n  async init(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.init());\n\n    const { request: { feature, def: { init } } } = this.loader;\n\n    if (init) {\n      init.call(feature, this._context);\n    }\n\n    return new ActiveFeatureStage(this);\n  }\n\n}\n\nclass ActiveFeatureStage extends FeatureStage {\n\n  get after() {\n    return 'init' as const;\n  }\n\n  constructor(prev: InitFeatureStage) {\n    super(prev.loader, () => prev.stop());\n    prev.loader.state.it = true;\n  }\n\n  async setup(): Promise<FeatureStage> {\n    return this;\n  }\n\n  async init(): Promise<FeatureStage> {\n    return this;\n  }\n\n}\n\nfunction newFeatureContext(\n    bsContext: BootstrapContext,\n    loader: FeatureLoader,\n): [FeatureContext, (() => void)[]] {\n\n  const unloads: (() => void)[] = [];\n  let componentRegistry: ComponentRegistry;\n  const definitionValueRegistry = bsContext.get(DefinitionValueRegistry);\n  const componentValueRegistry = bsContext.get(ComponentValueRegistry);\n  const registry = new ContextRegistry<FeatureContext>(bsContext);\n  const whenReady: OnEvent<[]> = loader.state.read.thru(\n      ready => ready ? nextArgs() : nextSkip(),\n  );\n\n  class Context extends FeatureContext {\n\n    readonly get = registry.newValues().get;\n\n    constructor() {\n      super();\n      registry.provide({ a: FeatureContext, is: this });\n      componentRegistry = new ComponentRegistry(this);\n    }\n\n    perDefinition<D extends any[], S>(spec: ContextValueSpec<DefinitionContext, any, D, S>) {\n\n      const unload = definitionValueRegistry.provide(spec);\n\n      unloads.push(unload);\n\n      return unload;\n    }\n\n    perComponent<D extends any[], S>(spec: ContextValueSpec<ComponentContext, any, D, S>) {\n\n      const unload = componentValueRegistry.provide(spec);\n\n      unloads.push(unload);\n\n      return unload;\n    }\n\n    define<T extends object>(componentType: ComponentClass<T>): void {\n      componentRegistry.define(componentType);\n    }\n\n    whenReady(callback: (this: void) => void): void {\n      bsContext.whenReady(() => {\n        whenReady.once(callback);\n      });\n    }\n\n  }\n\n  return [new Context(), unloads];\n}\n","import { noop } from 'call-thru';\nimport { ArraySet, Class, mergeFunctions } from '../../common';\nimport { FeatureDef } from '../feature-def';\nimport { FeatureNeedsError } from '../feature-needs-error';\nimport { FeatureKey } from './feature-loader.impl';\nimport { FeatureRequester } from './feature-requester.impl';\n\n/**\n * @internal\n */\nexport type FeatureClause = [FeatureRequest, 'is' | 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport type FeatureNeedClause = [FeatureRequest, 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport class FeatureRequest {\n\n  readonly def: FeatureDef;\n  private _uses = 0;\n  private _revoke: () => void = noop;\n\n  constructor(private readonly _requester: FeatureRequester, readonly feature: Class) {\n    this.def = FeatureDef.of(feature);\n  }\n\n  request(clauses: readonly FeatureNeedClause[]): this {\n\n    const requester = this._requester;\n    const { registry } = requester;\n    const isClause: FeatureClause = [this, 'is', this.feature];\n\n    this._revokeBy(registry.provide({\n      a: FeatureKey.of(this.feature),\n      is: isClause,\n    }));\n\n    new ArraySet(this.def.has).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'has', feature];\n\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n\n      // Request the provided feature _after_ provider\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n    });\n\n    new ArraySet(this.def.needs).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'needs', feature];\n\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n    });\n\n    this._uses = 1;\n\n    return this;\n  }\n\n  reuse(clauses: readonly FeatureNeedClause[]): this {\n    if (!this._uses) {\n      throw new FeatureNeedsError(clauses.map(([{ feature }, reason, need]) => [feature, reason, need]));\n    }\n\n    ++this._uses;\n\n    return this;\n  }\n\n  unuse() {\n    if (!--this._uses) {\n      this._revoke();\n    }\n  }\n\n  private _revokeBy(revoke: () => void) {\n    this._revoke = mergeFunctions(revoke, this._revoke);\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapValueRegistry } from '../../boot/impl';\nimport { Class } from '../../common';\nimport { FeatureNeedClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureRequester__key = /*#__PURE__*/ new SingleContextKey<FeatureRequester>(\n    'feature-requester',\n    {\n      byDefault: bootstrapDefault(context => new FeatureRequester(context)),\n    },\n);\n\n/**\n * @internal\n */\nexport class FeatureRequester {\n\n  static get [ContextKey__symbol](): ContextKey<FeatureRequester> {\n    return FeatureRequester__key;\n  }\n\n  readonly registry: BootstrapValueRegistry;\n  private readonly _map = new Map<Class, FeatureRequest>();\n\n  constructor(context: BootstrapContext) {\n    this.registry = context.get(BootstrapValueRegistry);\n  }\n\n  request(feature: Class, clauses: readonly FeatureNeedClause[] = []): FeatureRequest {\n\n    const existing = this._map.get(feature);\n\n    if (existing) {\n      return existing.reuse(clauses);\n    }\n\n    const request = new FeatureRequest(this, feature);\n\n    this._map.set(feature, request);\n\n    return request.request(clauses);\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip } from 'call-thru';\nimport { AfterEvent, afterEventBy, trackValue } from 'fun-events';\nimport { newNamespaceAliaser } from 'namespace-aliaser';\nimport { Class } from '../../common';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureDef, LoadedFeature } from '../../feature';\nimport { FeatureKey, FeatureLoader, FeatureRequester } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapValueRegistry, ElementBuilder } from '../impl';\nimport { componentFactoryOf } from '../impl/component-factory.symbol.impl';\n\n/**\n * Bootstraps components.\n *\n * Note that both features and components can be passed as parameters to this function, as components are features too.\n *\n * @category Core\n * @param features  Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapRegistry = BootstrapValueRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.get(FeatureRequester).request(feature);\n  bootstrapContext.get(FeatureKey.of(feature))(loader => {\n    loader!.init().then(complete);\n  });\n\n  return bootstrapContext;\n}\n\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\nfunction initBootstrap(bootstrapRegistry: BootstrapValueRegistry) {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const whenReady = stage.read.thru(s => s ? nextArgs() : nextSkip());\n  const values = bootstrapRegistry.values;\n\n  class Context extends BootstrapContext {\n\n    readonly get = values.get;\n\n    get onDefinition() {\n      return this.get(ElementBuilder).definitions.on;\n    }\n\n    get onComponent() {\n      return this.get(ElementBuilder).components.on;\n    }\n\n    constructor() {\n      super();\n      bootstrapRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    async whenDefined<C extends object>(componentType: ComponentClass<C>) {\n      await new Promise(resolve => this.whenReady(resolve));\n      await this.get(CustomElements).whenDefined(componentType);\n      return componentFactoryOf(componentType);\n    }\n\n    whenReady(callback: (this: void) => void): void {\n      whenReady.once(callback);\n    }\n\n    load(feature: Class<any>): AfterEvent<[LoadedFeature]> {\n      return afterEventBy<[LoadedFeature]>(receiver => {\n\n        const request = bootstrapContext.get(FeatureRequester).request(feature);\n        const info = trackValue<LoadedFeature>({\n          feature,\n          ready: false,\n        });\n\n        this.get(FeatureKey.of(feature))({\n          supply: receiver.supply,\n          receive(_ctx, ldr) {\n\n            // Present until `request` revoked\n            // But that happens only when supply is cut off.\n            const loader = ldr as FeatureLoader;\n\n            info.it = {\n              feature: loader.request.feature,\n              ready: loader.ready,\n            };\n            if (!loader.ready) {\n              loader.init().then(() => {\n                info.it = {\n                  feature: loader.request.feature,\n                  ready: true,\n                };\n              });\n            }\n          },\n        }).whenOff(() => {\n          request.unuse(); // Apply this callback _after_ registration complete,\n                           // to prevent receiver call.\n        });\n\n        info.read(receiver);\n      }).share();\n    }\n\n  }\n\n  const bootstrapContext = new Context();\n\n  return {\n    bootstrapContext,\n    complete() {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n","/**\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = /*#__PURE__*/ Symbol('attribute');\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath__root_Keys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name  Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\n// tslint:disable-next-line:class-name\nexport interface AttributePath__root_Keys {\n  [AttributePath__root]: true;\n}\n","/**\n * @module @wesib/wesib\n */\nimport { noop } from 'call-thru';\nimport { StatePath } from 'fun-events';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributePath, attributePathTo } from './attribute-path';\nimport { AttributeChangedCallback } from './attribute-registrar';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const key = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? defaultUpdateState : updateState;\n\n    return function (this: T, newValue, oldValue) {\n      update.call(this, key, newValue, oldValue);\n    };\n  }\n  return function (this: T, newValue, oldValue) {\n    ComponentContext.of(this).updateState(updateState, newValue, oldValue);\n  };\n}\n\nfunction defaultUpdateState<T extends object>(\n    this: T,\n    path: AttributePath,\n    newValue: string,\n    oldValue: string | null) {\n  ComponentContext.of(this).updateState(path, newValue, oldValue);\n}\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\n\n/**\n * Custom element attribute change callback.\n *\n * This function is called whenever a new attribute value assigned.\n *\n * @category Feature\n * @typeparam T  A type of component.\n */\nexport type AttributeChangedCallback<T extends object = any> =\n/**\n * @param this  Component instance.\n * @param newValue  New attribute value.\n * @param oldValue  Previous attribute value, or `null` if there were no value assigned.\n */\n    (this: T, newValue: string, oldValue: string | null) => void;\n\n/**\n * @category Feature\n */\nexport type AttributeRegistrar<T extends object = any> = (name: string, callback: AttributeChangedCallback<T>) => void;\n\n/**\n * @category Feature\n */\nexport const AttributeRegistrar: SingleContextRef<AttributeRegistrar> =\n    /*#__PURE__*/ new SingleContextKey<AttributeRegistrar>('attribute-registrar');\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class, mergeFunctions } from '../../common';\nimport { ComponentContext, ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback } from './attribute-registrar';\n\nconst AttributeRegistry__key = /*#__PURE__*/ new SingleContextKey<AttributeRegistry>('attribute-registry');\n\n/**\n * @internal\n */\nexport class AttributeRegistry<T extends object = any> {\n\n  static get [ContextKey__symbol](): ContextKey<AttributeRegistry> {\n    return AttributeRegistry__key;\n  }\n\n  private readonly _MutationObserver: typeof MutationObserver;\n  private readonly _attrs: { [name: string]: AttributeChangedCallback<T> } = {};\n\n  constructor(ctx: DefinitionContext) {\n    this._MutationObserver = (ctx.get(BootstrapWindow) as any).MutationObserver;\n  }\n\n  add(name: string, callback: AttributeChangedCallback<T>): void {\n    this._attrs[name] = mergeFunctions<[string, string | null], void, T>(this._attrs[name], callback);\n  }\n\n  define(elementType: Class) {\n\n    const attrs = this._attrs;\n    const observedAttributes = Object.keys(attrs);\n\n    if (!observedAttributes.length) {\n      return; // No attributes defined\n    }\n\n    Object.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes,\n    });\n    Object.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: function (name: string, oldValue: string | null, newValue: string) {\n        (attrs[name] as any).call(ComponentContext.of(this).component, newValue, oldValue);\n      },\n    });\n  }\n\n  mount(mount: ComponentMount<T>) {\n\n    const element = mount.element;\n    const attrs = this._attrs;\n    const attributeFilter = Object.keys(attrs);\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const observer = new this._MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return (attrs[attributeName] as any).call(\n                  ComponentContext.of(element).component,\n                  element.getAttribute(attributeName),\n                  record.oldValue);\n            }));\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { AttributeChangedCallback, AttributeRegistrar } from './attribute-registrar';\nimport { AttributeRegistry } from './attribute-registry.impl';\n\nconst AttributesSupport__feature: FeatureDef = {\n  perDefinition: [\n    { as: AttributeRegistry },\n    {\n      a: AttributeRegistrar,\n      by(registry: AttributeRegistry) {\n        return <T extends object>(name: string, callback: AttributeChangedCallback<T>) =>\n            registry.add(name, callback);\n      },\n      with: [AttributeRegistry],\n    },\n  ],\n  init(context) {\n    context.onDefinition(definitionContext => {\n      // Define element prototype attributes\n      definitionContext.whenReady(elementType => definitionContext.get(AttributeRegistry).define(elementType));\n    });\n    context.onComponent(componentContext => {\n\n      const mount = componentContext.mount;\n\n      if (mount) {\n        // Mount element attributes\n        componentContext.get(AttributeRegistry).mount(mount);\n      }\n    });\n  },\n};\n\n/**\n * A feature adding attributes to custom elements.\n *\n * This feature is enabled automatically whenever an `@Attribute`, `@Attributes`, or `@AttributeChanged` decorator\n * applied to component.\n *\n * @category Feature\n */\nexport class AttributesSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return AttributesSupport__feature;\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { TypedPropertyDecorator } from '../../common';\nimport { ComponentContext, ComponentDef } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { FeatureDef } from '../feature-def';\nimport { AttributeDef } from './attribute-def';\nimport { parseAttributeDef } from './attribute-def.impl';\nimport { AttributeRegistrar } from './attribute-registrar';\nimport { AttributesSupport } from './attributes-support.feature';\n\n/**\n * Creates a decorator for component's property that accesses custom element's attribute.\n *\n * The decorated property accesses corresponding attribute on read, and updates it on setting.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Attribute definition or just an attribute name.\n *\n * @return Component property decorator.\n */\nexport function Attribute<T extends ComponentClass>(\n    def?: AttributeDef<InstanceType<T>> | string,\n): TypedPropertyDecorator<T> {\n  return <V>(target: InstanceType<T>, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<V>) => {\n\n    const { name, updateState } = parseAttributeDef(target, propertyKey, def);\n    const componentType = target.constructor as T;\n\n    FeatureDef.define(componentType, { needs: AttributesSupport });\n    ComponentDef.define(\n        componentType,\n        {\n          define(definitionContext) {\n            definitionContext.get(AttributeRegistrar)(name, updateState);\n          },\n        });\n\n    const newDesc: TypedPropertyDescriptor<string | null> = {\n      get(this: InstanceType<T>): string | null {\n        return ComponentContext.of(this).element.getAttribute(name);\n      },\n      set(this: InstanceType<T>, newValue: string | null) {\n        ComponentContext.of(this).element.setAttribute(name, newValue as string);\n      },\n    };\n\n    if (descriptor == null) {\n      // Annotated field\n      Object.defineProperty(target, propertyKey, newDesc);\n      return;\n    }\n\n    return newDesc;\n  };\n}\n","import { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-registrar';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\n\n/**\n * @internal\n */\nexport function parseAttributeDef<T extends ComponentClass>(\n    target: InstanceType<T>,\n    propertyKey: string | symbol,\n    opts?: AttributeDef<InstanceType<T>> | string) {\n\n  let name: string;\n  let updateState: AttributeChangedCallback<InstanceType<T>>;\n\n  if (typeof opts === 'string') {\n    name = opts;\n    updateState = attributeStateUpdate(name);\n  } else {\n    if (opts && opts.name) {\n      name = opts.name;\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required, as property key is not a string: ' +\n          `${target.constructor.name}.${propertyKey.toString()}`);\n    } else {\n      name = propertyKey;\n    }\n\n    updateState = attributeStateUpdate(name, opts && opts.updateState);\n  }\n\n  return { name, updateState };\n}\n","/**\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = /*#__PURE__*/ Symbol('dom-property');\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n */\nexport type DomPropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath__root_Keys, K];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): DomPropertyPath<K> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// tslint:disable-next-line:class-name\nexport interface DomPropertyPath__root_Keys {\n  [DomPropertyPath__root]: true;\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { StateTracker } from 'fun-events';\n\nconst ComponentState__key = /*#__PURE__*/ new SingleContextKey<ComponentState>('component-state');\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ComponentContext, StateUpdater } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ComponentState } from './component-state';\n\nconst StateSupport__feature: FeatureDef = {\n  perComponent: [\n    {\n      a: ComponentState,\n      by(context: ComponentContext) {\n\n        const state = new ComponentState();\n\n        context.whenDestroyed(reason => state.done(reason));\n\n        return state;\n      },\n    },\n    {\n      a: StateUpdater,\n      by(state: ComponentState) {\n        return state.update;\n      },\n      with: [ComponentState],\n    },\n  ],\n};\n\n/**\n * Component state support feature.\n *\n * When enabled, it registers the following component context values:\n *\n * - [[StateUpdater]] that allows to update the component state, and\n * - [[ComponentState]] that allows to track component state changes.\n *\n * Other features would use this to notify when the state changes. E.g. [[DomPropertiesSupport]]\n * and [[AttributesSupport]] features issue state updates when needed.\n *\n * @category Feature\n */\nexport class StateSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StateSupport__feature;\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\n\nconst RenderScheduler__key = /*#__PURE__*/ new SingleContextKey<RenderScheduler>('render-scheduler');\n\n/**\n * Rendering scheduler.\n *\n * Schedules components rendering in order to make it less often. E.g. by utilizing `requestAnimationFrame()`.\n *\n * @category Feature\n */\nexport abstract class RenderScheduler {\n\n  /**\n   * A key of bootstrap, definition, or component context value containing [[RenderScheduler]] instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<RenderScheduler> {\n    return RenderScheduler__key;\n  }\n\n  /**\n   * Creates new render schedule.\n   *\n   * @returns New render schedule instance.\n   */\n  abstract newSchedule(): RenderSchedule;\n\n}\n\n/**\n * Render schedule.\n *\n * @category Feature\n */\nexport interface RenderSchedule {\n\n  /**\n   * Schedules component rendering.\n   *\n   * Only the latest rendering request has affect. I.e. if multiple rendering have been scheduled then the rendering\n   * will be performed by the latest one.\n   *\n   * @param render  A rendering function.\n   */\n  schedule(render: (this: void) => void): void;\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { RenderDef } from './render-def';\nimport { RenderScheduler } from './render-scheduler';\n\n/**\n * Component element render function interface.\n *\n * It has no arguments. It may return either nothing, or a function. In the latter case the returned function will be\n * called immediately to render the element. It may, in turn, return a render function, and so on.\n *\n * @category Feature\n */\nexport type ElementRender =\n/**\n * @returns Either delegated render, or nothing.\n */\n    (this: void) => void | ElementRender;\n\n/**\n * @category Feature\n */\nexport const ElementRender = {\n\n  /**\n   * Enables component element rendering.\n   *\n   * The `render` call will be scheduled by [[RenderScheduler]] once component state updated.\n   *\n   * @param context  Target component context.\n   * @param render  Element render function.\n   * @param def  Optional element render definition.\n   */\n  render(\n      context: ComponentContext,\n      render: ElementRender,\n      def: RenderDef = {},\n  ) {\n\n    const stateTracker = context.get(ComponentState);\n    const schedule = context.get(RenderScheduler).newSchedule();\n\n    const { offline } = def;\n    let rendered = false;\n    const stateSupply = stateTracker.onUpdate(() => {\n      if (offline || context.connected) {\n        scheduleRender();\n      } else {\n        rendered = false;\n      }\n    });\n\n    if (offline) {\n      scheduleRender();\n    } else {\n      context.whenOn(() => {\n        if (!rendered) {\n          scheduleRender();\n        }\n      }).whenOff(reason => {\n        stateSupply.off(reason);\n        rendered = true;\n      });\n    }\n\n    function scheduleRender() {\n      rendered = true;\n      schedule.schedule(renderElement);\n    }\n\n    function renderElement() {\n      for (;;) {\n\n        const newRender = render();\n\n        if (newRender === render || typeof newRender !== 'function') {\n          break;\n        }\n\n        render = newRender;\n      }\n    }\n  },\n\n};\n","/**\n * @module @wesib/wesib\n */\nimport { noop } from 'call-thru';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { RenderSchedule as RenderSchedule_, RenderScheduler as RenderScheduler_ } from './render-scheduler';\n\nconst RenderSupport__feature: FeatureDef = {\n  set: {\n    a: RenderScheduler_,\n    by: createRenderScheduler,\n    with: [BootstrapWindow],\n  },\n};\n\n/**\n * Rendering support feature.\n *\n * This feature is automatically enabled when {@link Render @Render} decorator is used.\n *\n * @category Feature\n */\nexport class RenderSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return RenderSupport__feature;\n  }\n\n}\n\nfunction createRenderScheduler(window: BootstrapWindow) {\n\n  class RenderScheduler extends RenderScheduler_ {\n\n    newSchedule() {\n\n      let scheduled: () => void = noop;\n\n      class RenderSchedule implements RenderSchedule_ {\n\n        schedule(render: (this: void) => void): void {\n\n          const previouslyScheduled = scheduled;\n\n          scheduled = render;\n          if (previouslyScheduled === noop) {\n            window.requestAnimationFrame(() => {\n              scheduled();\n              scheduled = noop;\n            });\n          }\n        }\n\n      }\n\n      return new RenderSchedule();\n    }\n  }\n\n  return new RenderScheduler();\n}\n","/**\n * @module @wesib/wesib\n */\nimport { TypedPropertyDecorator } from '../../common';\nimport { ComponentDef } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StateSupport } from '../state';\nimport { ElementRender } from './element-render';\nimport { RenderDef } from './render-def';\nimport { RenderSupport } from './render-support.feature';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by [[RenderScheduler]] once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * This decorator automatically enables [[StateSupport]] and [[RenderSupport]] features.\n *\n * Utilizes [[ElementRender.render]] function to define rendering.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<T extends ComponentClass>(def?: RenderDef): TypedPropertyDecorator<T> {\n  return (target: InstanceType<T>, propertyKey: string | symbol) => {\n\n    const componentType = target.constructor as T;\n\n    ComponentDef.define(\n        componentType,\n        {\n          define(defContext) {\n            defContext.onComponent(componentContext => {\n              componentContext.whenReady(() => {\n\n                const component = componentContext.component as any;\n                const render: () => any = component[propertyKey].bind(component);\n\n                ElementRender.render(componentContext, render, def);\n              });\n            });\n          },\n          feature: {\n            needs: [StateSupport, RenderSupport],\n          },\n        });\n  };\n}\n","/**\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\n\n/**\n * Component shadow content root.\n *\n * @category Feature\n */\nexport type ShadowContentRoot = ShadowRoot;\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nexport const ShadowContentRoot: SingleContextRef<ShadowContentRoot> =\n    /*#__PURE__*/ new SingleContextKey<ShadowContentRoot>('shadow-content-root');\n","/**\n * @module @wesib/wesib\n */\n/**\n * An event related to element's shadow DOM.\n *\n * The following event types supported:\n * - `wesib:shadowAttached` is thrown when a shadow root is attached to element.\n *   In particular, it is thrown for components decorated with {@link AttachShadow @AttachShadow}.\n *   This event bubbles and is not cancelable.\n *\n * @category Feature\n */\nexport class ShadowDomEvent extends Event {\n\n  /**\n   * Constructs shadow DOM event.\n   *\n   * @param type  Event type.\n   * @param eventInitDict  Event initialization dictionary.\n   */\n  constructor(type: string, eventInitDict?: EventInit) {\n    super(type, eventInitDict);\n  }\n\n  /**\n   * Shadow root this event relates to.\n   */\n  get shadowRoot(): ShadowRoot {\n    return (this.target as Element).shadowRoot as ShadowRoot;\n  }\n\n}\n","/**\n * @module @wesib/wesib\n */\nimport { FnContextKey, FnContextRef } from 'context-values';\nimport { ComponentContext } from '../../component';\nimport { ShadowContentDef } from './shadow-content-def';\n\n/**\n * Shadow root builder function type.\n *\n * An instance of this function is available in component context and is used by {@link AttachShadow @AttachShadow}\n * decorator to attach shadow root to decorated component's custom element.\n *\n * By default, if shadow root already exists for the component's element, it uses it.\n *\n * Dispatches a `wesib:shadowAttached` event for the found or attached shadow root.\n *\n * @category Feature\n */\nexport type ShadowRootBuilder =\n/**\n * @param context  Target component context.\n * @param init  Shadow root initialization options.\n *\n * @returns A shadow root instance for target component, or `null`/`undefined` if one can not be attached.\n */\n    (context: ComponentContext<any>, init: ShadowContentDef) => ShadowRoot | null | undefined;\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nexport const ShadowRootBuilder: FnContextRef<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>> =\n    /*#__PURE__*/ new FnContextKey<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>>('shadow-root-builder');\n","/**\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ShadowDomEvent } from './shadow-dom-event';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\nconst ShadowDomSupport__feature: FeatureDef = {\n  set: [\n    { a: ShadowRootBuilder, is: attachShadow },\n  ],\n};\n\n/**\n * Shadow root support feature.\n *\n * This feature is automatically enabled when {@link AttachShadow @AttachShadow} decorator is used.\n *\n * @category Feature\n */\nexport class ShadowDomSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ShadowDomSupport__feature;\n  }\n\n}\n\nfunction attachShadow(context: ComponentContext, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const element = context.element;\n  const shadowRoot = shadowRootOf(element, init);\n\n  if (shadowRoot) {\n    (shadowRoot as any)[ComponentContext__symbol] = context;\n    context.dispatchEvent(new ShadowDomEvent('wesib:shadowAttached', { bubbles: true }));\n    return shadowRoot;\n  }\n\n  return;\n}\n\nfunction shadowRootOf(element: Element, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const existing = element.shadowRoot;\n\n  if (existing) {\n    // Shadow root already attached. Using it.\n    return existing;\n  }\n  if ('attachShadow' in element) {\n    return element.attachShadow(init);\n  }\n\n  return; // Unable to attach shadow root.\n}\n","/**\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentDef, ContentRoot } from '../../component';\nimport { ShadowContentRoot } from './shadow-content-root';\nimport { ShadowDomSupport } from './shadow-dom-support.feature';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * Shadow content root definition.\n *\n * This is a readonly component shadow root initialization options.\n *\n * @category Feature\n */\nexport type ShadowContentDef = Readonly<ShadowRootInit>;\n\nconst defaultShadowContentDef: ShadowContentDef = { mode: 'open' };\n\n/**\n * @category Feature\n */\nexport const ShadowContentDef = {\n\n  /**\n   * Creates component definition for the given shadow content root definition.\n   *\n   * The returned component definition enables [[ShadowDomSupport]] feature and attaches shadow content root to the\n   * component.\n   *\n   * @typeparam T  A type of component.\n   * @param def  Shadow content root definition. Uses `mode: 'open'` by default.\n   *\n   * @returns Component definition.\n   */\n  componentDef<T extends object>(def: ShadowContentDef = defaultShadowContentDef): ComponentDef<T> {\n    return {\n      perComponent: [\n        {\n          a: ShadowContentRoot,\n          by(ctx: ComponentContext<T>) {\n            return ctx.get(ShadowRootBuilder)(ctx, def);\n          },\n        },\n        { // Content root is an alias of shadow root when present.\n          a: ContentRoot,\n          by(context: ComponentContext<T>) {\n            return context.get(ShadowContentRoot, { or: null });\n          },\n        },\n      ],\n      feature: { needs: ShadowDomSupport },\n    };\n  },\n\n};\n","/**\n * @module @wesib/wesib\n */\nimport { TypedClassDecorator } from '../../common';\nimport { ComponentDef } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ShadowContentDef } from './shadow-content-def';\n\n/**\n * Component class decorator that attaches shadow root to decorated component instance.\n *\n * Applies component definition created by [[ShadowContentDef.componentDef]] function.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @return Component class decorator.\n */\nexport function AttachShadow<T extends ComponentClass = any>(\n    def?: ShadowContentDef,\n): TypedClassDecorator<T> {\n  return (type: T) => {\n    ComponentDef.define(\n        type,\n        ShadowContentDef.componentDef(def));\n  };\n}\n","import { ContextUpKey, ContextUpRef, ContextValueOpts, ContextValues } from 'context-values';\nimport { AfterEvent, EventKeeper, EventSender, OnEvent, onSupplied } from 'fun-events';\n\ntype FetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<Res>,\n    request: Request,\n) => EventSender<Res>;\n\ntype CombinedFetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n) => OnEvent<Res>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<Res extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>\n    implements ContextUpRef<CombinedFetchAgent<Res>, FetchAgent<Res>, AfterEvent<FetchAgent<Res>[]>> {\n\n  constructor(name: string) {\n    super(name);\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          CombinedFetchAgent<Res>,\n          EventKeeper<FetchAgent<Res>[]> | FetchAgent<Res>,\n          AfterEvent<FetchAgent<Res>[]>>,\n  ): CombinedFetchAgent<Res> {\n\n    let agent!: CombinedFetchAgent<Res>;\n\n    opts.seed((...agents) => agent = combineFetchAgents(agents));\n\n    const fallback = opts.byDefault(() => (next, request) => agent(next, request));\n\n    return fallback || defaultFetchAgent;\n  }\n\n}\n\nfunction defaultFetchAgent<Res extends any[]>(\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n): OnEvent<Res> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<Res extends any[]>(agents: FetchAgent<Res>[]): CombinedFetchAgent<Res> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<Res> = (agentIdx, agentRequest) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","/**\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter [[HttpFetch]] processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by [[HttpFetch]].\n */\nexport type HttpFetchAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * [[HttpFetch]] call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under [[HttpFetchAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of response object(s) receivers. It is returned as a result of [[HttpFetch]] call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an [[HttpFetchAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> =\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent');\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { DomEventDispatcher, EventEmitter, EventSupply, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: EventSupply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new (window as any).AbortController();\n        const { signal } = abortController;\n\n        supply = eventSupply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal).on('abort').once(() => abortController.abort());\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","/**\n * @module @wesib/generic\n */\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { FnContextKey, FnContextRef } from 'context-values';\nimport { OnEvent } from 'fun-events';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of [[HttpFetch]] is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input  The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init  Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an [[HttpFetch]] instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> =\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n    'http-fetch',\n    {\n      byDefault: bootstrapDefault(newHttpFetch),\n    },\n);\n","/**\n * @module @wesib/generic\n */\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnDomEvent,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { EnterPageEvent, LeavePageEvent, NavigationEvent, StayOnPageEvent } from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\nconst Navigation__key = /*#__PURE__*/ new SingleContextKey<Navigation>('navigation');\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value when [[NavigationSupport]] feature is enabled.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * An `OnDomEvent` registrar of enter page event receivers.\n   */\n  abstract readonly onEnter: OnDomEvent<EnterPageEvent>;\n\n  /**\n   * An `OnDomEvent` registrar of leave page event receivers.\n   *\n   * These receivers may cancel navigation by calling `preventDefault()` method of received event.\n   */\n  abstract readonly onLeave: OnDomEvent<LeavePageEvent>;\n\n  /**\n   * An `OnDomEvent` registrar of stay on page event receivers.\n   *\n   * These receivers are informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   */\n  abstract readonly onStay: OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * An `OnEvent` registrar of navigation events receivers.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[NavigationEvent]>;\n\n  get [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` registrar of current page receivers.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[Page]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read;\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta  Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target  Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target  Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url  An URL to replace the\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   * @param ref  A reference to page navigation parameter to apply.\n   * @param input  Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     * @param ref  A reference to page navigation parameter to apply.\n     * @param input  Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target  Either navigation target or URL to navigate to.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target  Either navigation target or URL to replace the latest history entry with.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to [[Navigation.open]] and [[Navigation.replace]] methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { ContextUpKey, ContextUpRef, ContextValueOpts, ContextValues } from 'context-values';\nimport { AfterEvent, EventKeeper } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n * @param when  When navigation occurred. Either `pre-open`, or `pre-replace`.\n * @param from  The page to leave.\n * @param to  Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent, AfterEvent<NavigationAgent[]>> {\n\n  constructor(name: string) {\n    super(name);\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          NavigationAgent.Combined,\n          EventKeeper<NavigationAgent[]> | NavigationAgent,\n          AfterEvent<NavigationAgent[]>>,\n  ): NavigationAgent.Combined {\n\n    const { document } = opts.context.get(BootstrapWindow);\n\n    return (next, when, from, to) => {\n\n      const result = opts.byDefault(() => combinedAgent);\n\n      return result ? result(next, when, from, to) : next(to);\n    };\n\n    function combinedAgent(\n        next: (this: void, target: Navigation.URLTarget) => void,\n        when: 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ): void {\n\n      let agents!: NavigationAgent[];\n\n      opts.seed.once((...sources) => agents = sources);\n\n      return navigate(0, to);\n\n      function navigate(agentIdx: number, agentTo: Page): void {\n\n        const agent = agents[agentIdx];\n\n        if (!agent) {\n          return next(agentTo);\n        }\n\n        agent(\n            (\n                {\n                  url: nextURL = agentTo.url,\n                  title: nextTitle = agentTo.title,\n                  data: nextData = agentTo.data,\n                }: Navigation.Target = agentTo,\n            ) => navigate(\n                agentIdx + 1,\n                {\n                  url: new URL(String(nextURL), document.baseURI),\n                  title: nextTitle,\n                  data: nextData,\n                  get visited() {\n                    return agentTo.visited;\n                  },\n                  get current() {\n                    return agentTo.current;\n                  },\n                  get(ref) {\n                    return agentTo.get(ref);\n                  },\n                  put(ref, input) {\n                    agentTo.put(ref, input);\n                  },\n                },\n            ),\n            when,\n            from,\n            agentTo,\n        );\n      }\n    }\n  }\n\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under [[NavigationAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n   * one. Not calling this function effectively prevents navigation.\n   * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n   * @param when  When navigation occurred. Either `pre-open`, or `pre-replace`.\n   * @param from  The page to leave.\n   * @param to  Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an [[NavigationAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> =\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent');\n","/**\n * @module @wesib/generic\n */\nimport { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = /*#__PURE__*/ Symbol('page-param');\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to [[LeavePageEvent]]). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeparam T  Parameter value type.\n * @typaparam I  Parameter input type.\n */\nexport abstract class PageParam<T, I> implements PageParam.Ref<T, I> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}.It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page  A page to assign navigation parameter to.\n   * @param input  Parameter input used to construct its initial value.\n   * @param context  Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: I, context: PageParamContext): PageParam.Handle<T, I>;\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeparam T  Parameter value type.\n   * @typaparam I  Parameter input type.\n   */\n  export interface Ref<T, I> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, I>;\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeparam T  Parameter value type.\n   * @typaparam I  Parameter input type.\n   */\n  export interface Handle<T, I> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input  Parameter input to use when updating its value.\n     */\n    put(input: I): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before [[LeavePageEvent]] is fired for each parameter handle of current page.\n     *\n     * @param to  A page to transfer parameter to.\n     * @param when  When the transfer happens. Either `pre-open`, `pre-replace`, `open`, or `return`. The latter is used\n     * when return to page generated by another app version. E.g. from the page that has been reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(to: Page, when: 'pre-open' | 'pre-replace' | 'enter' | 'return'): Handle<T, I> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page  Entered page.\n     * @param when  When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at  The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { ContextValues } from 'context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { ValueTracker } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\nconst RoutingHistory__key = /*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'navigation-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n);\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol]() {\n    return RoutingHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ) {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ) {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ) {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry) {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        data,\n      },\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object' ? { data: state } : state[NAV_DATA_KEY];\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _context: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      url: target.url,\n      title: target.title,\n      data: target.data,\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get(ref) {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(ref[PageParam__symbol]);\n\n    return handle && handle.get();\n  }\n\n  put<T, I>(ref: PageParam.Ref<T, I>, input: I): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, I> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    const registry = new ContextRegistry<ParamContext>(this._context);\n\n    class ParamContext extends PageParamContext {\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n    }\n\n    const newHandle = param.create(this.page, input, new ParamContext());\n\n    this._params.set(param, newHandle);\n    if (this.page.current && newHandle.enter) {\n      newHandle.enter(this.page, 'init');\n    }\n\n    return newHandle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pre-open' | 'pre-replace' | 'enter' | 'return') {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page) {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return') {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave() {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget() {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void) {\n    this._update = update;\n  }\n\n  apply() {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n","/**\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { createNavigation } from './navigation.impl';\n\nconst NavigationSupport__feature: FeatureDef = {\n  set: { a: Navigation, by: createNavigation },\n};\n\n/**\n * Browser navigation support feature.\n *\n * Makes [[Navigation]] available in bootstrap context.\n */\nexport class NavigationSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return NavigationSupport__feature;\n  }\n\n}\n","import { BootstrapContext, BootstrapWindow, mergeFunctions } from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { AfterEvent, DomEventDispatcher, onAny, trackValue } from 'fun-events';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { Navigation as Navigation_ } from './navigation';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\nexport function createNavigation(context: BootstrapContext): Navigation_ {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage);\n  const onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage);\n  const onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage);\n  const onEvent = onAny<[NavigationEvent]>(onEnter, onLeave, onStay);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  const readPage: AfterEvent<[Page]> = nav.read.keep.thru(entry => entry.page);\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate')(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange')(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  class Navigation extends Navigation_ {\n\n    get length() {\n      return history.length;\n    }\n\n    get onEnter() {\n      return onEnter;\n    }\n\n    get onLeave() {\n      return onLeave;\n    }\n\n    get onStay() {\n      return onStay;\n    }\n\n    get on() {\n      return onEvent;\n    }\n\n    get read() {\n      return readPage;\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation_.Target | string | URL) {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation_.Target | string | URL) {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation_.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation();\n\n  function withParam(applyParams: (page: Page) => void): Navigation_.Parameterized {\n    return {\n      with<TT, II>(ref: PageParam.Ref<TT, II>, input: II): Navigation_.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target: Navigation_.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target: Navigation_.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function urlTargetOf(target: Navigation_.Target | string | URL): Navigation_.URLTarget {\n    if (typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation_.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target: Navigation_.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const urlTarget = urlTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n\n        navHistory[when](toEntry, nav);\n\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = navHistory.newEntry(urlTarget);\n\n      fromEntry.transfer(toEntry, whenLeave);\n\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      applyParams(toEntry.page);\n      if (!dispatcher.dispatch(leavePage) || next !== promise) {\n        return stay(toEntry);\n      }\n\n      let finalTarget: Navigation_.URLTarget | undefined;\n\n      agent(t => finalTarget = t, whenLeave, leavePage.from, leavePage.to);\n\n      if (!finalTarget) {\n        return stay(toEntry); // Some agent didn't call `next()`.\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: urlTarget,\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n}\n","import { nextArgs, nextSkip } from 'call-thru';\nimport { eventSupply, EventSupply, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: EventSupply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = eventSupply().whenOff(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.whenOff(reason => {\n          trackSupply.off(reason);\n          tracker.done(reason);\n        });\n\n        tracked = {\n          on: tracker.read.thru_(\n              response => response ? nextArgs(response) : nextSkip(),\n          ),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on(receiver).needs(supply).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          });\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import { flatMapIt, itsEach, itsIterator } from 'a-iterable';\nimport { asis, noop } from 'call-thru';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n} from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\n/**\n * @internal\n */\nexport class PageLoadRequests implements Iterable<PageLoadReq> {\n\n  private readonly _map = new Map<EventSupply, PageLoadReq[]>();\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {}\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    for (const request of this) {\n      if (!request.fragment) {\n        return [];\n      }\n      result.push(request.fragment);\n    }\n\n    return result;\n  }\n\n  [Symbol.iterator](): Iterator<PageLoadReq> {\n    return itsIterator(flatMapIt(this._map.values(), asis));\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = eventSupply();\n    let loadSupply = noEventSupply();\n\n    return {\n      get() {},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page) {\n\n        const transferred = self._transfer();\n\n        to.put(pageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = eventSupply().needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page)(response => emitter.send(response)).whenOff(error => {\n            if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n              // Report current page load error as failed load response\n              emitter.send({\n                ok: false as const,\n                page,\n                error,\n              });\n            }\n          }).needs(loadSupply);\n\n          return supply;\n        }).share();\n\n        itsEach(\n            self,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n              supply: eventSupply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest) {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, [...list]);\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.thru_(\n          response => response.ok\n              ? {\n                ...response,\n                fragment: (\n                    fragment.tag != null\n                    ? response.document.getElementsByTagName(fragment.tag)[0]\n                    : response.document.getElementById(fragment.id)\n                ) || undefined,\n              }\n              : response,\n      )\n      : onLoad;\n}\n\nclass PageLoadRequestsParam extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const pageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam();\n","/**\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under [[PageLoadAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of loaded document.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an [[DomFetchAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> =\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent');\n","import { noop, valueProvider } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url  An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> =\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) });\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsReduction } from 'a-iterable';\nimport { SingleContextKey } from 'context-values';\nimport { afterThe, EventEmitter, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { hthvParse, hthvQuote } from 'http-header-value';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { pageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = /*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n);\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser: DOMParser = new (window as any).DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ 'Accept': 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request)(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      fetchRequest = pageFragmentsRequest(page, fetchRequest);\n\n      const responseTextEmitter = new EventEmitter<[Response, string]>();\n      const onResponse: OnEvent<[PageLoadResponse]> = responseTextEmitter.on.thru_(\n          (response, text) => {\n            if (!response.ok) {\n              return {\n                ok: false as const,\n                page,\n                response,\n                error: response.status,\n              };\n            }\n            try {\n              return {\n                ok: true as const,\n                page,\n                response,\n                document: parsePageDocument(parser, url, response, text),\n              };\n            } catch (error) {\n              return {\n                ok: false as const,\n                page,\n                response,\n                error,\n              };\n            }\n          },\n      );\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const { supply } = receiver;\n\n        afterThe<[PageLoadResponse.Start]>({ page }).once({\n          supply: eventSupply().needs(supply),\n          receive(ctx, start) {\n            receiver.receive(ctx, start);\n          },\n        });\n\n        const responseSupply = httpFetch(fetchRequest)(response => {\n          onResponse(receiver);\n          response.text().then(\n              text => {\n                responseTextEmitter.send(response, text);\n                supply.needs(responseSupply);\n              },\n          ).catch(\n              e => supply.off(e),\n          );\n        });\n      });\n    }\n  };\n}\n\nfunction pageFragmentsRequest(page: Page, request: Request ) {\n\n  const fragments = page.get(pageLoadRequestsParam)?.fragments;\n\n  if (!fragments || !fragments.length) {\n    return request;\n  }\n\n  return new Request(\n      request,\n      {\n        headers: {\n          'Accept-Fragment': itsReduction(\n              fragments,\n              (header, fragment) =>\n                  (header ? header + ', ' : '')\n                  + (\n                      fragment.tag != null\n                          ? 'tag=' + hthvQuote(fragment.tag)\n                          : 'id=' + hthvQuote(fragment.id)\n                  ),\n              '',\n          ),\n        },\n      },\n  );\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as SupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","import { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, pageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\nclass PageLoadParam extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext) {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(pageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const pageLoadParam: PageParam<void, PageLoadRequest> = /*#__PURE__*/ new PageLoadParam();\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { AfterEvent, afterThe } from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = /*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n);\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<[PageLoadURLModifier?]>;\n  readonly agent: AfterEvent<[PageLoadAgent?]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe((next, request) => {\n        return next(new Request(request.url, request)).thru_(response => {\n          if (response.ok) {\n\n            const newRev = appRev(response.document);\n\n            if (newRev && newRev !== rev) {\n\n              const searchParams = new URLSearchParams(response.page.url.searchParams);\n\n              searchParams.set(appRevSearchParam, newRev);\n              navigation.update('?' + searchParams);\n              navigation.reload();\n            }\n          }\n\n          return response;\n        });\n      });\n    }\n  }\n\n}\n\nfunction appRev(doc: Document) {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","/**\n * @module @wesib/generic\n */\nimport { itsEach, overArray } from 'a-iterable';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContents]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param before  The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContents]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: N, to: N) => void),\n    importContent: (this: void, from: N, to: N) => void = importNodeContent,\n): N {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (from.nodeType !== Node.ELEMENT_NODE) {\n\n    const nodeClone = doc.importNode(from, false);\n\n    to.insertBefore(nodeClone, before);\n\n    return nodeClone;\n  }\n\n  const element = from as Node as Element;\n  const elementClone = doc.createElement(element.tagName.toLowerCase()) as Node as (Element & N);\n\n  element.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, element.getAttribute(attr)!));\n\n  importContent(from, elementClone);\n  to.insertBefore(elementClone, before);\n\n  return elementClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from  The node which contents to import.\n * @param to  The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { filterIt, itsEach, mapIt, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, overArray(doc.scripts)),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, overArray(response.document.querySelectorAll('script'))),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      },\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: Iterable<HTMLScriptElement>,\n): Iterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterIt(\n          scripts,\n          script => !!script.src,\n      ),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","/**\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { NavigationSupport } from '../navigation-support.feature';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\nconst PageLoadSupport__feature: FeatureDef = {\n  needs: NavigationSupport,\n  set: [\n    {\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    },\n    {\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    },\n    { a: PageLoadAgent, by: pageScriptsAgent },\n    { a: PageLoadAgent, by: pageStyleAgent },\n    { a: PageLoadAgent, by: pageTitleAgent },\n  ],\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach, itsFirst, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      },\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  });\n}\n","/**\n * @module @wesib/generic\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { EventSupply } from 'fun-events';\nimport { StypOptions, StypRules } from 'style-producer';\n\n/**\n * Component style producer function interface.\n */\nexport type ComponentStyleProducer =\n/**\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a `StypRule.rules` to render all rules,\n * or a result of `StypRuleList.grab()` method call to render only matching ones.\n * @param opts  Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\n    (\n        rules: StypRules,\n        opts?: StypOptions,\n    ) => EventSupply;\n\n/**\n * A key of component context value containing a component style producer.\n */\nexport const ComponentStyleProducer: SingleContextRef<ComponentStyleProducer> =\n    /*#__PURE__*/ new SingleContextKey<ComponentStyleProducer>('component-style-producer');\n","/**\n * @module @wesib/generic\n */\nimport { MultiContextKey, MultiContextRef } from 'context-values';\nimport { StypRender } from 'style-producer';\n\n/**\n * A CSS render that will be enabled by default by [[ComponentStyleProducer]].\n */\nexport type ComponentStypRender = StypRender;\n\n/**\n * A key of component context value containing component CSS renders.\n */\nexport const ComponentStypRender: MultiContextRef<ComponentStypRender> =\n    /*#__PURE__*/ new MultiContextKey<ComponentStypRender>('component-styp-render');\n","import { ComponentContext, DefaultNamespaceAliaser, ElementDef } from '@wesib/wesib';\nimport { ContextValues, SingleContextKey, SingleContextRef } from 'context-values';\nimport { css__naming, html__naming, NamespaceDef, QualifiedName } from 'namespace-aliaser';\n\n/**\n * @internal\n */\nexport type ElementIdClass = QualifiedName;\n\n/**\n * @internal\n */\nexport const ElementIdClass__NS = /*#__PURE*/ new NamespaceDef(\n    'https://wesib.github.io/ns/element-id-class',\n    'elic',\n    'element-id-class',\n);\n\n/**\n * @internal\n */\nexport const ElementIdClass: SingleContextRef<ElementIdClass> =\n    /*#__PURE__*/ new SingleContextKey('unique-element-class', { byDefault: assignElementId });\n\nlet uniqueClassSeq = 0;\n\nfunction assignElementId(contextValues: ContextValues): ElementIdClass {\n\n  const aliaser = contextValues.get(DefaultNamespaceAliaser);\n  const context = contextValues.get(ComponentContext);\n  const elementDef = context.get(ElementDef);\n  const name: string = elementDef.name ? html__naming.name(elementDef.name, aliaser) : 'component';\n  const local = `${name}#${++uniqueClassSeq}`;\n  const qualified = ElementIdClass__NS.name(aliaser(ElementIdClass__NS), local, css__naming);\n  const element = context.element as Element;\n\n  element.classList.add(qualified);\n\n  return qualified;\n}\n","import {\n  ArraySet,\n  BootstrapWindow,\n  ComponentContext,\n  ContentRoot,\n  DefaultNamespaceAliaser,\n  RenderScheduler,\n  ShadowContentRoot,\n} from '@wesib/wesib';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { EventSupply } from 'fun-events';\nimport { produceBasicStyle, StypOptions, StypRender, StypRules, StypSelector } from 'style-producer';\nimport { ComponentStypRender } from './component-styp-render';\nimport { ElementIdClass } from './element-id-class.impl';\n\nconst ComponentStyleProducer__key =\n    /*#__PURE__*/ new SingleContextKey<ComponentStyleProducer>('component-style-producer:impl');\n\nconst hostSelector: StypSelector.Normalized = [{ e: ':host' }];\n\n/**\n * @internal\n */\nexport class ComponentStyleProducer {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentStyleProducer> {\n    return ComponentStyleProducer__key;\n  }\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _produce = produceBasicStyle,\n  ) {}\n\n  produce(rules: StypRules, options: StypOptions = {}): EventSupply {\n\n    const context = this._context;\n    const shadowRoot = context.get(ShadowContentRoot, { or: null });\n\n    return this._produce(rules, {\n      ...options,\n      document: options.document || context.get(BootstrapWindow).document,\n      parent: options.parent || context.get(ContentRoot),\n      rootSelector: options.rootSelector || buildRootSelector(),\n      schedule: options.schedule || buildScheduler(),\n      nsAlias: options.nsAlias || context.get(DefaultNamespaceAliaser),\n      render: buildRender(),\n    });\n\n    function buildScheduler(): (operation: () => void) => void {\n\n      const scheduler = context.get(RenderScheduler);\n\n      return operation => scheduler.newSchedule().schedule(operation);\n    }\n\n    function buildRootSelector(): StypSelector {\n      return shadowRoot ? hostSelector : [];\n    }\n\n    function buildRender(): StypRender | readonly StypRender[] | undefined {\n\n      const { render } = options;\n      const renders = new ArraySet<StypRender>(render)\n          .add(...context.get(ComponentStypRender));\n\n      if (!shadowRoot) {\n        renders.add(noShadowRender(context.get(ElementIdClass)));\n      }\n\n      return renders.value;\n    }\n  }\n\n}\n\nfunction noShadowRender(idClass: ElementIdClass): StypRender {\n  return {\n    order: -100,\n    render(producer, properties) {\n      producer.render(properties, {\n        selector: [{ c: [idClass] }, ...producer.selector],\n      });\n    },\n  };\n}\n","/**\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol, RenderSupport } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { ComponentStyleProducer as ComponentStyleProducer_ } from './component-style-producer.impl';\n\nconst BasicStyleProducerSupport__feature: FeatureDef = {\n  needs: RenderSupport,\n  perComponent: [\n    {\n      as: ComponentStyleProducer_,\n    },\n    {\n      a: ComponentStyleProducer,\n      by(producer: ComponentStyleProducer_): ComponentStyleProducer {\n        return (rules, opts) => producer.produce(rules, opts);\n      },\n      with: [ComponentStyleProducer_],\n    },\n  ],\n};\n\n/**\n * Basic style producer support feature.\n *\n * Depends on [style-producer].\n *\n * Unlike [[StyleProducerSupport]] feature this one does not enable default CSS renders.\n *\n * It is enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * [style-producer]: https://www.npmjs.com/package/style-producer\n */\nexport class BasicStyleProducerSupport {\n\n  static get [FeatureDef__symbol]() {\n    return BasicStyleProducerSupport__feature;\n  }\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { ComponentContext } from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { eventSupply, EventSupply, noEventSupply } from 'fun-events';\nimport { lazyStypRules, StypOptions, StypRules } from 'style-producer';\nimport { ComponentStyleProducer } from './component-style-producer';\n\n/**\n * Component CSS styles production options.\n */\nexport interface ComponentStypOptions extends StypOptions {\n\n  /**\n   * Whether to produce CSS stylesheets while component is not connected.\n   *\n   * Can be one of:\n   * - `true` - to produce stylesheets when first connected and update them even if component is disconnected after\n   *   that. This is the default, as stylesheet updates is expected to be rare operation.\n   * - `false` - to produce stylesheet whenever component is connected and remove them once disconnected.\n   *   This is a good choice if stylesheets are small and updated frequently.\n   * - `always` - to produce stylesheets immediately upon component readiness and update them offline after that.\n   *   This is the right choice if component needs a stylesheet ready before it is added to the document.\n   */\n  offline?: boolean | 'always';\n\n}\n\nexport const ComponentStypOptions = {\n\n  /**\n   * Produces and dynamically updates component's CSS stylesheets based on the given CSS rules.\n   *\n   * @param context  Target component context.\n   * @param rules  A source of CSS rules to produce stylesheets for.\n   * @param options  Production options.\n   *\n   * @returns CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  produce(\n      context: ComponentContext,\n      rules: StypRules.Source,\n      options?: ComponentStypOptions,\n  ): EventSupply {\n\n    const css = lazyStypRules(rules);\n    const offline = options && options.offline;\n    const produceStyle = context.get(ComponentStyleProducer);\n\n    let cssSupply = noEventSupply();\n    let doProduceStyle: () => void;\n    const supply = eventSupply(reason => {\n      doProduceStyle = noop;\n      cssSupply.off(reason);\n    });\n\n    doProduceStyle = () => {\n      cssSupply = produceStyle(css, options).needs(supply);\n    };\n\n    switch (offline) {\n    case 'always':\n      context.whenReady(doProduceStyle);\n      break;\n    case false:\n      context.whenOn(connectionSupply => {\n        doProduceStyle();\n        cssSupply.needs(connectionSupply);\n      });\n      break;\n    default:\n      context.whenOn.once(doProduceStyle);\n    }\n\n    context.whenDestroyed(reason => supply.off(reason));\n\n    return supply;\n  },\n};\n","/**\n * @module @wesib/generic\n */\nimport { ComponentClass, ComponentDef } from '@wesib/wesib';\nimport { StypRules } from 'style-producer';\nimport { BasicStyleProducerSupport } from './basic-style-producer-support.feature';\nimport { ComponentStypOptions } from './component-styp-options';\n\n/**\n * A decorator of component property returning CSS rules to produce.\n *\n * Decorated property value should either contain a CSS rules source of type `StypRules.Source` or be a method\n * returning it.\n *\n * This decorator automatically enables [[BasicStyleProducerSupport]] feature.\n *\n * Utilizes [[ComponentStypOptions.produce]] function to produce CSS stylesheets.\n *\n * @typeparam T  A type of decorated component class.\n * @param options  Non-mandatory CSS style production options.\n *\n * @returns Component property decorator.\n */\nexport function ProduceStyle<T extends ComponentClass>(options?: ComponentStypOptions):\n    <V extends StypRules.Source | (() => StypRules.Source)>(\n        target: InstanceType<T>,\n        propertyKey: string | symbol,\n        descriptor?: TypedPropertyDescriptor<V>,\n    ) => any | void {\n  return (target: InstanceType<T>, propertyKey: string | symbol) => {\n\n    const componentType = target.constructor as T;\n\n    ComponentDef.define(\n        componentType,\n        {\n          define(defContext) {\n            defContext.onComponent(componentContext => {\n              componentContext.whenReady(component => {\n\n                const property = component[propertyKey];\n\n                ComponentStypOptions.produce(\n                    componentContext,\n                    typeof property === 'function' ? property.bind(component) : property,\n                    options,\n                );\n              });\n            });\n          },\n          feature: {\n            needs: [BasicStyleProducerSupport],\n          },\n        });\n  };\n}\n","/**\n * @module @wesib/generic\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { RefStypRule, StypProperties, StypRule, StypRuleRef, StypRules } from 'style-producer';\nimport { ThemeStyle } from './theme-style';\n\nconst Theme__key = new SingleContextKey<Theme>('theme');\n\n/**\n * A hierarchy of CSS rules within single root.\n *\n * A component may use it to extract styling information.\n *\n * Current theme is available in bootstrap, definition, or component context. By default, only one theme is declared\n * per bootstrap. But this can be overridden.\n */\nexport abstract class Theme {\n\n  /**\n   * A key of bootstrap, definition, or component context value containing current theme instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<Theme> {\n    return Theme__key;\n  }\n\n  /**\n   * Root CSS rule.\n   *\n   * All theme styling is represented as rules within this root.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * Obtains CSS rule reference by its `referrer`.\n   *\n   * This is a helper method that resolves the given `referrer` against the `root` CSS rule of this theme.\n   *\n   * @param referrer  Target CSS rule referrer.\n   *\n   * @returns CSS rule reference.\n   */\n  ref<T extends StypProperties<T>>(referrer: RefStypRule<T>): StypRuleRef<T> {\n    return referrer(this.root);\n  }\n\n  /**\n   * Obtains a styling for the given theme styles.\n   *\n   * This method requests the registered {@link ThemeStyle theme styles} for CSS rules they provide.\n   * If some of the styles are not registered then uses the given style as provider.\n   *\n   * @param styles  The styles to obtain styling information for.\n   *\n   * @returns Dynamically updated CSS rule set containing the requested styling.\n   */\n  abstract style(...styles: ThemeStyle.Provider[]): StypRules;\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { Theme } from './theme';\n\nconst ThemeFactory__key = new SingleContextKey<ThemeFactory>('theme-factory');\n\nexport abstract class ThemeFactory {\n\n  static get [ContextKey__symbol](): ContextKey<ThemeFactory> {\n    return ThemeFactory__key;\n  }\n\n  abstract newTheme(): Theme;\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { AIterable } from 'a-iterable';\nimport { ContextRef, ContextValueOpts, ContextValues, SimpleContextKey } from 'context-values';\nimport { stypRules, StypRules } from 'style-producer';\nimport { Theme } from './theme';\n\n/**\n * Theme style provides part of the theme styling information.\n *\n * Theme style(s) can be provided in bootstrap context. They are applied to the theme at most once, when requested\n * by calling [[Theme.style]] method.\n *\n * Theme style is either a function, or an extension of another theme style.\n */\nexport type ThemeStyle = ThemeStyle.Provider | ThemeStyle.Extension;\n\nexport namespace ThemeStyle {\n\n  /**\n   * Theme style provider function.\n   *\n   * This function is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n   *\n   * This function is used as an identifier of particular style and can be extended using [[ThemeStyle.Extension]].\n   *\n   * It is not absolutely necessary to register style provider. It will be applied on request anyway.\n   *\n   * @param theme  A theme to apply styling to.\n   *\n   * @returns Dynamically updated CSS rule set containing the applied styling.\n   */\n  export type Provider = (this: void, theme: Theme) => StypRules;\n\n  /**\n   * Theme style extension.\n   *\n   * An extension should be registered in bootstrap context in order to be applied.\n   */\n  export interface Extension {\n\n    /**\n     * A theme style provider to extend.\n     */\n    readonly style: ThemeStyle.Provider;\n\n    /**\n     * Extends the theme style.\n     *\n     * This method is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n     *\n     * It will be called after the style provider it extends.\n     *\n     * @param theme  A theme to apply styling to.\n     *\n     * @returns Dynamically updated CSS rule set containing the applied styling.\n     */\n    provide(theme: Theme): StypRules;\n\n  }\n\n  /**\n   * A function obtaining combined style provider. I.e. the one that applies the style along with all extensions.\n   *\n   * @param A  provider of theme style to apply.\n   *\n   * @returns A combined theme style provider.\n   */\n  export type ById = (this: void, style: ThemeStyle.Provider) => ThemeStyle.Provider;\n\n}\n\nclass ThemeStyleKey extends SimpleContextKey<ThemeStyle.ById, ThemeStyle> {\n\n  constructor() {\n    super('theme-style');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, ThemeStyle.ById, ThemeStyle, AIterable<ThemeStyle>>,\n  ): ThemeStyle.ById | null | undefined {\n\n    const providers = new Map<ThemeStyle.Provider, [ThemeStyle.Provider, boolean]>();\n\n    opts.seed.forEach(style => {\n\n      let key: ThemeStyle.Provider;\n      let provider: ThemeStyle.Provider;\n      let isId: boolean;\n\n      if (typeof style === 'function') {\n        key = provider = style;\n        isId = true;\n      } else {\n        key = style.style;\n        provider = style.provide.bind(style);\n        isId = false;\n      }\n\n      const prev = providers.get(key);\n\n      if (!prev) {\n        providers.set(key, [provider, isId]);\n      } else {\n\n        const [prevProvider, hasId] = prev;\n\n        providers.set(\n            key,\n            [\n              isId ? combineStyles(provider, prevProvider) : combineStyles(prevProvider, provider),\n              isId || hasId,\n            ]);\n      }\n    });\n\n    return providers.size ? byId : opts.byDefault(() => byId);\n\n    function byId(id: ThemeStyle.Provider): ThemeStyle.Provider {\n\n      const existing = providers.get(id);\n\n      if (!existing) {\n        return id;\n      }\n\n      const [provider, hasId] = existing;\n\n      return hasId ? provider : combineStyles(id, provider);\n    }\n  }\n\n}\n\n/**\n * A key of bootstrap context value containing theme styles.\n */\nexport const ThemeStyle: ContextRef<ThemeStyle.ById, ThemeStyle> = new ThemeStyleKey();\n\nfunction combineStyles(first: ThemeStyle.Provider, second: ThemeStyle.Provider): ThemeStyle.Provider {\n  return theme => stypRules(first(theme), second(theme));\n}\n","import { lazyStypRules, stypRoot, StypRule, StypRules } from 'style-producer';\nimport { Theme as Theme_ } from './theme';\nimport { ThemeStyle } from './theme-style';\n\n/**\n * @internal\n */\nexport class Theme extends Theme_ {\n\n  readonly root: StypRule = stypRoot();\n  private readonly _rules = new Map<ThemeStyle.Provider, StypRules>();\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  style(...styles: ThemeStyle.Provider[]): StypRules {\n\n    const theme = this;\n\n    return lazyStypRules(...styles.reduce<StypRules[]>(addStyleRules, []));\n\n    function addStyleRules(target: StypRules[], style: ThemeStyle.Provider) {\n\n      const existing = theme._rules.get(style);\n\n      if (existing) {\n        target.push(existing);\n      } else {\n\n        const constructed = theme._styles(style)(theme);\n\n        theme._rules.set(style, constructed);\n        target.push(constructed);\n      }\n\n      return target;\n    }\n  }\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { BasicStyleProducerSupport } from '../styp';\nimport { Theme } from './theme';\nimport { ThemeFactory } from './theme-factory';\nimport { ThemeFactory as ThemeFactory_ } from './theme-factory.impl';\nimport { ThemeStyle } from './theme-style';\n\nconst ThemeSupport__feature: FeatureDef = {\n  needs: BasicStyleProducerSupport,\n  set: [\n    { a: ThemeFactory, as: ThemeFactory_, with: [ThemeStyle] },\n    {\n      a: Theme,\n      by(factory: ThemeFactory) {\n        return factory.newTheme();\n      },\n      with: [ThemeFactory],\n    },\n  ],\n};\n\n/**\n * Theme support feature.\n *\n * This needs to be enabled in order [[Theme]] and [[ThemeFactory]] to be available.\n */\nexport class ThemeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ThemeSupport__feature;\n  }\n\n}\n","import { ThemeFactory as ThemeFactory_ } from './theme-factory';\nimport { ThemeStyle } from './theme-style';\nimport { Theme } from './theme.impl';\n\n/**\n * @internal\n */\nexport class ThemeFactory extends ThemeFactory_ {\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  newTheme() {\n    return new Theme(this._styles);\n  }\n\n}\n","/**\n * @module @wesib/generic\n */\nimport { ComponentContext } from '@wesib/wesib';\nimport { AIterable } from 'a-iterable';\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n  ValueTracker,\n} from 'fun-events';\n\n/**\n * Component tree node representing arbitrary element.\n */\nexport abstract class ElementNode {\n\n  /**\n   * The element itself.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  abstract readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  abstract readonly parent: ElementNode | null;\n\n  /**\n   * Select element nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested components. E.g. component element name.\n   * @param opts  Element selector options.\n   */\n  abstract select(\n      selector: string,\n      opts: ElementNode.ElementSelectorOpts,\n  ): ElementNodeList;\n\n  /**\n   * Select component nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested components. E.g. component element name.\n   * @param opts  Component selector options.\n   */\n  abstract select(\n      selector: string,\n      opts?: ElementNode.ComponentSelectorOpts,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Returns a value tracker of element's attribute.\n   *\n   * @param name  Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  abstract attribute(name: string): ValueTracker<string | null, string>;\n\n  /**\n   * Returns a value tracker of element's property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @param key  Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  abstract property<V>(key: PropertyKey): ValueTracker<V>;\n\n}\n\nexport namespace ElementNode {\n\n  /**\n   * Element node representing raw element no bound to any component.\n   */\n  export interface Raw extends ElementNode {\n\n    readonly context?: undefined;\n\n  }\n\n  /**\n   * Any element node. Either bound to some component or not.\n   */\n  export type Any = Raw | ComponentNode;\n\n  /**\n   * Element node selector options.\n   */\n  export interface SelectorOpts {\n\n    /**\n     * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n     */\n    all?: boolean;\n\n    /**\n     * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n     */\n    deep?: boolean;\n\n  }\n\n  /**\n   * Component node selector options.\n   */\n  export interface ComponentSelectorOpts extends SelectorOpts {\n\n    all?: false;\n\n  }\n\n  /**\n   * Any element node selector options.\n   */\n  export interface ElementSelectorOpts extends SelectorOpts {\n\n    /**\n     * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n     */\n    all: true;\n\n  }\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = object> extends ElementNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> =\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>('component-node');\n\n/**\n * Dynamic list of selected component tree nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n */\nexport abstract class ElementNodeList<N extends ElementNode = ElementNode.Any>\n    extends AIterable<N>\n    implements EventSender<[N[], N[]]>, EventKeeper<[ElementNodeList<N>]> {\n\n  /**\n   * An `OnEvent` sender of list changes. Sends arrays of added and removed nodes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[N[], N[]]>;\n\n  get [OnEvent__symbol](): OnEvent<[N[], N[]]> {\n    return this.onUpdate;\n  }\n\n  /**\n   * An `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[ElementNodeList<N>]>;\n\n  get [AfterEvent__symbol](): AfterEvent<[ElementNodeList<N>]> {\n    return this.read;\n  }\n\n  /**\n   * An `AfterEvent` keeper of the first node in this list.\n   */\n  abstract readonly first: AfterEvent<[N?]>;\n\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { filterIt, itsEach, itsFirst, itsIterator, mapIt, overArray } from 'a-iterable';\nimport { AfterEvent, afterEventBy, afterSupplied, EventEmitter, eventSupply, onEventBy } from 'fun-events';\nimport { ElementNode, ElementNodeList as ElementNodeList_ } from './element-node';\n\nconst WATCH_CHILD_LIST = { childList: true };\nconst WATCH_DEEP = { childList: true, subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<N extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string,\n    nodeOf: (node: Element, optional?: boolean) => N | undefined,\n    { deep, all }: ElementNode.SelectorOpts,\n): ElementNodeList_<N> {\n\n  const Observer: typeof MutationObserver = (bsContext.get(BootstrapWindow) as any).MutationObserver;\n  const observer = new Observer(update);\n  const updates = new EventEmitter<[N[], N[]]>();\n  const init: MutationObserverInit = deep ? WATCH_DEEP : WATCH_CHILD_LIST;\n  let cache = new Set<Element>();\n  let iterable: Iterable<N> | undefined;\n  let nodeList: ElementNodeList;\n\n  const onUpdate = onEventBy<[N[], N[]]>(receiver => {\n\n    const firstReceiver = !updates.size;\n    const supply = updates.on(receiver);\n\n    if (firstReceiver) {\n      refresh();\n      observer.observe(root, init);\n    }\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      if (!updates.size) {\n        observer.disconnect();\n      }\n    }).needs(supply);\n  });\n  const read = afterEventBy<[ElementNodeList]>(onUpdate.thru(() => nodeList), () => [nodeList]);\n  const first: AfterEvent<[N?]> = afterSupplied(read).keep.thru(itsFirst);\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as N;\n\n        updates.send([node], [node]);\n      }\n    });\n  }\n\n  class ElementNodeList extends ElementNodeList_<N> {\n\n    get onUpdate() {\n      return onUpdate;\n    }\n\n    get read() {\n      return read;\n    }\n\n    get first() {\n      return first;\n    }\n\n    [Symbol.iterator]() {\n      return itsIterator(iterable || (iterable = filterIt<N | undefined, N>(\n          mapIt(\n              elements(),\n              element => nodeOf(element),\n          ),\n          isPresent,\n      )));\n    }\n\n  }\n\n  return nodeList = new ElementNodeList();\n\n  function elements(): Set<Element> {\n    return updates.size ? cache : refresh();\n  }\n\n  function refresh(): Set<Element> {\n    iterable = undefined;\n    return cache = new Set<Element>(request());\n  }\n\n  function request(): Set<Element> {\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(selector)));\n    }\n    return new Set(\n        filterIt(\n            overArray(root.children),\n            item => item.matches(selector),\n        ),\n    );\n  }\n\n  function update(mutations: MutationRecord[]) {\n\n    const added: N[] = [];\n    const removed: N[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overArray(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overArray(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n\nfunction isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n\nfunction isPresent<T>(item: T | undefined): item is T {\n  return item != null;\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver, eventSupply,\n  EventSupply,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n  ValueTracker,\n} from 'fun-events';\n\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer: typeof MutationObserver = (this._bs.get(BootstrapWindow) as any).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string, string | null]>): EventSupply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: eventSupply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect() {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: [...self._emitters.keys()],\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]) {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string, string | null]> {\n\n    const emitter = new EventEmitter<[string, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\nclass AttributeTracker extends ValueTracker<string | null, string> {\n\n  private readonly _updates = new EventEmitter<[string, string | null]>();\n  readonly on: OnEvent<[string, string | null]>;\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n\n    let observeSupply = noEventSupply();\n\n    this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            _name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    });\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    this._observer.element.setAttribute(this._name, value as string);\n  }\n\n  done(reason?: any): this {\n    this._updates.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null, string> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\nimport { EventEmitter, eventSupply, noEventSupply, OnEvent, ValueTracker } from 'fun-events';\n\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n  private _supply = noEventSupply();\n\n  constructor(\n      private readonly _element: any,\n      private readonly _key: PropertyKey) {\n    super();\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._updates.on;\n  }\n\n  bind(context: ComponentContext) {\n\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    this._supply = propertyState.onUpdate({\n      supply: eventSupply().whenOff(reason => this._updates.done(reason)),\n      receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n    });\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  done(reason?: any): this {\n    this._supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext) {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import {\n  BootstrapContext,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ValueTracker } from 'fun-events';\nimport { ComponentNode, ElementNode as ElementNode_, ElementNodeList } from './element-node';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\nconst NODE_REF = /*#__PURE__*/ Symbol('element-node');\n\nclass ElementNode extends ElementNode_ {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n    super();\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    (element as any)[NODE_REF] = this;\n\n    const context = (element as any)[ComponentContext__symbol] as ComponentContext<any> | undefined;\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext<any> | undefined {\n    return (this.element as any)[ComponentContext__symbol];\n  }\n\n  get parent() {\n\n    const parent = this.element.parentElement;\n\n    return parent != null ? elementNodeOf(this._bs, parent) : null;\n  }\n\n  select(selector: string, opts?: ElementNode_.SelectorOpts): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, opts);\n  }\n\n  attribute(name: string): ValueTracker<string | null, string> {\n    return this._attrs.get(name);\n  }\n\n  property<V>(key: PropertyKey): ValueTracker<V> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext) {\n    this._props.bind(context);\n  }\n\n}\n\nexport function elementNodeOf(bs: BootstrapContext, element: Element, optional?: boolean): ElementNode_.Any {\n\n  const found: ElementNode_.Any = (element as any)[NODE_REF];\n\n  if (optional || found) {\n    return found;\n  }\n\n  return new ElementNode(bs, element) as ElementNode_.Raw;\n}\n\nfunction selectNodes(\n    bs: BootstrapContext,\n    root: Element,\n    selector: string,\n    opts: ElementNode_.SelectorOpts = {}): ElementNodeList<any> {\n\n  const adapter = bs.get(ElementAdapter);\n\n  if (opts.all) {\n    return elementNodeList<ElementNode_.Any>(\n        bs,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bs, element, optional),\n        opts,\n    );\n  }\n  return elementNodeList<ComponentNode<any>>(\n      bs,\n      root,\n      selector,\n      (element, optional) => {\n        if (adapter(element)) {\n          return elementNodeOf(bs, element, optional) as ComponentNode<any>;\n        }\n        return undefined;\n      },\n      opts,\n  );\n}\n","/**\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext, FeatureDef, FeatureDef__symbol, StateSupport } from '@wesib/wesib';\nimport { ComponentNode } from './element-node';\nimport { elementNodeOf } from './element-node.impl';\n\nconst ComponentTreeSupport__feature: FeatureDef = {\n  needs: StateSupport,\n  perComponent: {\n    a: ComponentNode,\n    by(context: ComponentContext) {\n      return elementNodeOf(context.get(BootstrapContext), context.element) as ComponentNode;\n    },\n  },\n};\n\n/**\n * Component tree support feature.\n *\n * Provides a [[ComponentNode]] instance for each component.\n */\nexport class ComponentTreeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ComponentTreeSupport__feature;\n  }\n\n}\n"],"names":["BootstrapContext__key","SingleContextKey","BootstrapContext","ContextValues","ContextKey__symbol","bootstrapDefault","provide","context","key","bootstrapContext","get","ComponentFactory__key","ComponentFactory","[object Object]","element","mount","this","mountTo","connected","BootstrapWindow","byDefault","window","DefaultNamespaceAliaser","ctx","document","body","isArray","value","Array","ArraySet","AIterable","super","items","Set","size","Symbol","iterator","next","forEach","item","add","mergeFunctions","first","second","merge","_f","s","args","apply","MetaAccessor","symbol","type","def","superType","superClassOf","satisfying","prototype","Object","getPrototypeOf","constructor","st","superDef","of","defs","prevDef","defineProperty","configurable","PromiseResolver","promise","Promise","resolve","reject","_resolve","_reject","error","FeatureDef__symbol","FeatureMeta","reduce","prev","set","needs","has","init","perDefinition","perComponent","meta","FeatureDef","featureType","define","Feature","FeatureContext_key","FeatureContext","onDefinition","onComponent","componentType","whenDefined","feature","load","FeatureNeedsError","Error","reason","need","name","ComponentDef__symbol","ComponentMeta","ComponentDef","Component","ComponentContext__key","ComponentEventDispatcher__key","dispatch","event","dispatchEvent","on","DomEventDispatcher","ContentRoot","StateUpdater","FnContextKey","valueProvider","noop","ComponentContext__symbol","ComponentContext","updateComponentState","bind","TypeError","contentRoot","newValue","oldValue","ComponentEvent","Event","eventInitDict","target","ComponentMount","component","ElementAdapter","ContextUpKey","opts","defaultElementAdapter","result","seed","adapters","combined","adapter","ComponentFactory__symbol","componentFactoryOf","factory","CustomElements__key","values","customElements","nsAlias","CustomElements","componentTypeOrName","elementType","isQualifiedName","html__naming","extend","elementDef","extends","componentResolver","undefined","ComponentResolver__symbol","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","BootstrapValueRegistry__key","BootstrapValueRegistry","ContextRegistry","a","is","newValues","ComponentValueRegistry__key","ComponentValueRegistry","initial","DefinitionValueRegistry__key","DefinitionValueRegistry","ComponentStatus__symbol","elementStatus","ElementBuilder__key","ElementBuilder","EventEmitter","_definitionValueRegistry","_componentValueRegistry","builder","typeValueRegistry","ready","trackValue","whenReady","read","thru","cls","nextArgs","nextSkip","definitionContext","createValueRegistry","append","componentFactory","ComponentFactory_","_createComponent","valueRegistry","elementSuper","createMount","ComponentMount_","it","el","doc","ownerDocument","contains","checkConnected","componentCreated","DefinitionContext_","definitionRegistry","seedIn","spec","callback","once","call","definitions","send","_elementType","enumerable","Element","status","aliveSupply","sts","whenOff","whenOn","offSupply","eventSupply","off","ComponentContext_","done","whenDestroyed","parentNode","parentElement","removeChild","removeElement","writable","components","proto","prevContext","newComponent","bubbles","ComponentRegistry","_context","_definitionQueue","definition","push","buildElement","FeatureKey__symbol","FeatureKey","feat","bsContext","from","keep","preferredFeatureClause","afterEventBy","receiver","origin","source","afterThe","stageId","afterAll","clause","deps","loadFeatureDeps","dig_","request","thru_","loader","to","stage","ownLoader","FeatureLoader","ownSource","rcv","unload","share","lastLoader","preventDuplicateLoader","clauses","preferred","required","afterEach","map","dep","presentFeatureDeps","filterIt","mapIt","isPresent","down","_down","_stage","SetupFeatureStage","then","after","state","lastStage","id","setup","prevStage","stop","FeatureStage","_stop","action","all","perDep","unloads","componentRegistry","definitionValueRegistry","componentValueRegistry","registry","newFeatureContext","bootstrapValueRegistry","InitFeatureStage","async","ActiveFeatureStage","FeatureRequest","_requester","requester","isClause","_revokeBy","unuse","_uses","_revoke","revoke","FeatureRequester__key","FeatureRequester","Map","existing","_map","reuse","bootstrapComponents","features","bootstrapRegistry","create","complete","by","newNamespaceAliaser","info","supply","_ctx","ldr","initBootstrap","length","AttributePath__root","attributeStateUpdate","updateState","attributePathTo","update","defaultUpdateState","path","AttributeRegistrar","AttributeRegistry__key","AttributeRegistry","_MutationObserver","MutationObserver","_attrs","attrs","observedAttributes","keys","attributeFilter","records","record","attributeName","getAttribute","observe","attributes","attributeOldValue","AttributesSupport__feature","as","with","componentContext","AttributesSupport","Attribute","propertyKey","descriptor","toString","parseAttributeDef","newDesc","setAttribute","DomPropertyPath__root","ComponentState__key","ComponentState","StateTracker","StateSupport__feature","StateSupport","RenderScheduler__key","RenderScheduler","ElementRender","render","stateTracker","schedule","newSchedule","offline","rendered","stateSupply","onUpdate","scheduleRender","renderElement","newRender","RenderSupport__feature","RenderScheduler_","scheduled","previouslyScheduled","requestAnimationFrame","RenderSupport","Render","defContext","ShadowContentRoot","ShadowDomEvent","shadowRoot","ShadowRootBuilder","ShadowDomSupport__feature","attachShadow","shadowRootOf","ShadowDomSupport","defaultShadowContentDef","mode","ShadowContentDef","componentDef","or","AttachShadow","FetchAgentKey","agent","agents","fetch","agentIdx","agentRequest","onSupplied","nextRequest","combineFetchAgents","defaultFetchAgent","HttpFetchAgent","HttpFetchAborted","HttpFetch","input","Request","onEventBy","responseEmitter","abortController","AbortController","signal","abort","response","receive","customSignal","aborted","catch","EnterPageEvent","cancelable","when","LeavePageEvent","StayOnPageEvent","Navigation__key","Navigation","OnEvent__symbol","AfterEvent__symbol","go","NavigationAgentKey","combinedAgent","sources","navigate","agentTo","url","nextURL","title","nextTitle","data","nextData","URL","String","baseURI","visited","current","ref","put","NavigationAgent","PageParam__symbol","PageParam","PageParamContext","RoutingHistory__key","NavHistory","_document","_location","location","_history","history","_uid","btoa","Math","random","extractNavData","entry","newEntry","href","_entries","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","tracker","page","pushState","_enter","fromEntry","e","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","delete","forget","NAV_DATA_KEY","_params","_status","handle","param","newHandle","itsEach","entries","transferred","at","stay","clear","_update","NavigationSupport__feature","dispatcher","navHistory","onEnter","onLeave","onStay","onEvent","onAny","nav","nextEntry","readPage","hashChange","Navigation_","delta","toURL","withParam","applyParams","open","replace","whenLeave","urlTarget","urlTargetOf","doNavigate","prepared","leavePage","finalTarget","t","prepare","cachingPageLoader","pageUrl","sup","tracked","onLoad","trackSupply","resp","num","requested","PageLoadAbortError","PageLoadRequests","_navigation","_loader","fragments","fragment","itsIterator","flatMapIt","asis","self","pageSupply","loadSupply","noEventSupply","_add","_transfer","pageLoadRequestsParam","responseReceiver","emitter","ok","tag","getElementsByTagName","getElementById","onFragment","req","eventReceiver","list","_page","requests","PageLoadAgent","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","Accept-Fragment","itsReduction","header","hthvQuote","pageFragmentsRequest","responseTextEmitter","onResponse","text","parsePageDocument","start","responseSupply","parseFromString","hthvParse","v","head","base","querySelector","newBase","createElement","appendChild","pageLoadParam","PageCacheBuster__key","PageCacheBuster","appRevSearchParam","rev","appRev","navigation","urlModifier","searchParams","newRev","URLSearchParams","reload","importNode","beforeOrImport","importContent","importNodeContent","before","nodeType","Node","ELEMENT_NODE","nodeClone","insertBefore","elementClone","tagName","toLowerCase","getAttributeNames","attr","overArray","childNodes","node","externalScripts","scripts","script","src","PageLoadSupport__feature","buster","allScripts","querySelectorAll","_from","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","itsFirst","nextSibling","style","textContent","PageLoadSupport","ComponentStyleProducer","ComponentStypRender","MultiContextKey","ElementIdClass__NS","NamespaceDef","ElementIdClass","contextValues","aliaser","local","uniqueClassSeq","qualified","css__naming","classList","ComponentStyleProducer__key","hostSelector","_produce","produceBasicStyle","rules","options","parent","rootSelector","scheduler","operation","buildScheduler","renders","idClass","order","producer","properties","selector","c","buildRender","BasicStyleProducerSupport__feature","ComponentStyleProducer_","produce","BasicStyleProducerSupport","ComponentStypOptions","css","lazyStypRules","produceStyle","doProduceStyle","cssSupply","connectionSupply","ProduceStyle","property","Theme__key","Theme","referrer","root","ThemeFactory__key","ThemeFactory","ThemeStyle","SimpleContextKey","providers","provider","isId","prevProvider","hasId","combineStyles","byId","theme","stypRules","Theme_","_styles","stypRoot","styles","_rules","constructed","ThemeSupport__feature","ThemeFactory_","newTheme","ThemeSupport","ElementNode","ComponentNode","ElementNodeList","WATCH_CHILD_LIST","childList","WATCH_DEEP","subtree","elementNodeList","nodeOf","deep","observer","Observer","mutations","added","removed","mutation","removedNodes","removeNode","addedNodes","addNode","updates","iterable","nodeList","cache","firstReceiver","refresh","disconnect","afterSupplied","addEventListener","ElementNodeList_","children","matches","isElement","AttributesObserver","_bs","_observer","_emitter","_emitters","reconnect","takeRecords","AttributeTracker","ValueTracker","_name","observeSupply","_updates","NodeAttributes","bs","created","PropertyTracker","_element","_key","propertyState","track","_supply","_path","NodeProperties","_props","prop","NODE_REF","ElementNode_","_bind","elementNodeOf","optional","selectNodes","found","ComponentTreeSupport__feature","ComponentTreeSupport"],"mappings":"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"}